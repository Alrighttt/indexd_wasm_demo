<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>indexd WASM Demo</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #0a0a0a; color: #e0e0e0; padding: 2rem; max-width: 800px; margin: 0 auto; }
    h1 { font-size: 1.5rem; margin-bottom: 1.5rem; color: #fff; }
    h2 { font-size: 1.1rem; margin-bottom: 0.75rem; color: #b0b0b0; }
    section { background: #151515; border: 1px solid #2a2a2a; border-radius: 8px; padding: 1.25rem; margin-bottom: 1.25rem; }
    button { background: #1a6b3c; color: #fff; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer; font-size: 0.875rem; }
    button:hover { background: #1f8148; }
    button:disabled { background: #333; color: #666; cursor: not-allowed; }
    input, textarea { background: #1a1a1a; color: #e0e0e0; border: 1px solid #333; border-radius: 4px; padding: 0.5rem; width: 100%; font-family: monospace; font-size: 0.8rem; }
    textarea { resize: vertical; min-height: 3rem; }
    .row { display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem; }
    .output { background: #0d0d0d; border: 1px solid #222; border-radius: 4px; padding: 0.75rem; margin-top: 0.75rem; font-family: monospace; font-size: 0.8rem; white-space: pre-wrap; word-break: break-all; min-height: 2rem; }
    .label { font-size: 0.75rem; color: #888; margin-bottom: 0.25rem; }
    .pass { color: #4ade80; }
    .fail { color: #f87171; }
    #loading { text-align: center; padding: 2rem; color: #888; }
    #app { display: none; }
    .dropzone { border: 2px dashed #333; border-radius: 8px; padding: 2rem; text-align: center; color: #666; cursor: pointer; transition: border-color 0.2s, color 0.2s; }
    .dropzone:hover, .dropzone.dragover { border-color: #1a6b3c; color: #4ade80; }
    .dropzone .file-info { color: #e0e0e0; font-size: 0.85rem; margin-top: 0.5rem; }
    hr { border: none; border-top: 1px solid #2a2a2a; margin: 1rem 0; }
    progress { width: 100%; height: 8px; appearance: none; border: none; border-radius: 4px; overflow: hidden; margin-top: 0.5rem; }
    progress::-webkit-progress-bar { background: #1a1a1a; border-radius: 4px; }
    progress::-webkit-progress-value { background: #1a6b3c; border-radius: 4px; }
    progress::-moz-progress-bar { background: #1a6b3c; border-radius: 4px; }

    /* Browser Navigation Controls */
    .browser-nav { display: flex; flex-direction: column; gap: 0.5rem; margin-top: 1rem; padding: 0.5rem; background: #0d0d0d; border: 1px solid #222; border-radius: 4px; }
    .browser-nav-row { display: flex; gap: 0.5rem; align-items: center; }
    .browser-nav button { padding: 0.4rem 0.75rem; font-size: 0.8rem; min-width: auto; }
    .browser-nav .address-bar { flex: 1; background: #1a1a1a; border: 1px solid #333; border-radius: 4px; padding: 0.4rem 0.6rem; font-family: monospace; font-size: 0.75rem; color: #ddd; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .browser-nav .address-bar:focus { outline: none; border-color: #667eea; background: #222; }
    .browser-container { display: flex; gap: 1rem; margin-top: 1rem; }
    .browser-main { flex: 1; min-width: 0; }
    .browser-history { width: 200px; background: #0d0d0d; border: 1px solid #222; border-radius: 4px; padding: 0.75rem; max-height: 600px; overflow-y: auto; }
    .browser-history h3 { font-size: 0.85rem; color: #b0b0b0; margin-bottom: 0.5rem; }
    .history-item { font-size: 0.75rem; padding: 0.4rem; margin-bottom: 0.25rem; background: #151515; border: 1px solid #2a2a2a; border-radius: 4px; cursor: pointer; transition: background 0.2s; display: flex; align-items: center; gap: 0.5rem; }
    .history-item:hover { background: #1a1a1a; }
    .history-item.active { background: #1a6b3c; border-color: #1f8148; }
    .history-item.downloaded { background: #0d3d20; border-color: #1a6b3c; }
    .history-item.downloaded:hover { background: #114d28; }
    .history-item.active.downloaded { background: #1a6b3c; border-color: #1f8148; }
    .history-title { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; cursor: pointer; }
    .history-delete { flex-shrink: 0; }
  </style>
</head>
<body>
  <h1>indexd WASM Demo</h1>

  <div id="loading">Loading WASM module...</div>

  <div id="app">
    <!-- Configuration -->
    <section>
      <h2>Configuration</h2>
      <div class="label">Indexer URL</div>
      <input id="cfg-url" type="text" placeholder="https://indexer.example.com" style="margin-bottom:0.5rem" />
      <div class="label">App Key (hex seed)</div>
      <input id="cfg-key" type="text" placeholder="e.g. ab12cd34..." style="margin-bottom:0.5rem" />
      <hr />
      <div class="label" style="cursor:pointer; user-select:none;" id="performance-toggle">
        <span id="performance-arrow" style="display:inline-block; transition:transform 0.2s;">‚ñ∂</span> Performance
      </div>
      <div id="performance-section" style="display:none;">
        <div style="display:flex; gap:0.5rem; margin-bottom:0.75rem; margin-top:0.5rem;">
          <button id="preset-conservative" style="flex:1; padding:0.6rem; background:#10b981; color:white; border:none; border-radius:4px; cursor:pointer; font-size:0.85rem;">
            üê¢ Conservative<br><span style="font-size:0.7rem; opacity:0.9;">Most Stable</span>
          </button>
          <button id="preset-balanced" style="flex:1; padding:0.6rem; background:#3b82f6; color:white; border:none; border-radius:4px; cursor:pointer; font-size:0.85rem;">
            ‚öñÔ∏è Balanced<br><span style="font-size:0.7rem; opacity:0.9;">Recommended</span>
          </button>
          <button id="preset-fast" style="flex:1; padding:0.6rem; background:#f59e0b; color:white; border:none; border-radius:4px; cursor:pointer; font-size:0.85rem;">
            üöÄ Fast<br><span style="font-size:0.7rem; opacity:0.9;">May Be Unstable</span>
          </button>
        </div>
        <div class="label" style="margin-top:0.5rem;">Concurrency Limits</div>
        <div style="display:grid; grid-template-columns: 2fr 1fr; gap:0.5rem; align-items:center; margin-bottom:0.5rem;">
          <label style="font-size:0.85rem; color:#999;">Max Price Fetches:</label>
          <input id="cfg-max-price-fetches" type="number" min="1" max="10" value="10" style="padding:0.4rem; text-align:center;" />
          <label style="font-size:0.85rem; color:#999;">Max Downloads:</label>
          <input id="cfg-max-downloads" type="number" min="1" max="20" value="20" style="padding:0.4rem; text-align:center;" />
          <label style="font-size:0.85rem; color:#999;">Max Uploads:</label>
          <input id="cfg-max-uploads" type="number" min="1" max="20" value="16" style="padding:0.4rem; text-align:center;" />
        </div>
        <div style="font-size:0.75rem; color:#999; margin-bottom:0.75rem; line-height:1.4;">
          üí° Lower = more stable, higher = faster. Changes require reconnecting SDK.
        </div>
      </div>
      <hr />
      <div class="label">Recovery Phrase</div>
      <div class="row">
        <input id="phrase" type="text" placeholder="recovery phrase appears here" />
        <button id="btn-generate">Generate</button>
        <button id="btn-validate">Validate</button>
      </div>
      <div class="output" id="phrase-output"></div>

    </section>

    <!-- Register -->
    <section>
      <h2>Register App</h2>
      <div class="label">App Name</div>
      <input id="reg-name" type="text" placeholder="My App" style="margin-bottom:0.5rem" />
      <div class="label">App Description</div>
      <input id="reg-desc" type="text" placeholder="A brief description of your app" style="margin-bottom:0.5rem" />
      <div class="label">Service URL</div>
      <input id="reg-service-url" type="text" placeholder="https://myapp.example.com" style="margin-bottom:0.5rem" />
      <div class="row">
        <button id="btn-request-connection">1. Request Connection</button>
      </div>
      <div class="output" id="reg-status" style="display:none;"></div>
      <div id="reg-approval" style="display:none; margin-top:0.75rem;">
        <div class="label">Approve the connection by visiting the link above, then:</div>
        <div class="row">
          <button id="btn-wait-approval">2. Wait for Approval</button>
        </div>
      </div>
      <div id="reg-finalize" style="display:none; margin-top:0.75rem;">
        <div class="label">Recovery Phrase (uses the phrase from Configuration above, or enter one here)</div>
        <div class="row">
          <input id="reg-mnemonic" type="text" placeholder="leave blank to use the phrase above" />
          <button id="btn-reg-generate">Generate</button>
        </div>
        <div class="row" style="margin-top:0.5rem">
          <button id="btn-register">3. Register</button>
        </div>
      </div>
      <div class="output" id="reg-result" style="display:none; margin-top:0.75rem;"></div>
    </section>

    <!-- Account Dashboard -->
    <section id="account-dashboard">
      <h2>Account Dashboard</h2>
      <div class="row" style="margin-bottom:1rem;">
        <button id="btn-refresh-account">Load Account Data</button>
      </div>

      <!-- Storage Usage Bar -->
      <div style="margin-bottom:1.5rem;">
        <div style="display:flex; justify-content:space-between; margin-bottom:0.5rem; align-items:baseline;">
          <span style="font-weight:500;">Storage Usage</span>
          <span id="account-storage-text" style="color:#888; font-size:0.9rem;">Loading...</span>
        </div>
        <div style="width:100%; height:24px; background:#0a0a0a; border-radius:6px; overflow:hidden; border:1px solid #222;">
          <div id="account-storage-bar" style="width:0%; height:100%; background:linear-gradient(90deg, #10b981, #059669); transition:width 0.3s;"></div>
        </div>
        <div style="display:flex; justify-content:space-between; margin-top:0.25rem; font-size:0.85rem; color:#666;">
          <span id="account-used-label">Used: 0 GB</span>
          <span id="account-free-label">Free: 0 GB</span>
        </div>

        <!-- Prune Slabs -->
        <div style="margin-top:1rem; padding:1rem; background:#0a0a0a; border-radius:6px; border:1px solid #222;">
          <div style="display:flex; justify-content:space-between; align-items:center; gap:1rem;">
            <div style="flex:1;">
              <div style="font-weight:500; margin-bottom:0.25rem; color:#e0e0e0;">Clean Up Storage</div>
              <div style="color:#888; font-size:0.85rem;">Remove unused slabs to reclaim space</div>
            </div>
            <button id="btn-prune-slabs" style="padding:0.5rem 1rem; background:#8b5cf6; color:white; border:none; border-radius:4px; cursor:pointer; white-space:nowrap; font-size:0.9rem; font-weight:500;">
              üßπ Prune Slabs
            </button>
          </div>
        </div>
      </div>

      <!-- Quick Stats Grid -->
      <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(150px, 1fr)); gap:1rem; margin-bottom:1.5rem;">
        <div style="background:#0a0a0a; padding:1.25rem; border-radius:6px; border:1px solid #222;">
          <div style="color:#888; font-size:0.85rem; margin-bottom:0.5rem;">Objects Stored</div>
          <div id="account-objects-count" style="font-size:1.75rem; font-weight:600; color:#10b981;">-</div>
        </div>
        <div style="background:#0a0a0a; padding:1.25rem; border-radius:6px; border:1px solid #222;">
          <div style="color:#888; font-size:0.85rem; margin-bottom:0.5rem;">Storage Used</div>
          <div id="account-used-storage" style="font-size:1.75rem; font-weight:600; color:#3b82f6;">-</div>
        </div>
        <div style="background:#0a0a0a; padding:1.25rem; border-radius:6px; border:1px solid #222;">
          <div style="color:#888; font-size:0.85rem; margin-bottom:0.5rem;">Capacity</div>
          <div id="account-capacity-percent" style="font-size:1.75rem; font-weight:600; color:#8b5cf6;">-</div>
        </div>
        <div style="background:#0a0a0a; padding:1.25rem; border-radius:6px; border:1px solid #222;">
          <div style="color:#888; font-size:0.85rem; margin-bottom:0.5rem;">Total Stored (3x)</div>
          <div id="account-total-stored" style="font-size:1.75rem; font-weight:600; color:#f59e0b;">-</div>
        </div>
      </div>

      <!-- Account Details -->
      <div style="background:#0a0a0a; padding:1.25rem; border-radius:6px; border:1px solid #222;">
        <h3 style="margin:0 0 1rem 0; font-size:1rem; color:#e0e0e0;">Account Details</h3>
        <div style="display:grid; gap:0.75rem; font-size:0.9rem;">
          <div style="display:flex; justify-content:space-between;">
            <span style="color:#888;">App Name:</span>
            <span id="account-app-name" style="color:#e0e0e0; font-family:monospace;">-</span>
          </div>
          <div style="display:flex; justify-content:space-between;">
            <span style="color:#888;">Account Key:</span>
            <span id="account-key" style="color:#e0e0e0; font-family:monospace; font-size:0.8rem;" title="">-</span>
          </div>
          <div style="display:flex; justify-content:space-between;">
            <span style="color:#888;">Last Used:</span>
            <span id="account-last-used" style="color:#e0e0e0;">-</span>
          </div>
          <div style="display:flex; justify-content:space-between;">
            <span style="color:#888;">Storage Limit:</span>
            <span id="account-max-storage" style="color:#e0e0e0;">-</span>
          </div>
        </div>
      </div>

      <div class="output" id="account-status" style="margin-top:1rem;"></div>
    </section>

    <!-- CORS Diagnostics -->
    <section>
      <h2>üîß CORS Diagnostics</h2>
      <p style="color:#888; font-size:0.9rem; margin-bottom:1rem;">
        Test endpoints to verify CORS preflight (OPTIONS) support. If these fail with CORS errors, the endpoints need OPTIONS routes added.
      </p>

      <div style="display:grid; gap:1rem;">
        <!-- Test POST /slabs -->
        <div style="padding:1rem; background:#0a0a0a; border-radius:6px; border:1px solid #222;">
          <div style="font-weight:500; margin-bottom:0.5rem;">POST /slabs</div>
          <div style="color:#888; font-size:0.85rem; margin-bottom:0.75rem;">
            Attempts to pin a test slab with random data. Should trigger CORS preflight due to signed authentication headers.
          </div>
          <button id="btn-test-post-slab" style="width:100%; padding:0.6rem; background:#3b82f6; color:white; border:none; border-radius:4px; cursor:pointer;">
            Test POST /slabs
          </button>
          <div class="output" id="test-post-slab-status" style="margin-top:0.5rem; display:none;"></div>
        </div>

        <!-- Test DELETE /slabs/:slabid -->
        <div style="padding:1rem; background:#0a0a0a; border-radius:6px; border:1px solid #222;">
          <div style="font-weight:500; margin-bottom:0.5rem;">DELETE /slabs/:slabid</div>
          <div style="color:#888; font-size:0.85rem; margin-bottom:0.75rem;">
            Attempts to delete a slab (will fail if slab doesn't exist, but CORS check happens first). Tests DELETE method preflight.
          </div>
          <input id="test-slab-id" type="text" placeholder="Slab ID (hex) - leave blank to use random ID" style="width:100%; margin-bottom:0.5rem;" />
          <button id="btn-test-delete-slab" style="width:100%; padding:0.6rem; background:#ef4444; color:white; border:none; border-radius:4px; cursor:pointer;">
            Test DELETE /slabs/:slabid
          </button>
          <div class="output" id="test-delete-slab-status" style="margin-top:0.5rem; display:none;"></div>
        </div>

        <!-- Results Summary -->
        <div style="padding:1rem; background:#0a0a0a; border-radius:6px; border:1px solid #222;">
          <div style="font-weight:500; margin-bottom:0.5rem;">üìä Results Summary</div>
          <div id="cors-summary" style="color:#888; font-size:0.85rem;">
            Run tests above to see results. CORS errors indicate missing OPTIONS routes.
          </div>
        </div>
      </div>
    </section>

    <!-- Upload Text -->
    <section>
      <h2>Upload Text</h2>
      <div class="label">Text to upload</div>
      <textarea id="ul-text" rows="4" placeholder="Type or paste text here..."></textarea>
      <div class="row" style="margin-top:0.5rem">
        <button id="btn-upload">Upload</button>
      </div>
      <progress id="ul-progress" max="100" value="0" style="display:none"></progress>
      <div class="output" id="ul-status"></div>
    </section>

    <!-- Upload File -->
    <section>
      <h2>Upload File</h2>
      <div class="dropzone" id="uf-dropzone">
        Drop a file here or click to select
        <input type="file" id="uf-file" style="display:none" />
        <div class="file-info" id="uf-file-info"></div>
      </div>
      <div class="row" style="margin-top:0.5rem">
        <button id="btn-upload-file">Upload</button>
      </div>
      <progress id="uf-progress" max="100" value="0" style="display:none"></progress>
      <div class="output" id="uf-status"></div>
    </section>

    <!-- Download File -->
    <section>
      <h2>Download File</h2>
      <div class="label">Object ID or Share URL</div>
      <input id="dl-url" type="text" placeholder="Paste sia:// URL or object ID (hex)" style="margin-bottom:0.5rem" />
      <div class="label">Filename</div>
      <div class="row">
        <input id="dl-filename" type="text" placeholder="e.g. photo.jpg" />
        <button id="btn-download">Download</button>
      </div>
      <progress id="dl-progress" max="100" value="0" style="display:none"></progress>
      <div class="output" id="dl-status"></div>
    </section>

    <!-- List Objects -->
    <section>
      <h2>My Objects</h2>
      <div class="row">
        <button id="btn-list-objects">Refresh List</button>
        <input id="list-limit" type="number" value="50" min="1" max="1000" style="width:5rem" placeholder="Limit" />
      </div>
      <div class="output" id="list-status"></div>
      <div id="objects-list" style="margin-top:1rem; max-height:400px; overflow-y:auto;">
        <!-- Objects will be displayed here -->
      </div>
    </section>

    <!-- Share Object -->
    <section>
      <h2>Share Object</h2>
      <div class="label">Object ID (hex)</div>
      <input id="share-object-id" type="text" placeholder="e.g. 0e90d697f504..." style="margin-bottom:0.5rem" />
      <div class="label">Expires in</div>
      <div class="row">
        <input id="share-duration" type="number" value="24" min="1" style="width:5rem" />
        <select id="share-unit" style="background:#1a1a1a; color:#e0e0e0; border:1px solid #333; border-radius:4px; padding:0.5rem;">
          <option value="3600000">hours</option>
          <option value="86400000" selected>days</option>
          <option value="604800000">weeks</option>
        </select>
        <button id="btn-share">Generate Link</button>
      </div>
      <div class="output" id="share-status"></div>
    </section>

    <!-- HTML Viewer (Decentralized Browser) -->
    <section>
      <h2>üåê Decentralized Browser</h2>

      <!-- Browser Navigation Controls -->
      <div class="browser-nav" id="browser-nav">
        <div class="browser-nav-row">
          <input type="text" class="address-bar" id="address-bar" placeholder="Paste Sia share URL or object ID..." title="Press Enter or click Go to auto-detect file type" style="flex:1;">
          <button id="btn-go" title="Auto-detect file type and load content" style="background:#10b981; border-color:#10b981; font-weight:bold; padding:0.5rem 2rem;">Go</button>
        </div>
        <div class="browser-nav-row" style="justify-content:flex-start; gap:0.5rem;">
          <button id="btn-external-tab" title="‚ö†Ô∏è Opens in new tab with JavaScript enabled - use only for trusted content" style="background:#f59e0b; border-color:#f59e0b; font-size:0.85rem; padding:0.4rem 0.8rem;">‚ö†Ô∏è Open in External Tab</button>
          <span style="color:#888; font-size:0.8rem; font-style:italic;">Warning: External tab allows JavaScript execution</span>
        </div>
      </div>

      <progress id="iframe-progress" max="100" value="0" style="display:none; margin-top:1rem"></progress>
      <div class="output" id="iframe-status"></div>

      <!-- Browser Container with Iframe and History -->
      <div class="browser-container" id="browser-container">
        <div class="browser-main">
          <iframe id="html-iframe" style="width:100%; height:600px; border:1px solid #333; border-radius:4px; background:white;" sandbox="allow-same-origin"></iframe>
          <!-- MSE Video Player (outside sandboxed iframe) -->
          <div id="video-container" style="display:none; width:100%; height:600px; border:1px solid #333; border-radius:4px; background:#0a0a0a; padding:2rem; box-sizing:border-box;">
            <video id="mse-video" controls autoplay style="width:100%; max-height:100%; background:#000;"></video>
          </div>
        </div>
        <div class="browser-history">
          <h3>üìú History</h3>
          <div id="history-list"></div>
        </div>
      </div>
    </section>

  </div>

  <script type="module">
    import init, {
      generateRecoveryPhrase,
      validateRecoveryPhrase,
      AppKey,
      Builder,
    } from './pkg/indexd_wasm.js';

    // Import file-type for MIME detection
    import {fileTypeFromBlob} from './vendor/file-type.bundle.js';

    // Check browser compatibility on page load
    window.addEventListener('DOMContentLoaded', () => {
      console.log('üåê Browser compatibility check:');
      console.log('  WebTransport:', typeof WebTransport !== 'undefined' ? '‚úÖ Available' : '‚ùå Not available');
      console.log('  Secure context:', window.isSecureContext ? '‚úÖ Yes' : '‚ùå No (requires HTTPS)');
      console.log('  Browser:', navigator.userAgent);

      if (typeof WebTransport === 'undefined') {
        const warning = document.createElement('div');
        warning.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#dc2626;color:white;padding:1rem;text-align:center;z-index:9999;font-weight:bold;';
        warning.innerHTML = '‚ö†Ô∏è WebTransport not supported in this browser. Downloads will fail.<br>Please use Chrome 97+, Edge 97+, or check Safari Feature Flags (Develop ‚Üí Feature Flags ‚Üí WebTransport)';
        document.body.prepend(warning);
      } else if (!window.isSecureContext) {
        const warning = document.createElement('div');
        warning.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#dc2626;color:white;padding:1rem;text-align:center;z-index:9999;font-weight:bold;';
        warning.innerHTML = '‚ö†Ô∏è Page must be served over HTTPS for WebTransport to work. Use https://localhost or deploy to HTTPS server.';
        document.body.prepend(warning);
      }
    });

    let currentKey = null;

    function hex(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function randomHex(len) {
      const arr = new Uint8Array(len);
      crypto.getRandomValues(arr);
      return hex(arr);
    }

    function fromHex(h) {
      const bytes = new Uint8Array(h.length / 2);
      for (let i = 0; i < bytes.length; i++) {
        bytes[i] = parseInt(h.substr(i * 2, 2), 16);
      }
      return bytes;
    }

    function formatSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
      return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
    }

    // Streaming download helper ‚Äî avoids holding the entire file in WASM memory.
    // Returns { blob, elapsed } where blob is assembled from streamed chunks.
    async function streamingDownload(sdk, obj, status, progress, label) {
      progress.style.display = 'block';
      status.textContent = label || 'Downloading...';

      const downloadStart = performance.now();
      let lastProgressUpdate = 0;
      const PROGRESS_THROTTLE_MS = 100;

      const blobParts = [];
      await sdk.downloadStreaming(obj,
        (chunk) => { blobParts.push(chunk); },
        (current, total) => {
          const now = performance.now();
          if (now - lastProgressUpdate >= PROGRESS_THROTTLE_MS || current === total) {
            progress.max = total;
            progress.value = current;
            status.textContent = `${label || 'Downloading'}... ${current}/${total} slabs`;
            lastProgressUpdate = now;
          }
        },
      );

      const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
      progress.value = progress.max;
      return { blob: new Blob(blobParts), elapsed };
    }

    // Auto-restore config from localStorage on page load
    const urlInput = document.getElementById('cfg-url');
    const keyInput = document.getElementById('cfg-key');
    const maxPriceFetchesInput = document.getElementById('cfg-max-price-fetches');
    const maxDownloadsInput = document.getElementById('cfg-max-downloads');
    const maxUploadsInput = document.getElementById('cfg-max-uploads');

    const savedUrl = localStorage.getItem('indexer-url');
    const savedKey = localStorage.getItem('app-key');
    const savedMaxPriceFetches = localStorage.getItem('max-price-fetches');
    const savedMaxDownloads = localStorage.getItem('max-downloads');
    const savedMaxUploads = localStorage.getItem('max-uploads');

    if (savedUrl) urlInput.value = savedUrl;
    if (savedKey) keyInput.value = savedKey;
    if (savedMaxPriceFetches) maxPriceFetchesInput.value = savedMaxPriceFetches;
    if (savedMaxDownloads) maxDownloadsInput.value = savedMaxDownloads;
    if (savedMaxUploads) maxUploadsInput.value = savedMaxUploads;

    // Performance section toggle
    document.getElementById('performance-toggle').addEventListener('click', () => {
      const section = document.getElementById('performance-section');
      const arrow = document.getElementById('performance-arrow');
      if (section.style.display === 'none') {
        section.style.display = 'block';
        arrow.style.transform = 'rotate(90deg)';
      } else {
        section.style.display = 'none';
        arrow.style.transform = 'rotate(0deg)';
      }
    });

    // Save to localStorage when config changes
    urlInput.addEventListener('input', () => {
      localStorage.setItem('indexer-url', urlInput.value.trim());
    });
    keyInput.addEventListener('input', () => {
      localStorage.setItem('app-key', keyInput.value.trim());
    });
    maxPriceFetchesInput.addEventListener('input', () => {
      localStorage.setItem('max-price-fetches', maxPriceFetchesInput.value);
      cachedSdk = null; // Invalidate SDK cache when concurrency settings change
    });
    maxDownloadsInput.addEventListener('input', () => {
      localStorage.setItem('max-downloads', maxDownloadsInput.value);
      cachedSdk = null; // Invalidate SDK cache when concurrency settings change
    });
    maxUploadsInput.addEventListener('input', () => {
      localStorage.setItem('max-uploads', maxUploadsInput.value);
      cachedSdk = null; // Invalidate SDK cache when concurrency settings change
    });

    // helpers to read shared config
    function getUrl() { return document.getElementById('cfg-url').value.trim(); }
    function getKeyHex() { return document.getElementById('cfg-key').value.trim(); }
    function getMaxPriceFetches() { return parseInt(document.getElementById('cfg-max-price-fetches').value) || 10; }
    function getMaxDownloads() { return parseInt(document.getElementById('cfg-max-downloads').value) || 20; }
    function getMaxUploads() { return parseInt(document.getElementById('cfg-max-uploads').value) || 16; }

    // SDK cache to avoid recreating and re-initializing
    let cachedSdk = null;
    let cachedConfig = null;

    async function connectSdk(statusEl) {
      const url = getUrl();
      const keyHex = getKeyHex();
      if (!url || !keyHex) {
        statusEl.innerHTML = '<span class="fail">Set Indexer URL and App Key in Configuration first</span>';
        return null;
      }

      // Return cached SDK if config hasn't changed (include concurrency settings in cache key)
      const maxPriceFetches = getMaxPriceFetches();
      const maxDownloads = getMaxDownloads();
      const maxUploads = getMaxUploads();
      const currentConfig = `${url}|${keyHex}|${maxPriceFetches}|${maxDownloads}|${maxUploads}`;
      if (cachedSdk && cachedConfig === currentConfig) {
        statusEl.innerHTML = '<span class="pass">Using cached connection</span>';
        return cachedSdk;
      }

      statusEl.textContent = 'Creating app key...';
      const seed = fromHex(keyHex);
      const appKey = new AppKey(seed);
      statusEl.textContent = `App key created. Public key: ${appKey.publicKey()}\nConnecting to indexer...`;
      const builder = new Builder(url);

      // Configure concurrency limits
      builder.withMaxPriceFetches(maxPriceFetches);
      builder.withMaxDownloads(maxDownloads);
      builder.withMaxUploads(maxUploads);

      const sdk = await builder.connected(appKey);
      if (!sdk) {
        statusEl.innerHTML = '<span class="fail">App key not recognized by this indexer. Register first.</span>';
        return null;
      }

      // Cache the SDK
      cachedSdk = sdk;
      cachedConfig = currentConfig;
      statusEl.innerHTML = '<span class="pass">Connected!</span>';
      return sdk;
    }

    await init();
    console.log('[JS] WASM module initialized successfully');
    document.getElementById('loading').style.display = 'none';
    document.getElementById('app').style.display = 'block';

    // -- Performance Presets --
    function setPreset(priceFetches, downloads, uploads) {
      document.getElementById('cfg-max-price-fetches').value = priceFetches;
      document.getElementById('cfg-max-downloads').value = downloads;
      document.getElementById('cfg-max-uploads').value = uploads;
      localStorage.setItem('max-price-fetches', priceFetches);
      localStorage.setItem('max-downloads', downloads);
      localStorage.setItem('max-uploads', uploads);
      cachedSdk = null; // Invalidate SDK cache
    }

    document.getElementById('preset-conservative').addEventListener('click', () => setPreset(5, 10, 8));
    document.getElementById('preset-balanced').addEventListener('click', () => setPreset(10, 20, 16));
    document.getElementById('preset-fast').addEventListener('click', () => setPreset(10, 20, 20));

    // -- Recovery Phrase --
    document.getElementById('btn-generate').addEventListener('click', () => {
      const phrase = generateRecoveryPhrase();
      document.getElementById('phrase').value = phrase;
      document.getElementById('phrase-output').innerHTML = '<span class="pass">Generated successfully</span>';
    });

    document.getElementById('btn-validate').addEventListener('click', () => {
      const phrase = document.getElementById('phrase').value.trim();
      const out = document.getElementById('phrase-output');
      if (!phrase) {
        out.innerHTML = '<span class="fail">Enter a phrase first</span>';
        return;
      }
      try {
        validateRecoveryPhrase(phrase);
        out.innerHTML = '<span class="pass">Valid recovery phrase</span>';
      } catch (e) {
        out.innerHTML = `<span class="fail">Invalid: ${e.message}</span>`;
      }
    });

    // -- Register --
    let regBuilder = null;
    let regAppId = null;

    document.getElementById('btn-request-connection').addEventListener('click', async () => {
      const status = document.getElementById('reg-status');
      const approvalDiv = document.getElementById('reg-approval');
      const finalizeDiv = document.getElementById('reg-finalize');
      const resultDiv = document.getElementById('reg-result');
      const btn = document.getElementById('btn-request-connection');

      const url = getUrl();
      const name = document.getElementById('reg-name').value.trim();
      const desc = document.getElementById('reg-desc').value.trim();
      const serviceUrl = document.getElementById('reg-service-url').value.trim();

      status.style.display = 'none';
      approvalDiv.style.display = 'none';
      finalizeDiv.style.display = 'none';
      resultDiv.style.display = 'none';

      if (!url || !name || !desc || !serviceUrl) {
        status.style.display = 'block';
        status.innerHTML = '<span class="fail">Indexer URL (in Configuration) and all fields are required</span>';
        return;
      }

      try {
        btn.disabled = true;
        btn.textContent = 'Requesting connection...';
        status.style.display = 'block';
        status.textContent = 'Requesting connection from indexer...';

        regAppId = randomHex(32);
        regBuilder = new Builder(url);

        const appMetadata = JSON.stringify({
          appID: regAppId,
          name: name,
          description: desc,
          serviceURL: serviceUrl
        });

        await regBuilder.requestConnection(appMetadata);

        const responseUrl = regBuilder.responseUrl();
        status.innerHTML = `<span class="pass">‚úì Connection requested!</span>\n\nApprove this app by visiting:\n<a href="${responseUrl}" target="_blank" rel="noopener" style="color:#60a5fa; word-break:break-all;">${responseUrl}</a>`;
        approvalDiv.style.display = 'block';

        btn.textContent = '1. Request Connection';
        btn.disabled = false;
      } catch (e) {
        status.style.display = 'block';
        status.innerHTML = `<span class="fail">Failed to request connection: ${e.message}</span>`;
        btn.textContent = '1. Request Connection';
        btn.disabled = false;
      }
    });

    document.getElementById('btn-wait-approval').addEventListener('click', async () => {
      const status = document.getElementById('reg-status');
      const finalizeDiv = document.getElementById('reg-finalize');
      const btn = document.getElementById('btn-wait-approval');

      if (!regBuilder) {
        status.innerHTML += `\n<span class="fail">Complete step 1 first</span>`;
        return;
      }

      try {
        btn.disabled = true;
        btn.textContent = 'Waiting for approval...';
        status.innerHTML += '\n\nPolling for approval (this may take a while)...';

        await regBuilder.waitForApproval();

        status.innerHTML += `\n<span class="pass">Approved!</span>`;
        btn.textContent = 'Approved!';
        finalizeDiv.style.display = 'block';
      } catch (e) {
        btn.disabled = false;
        btn.textContent = '3. Wait for Approval';
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    document.getElementById('btn-reg-generate').addEventListener('click', () => {
      document.getElementById('reg-mnemonic').value = generateRecoveryPhrase();
    });

    document.getElementById('btn-register').addEventListener('click', async () => {
      const status = document.getElementById('reg-status');
      const resultDiv = document.getElementById('reg-result');
      // use register-specific mnemonic if provided, otherwise fall back to config phrase
      const mnemonic = document.getElementById('reg-mnemonic').value.trim()
        || document.getElementById('phrase').value.trim();

      if (!regBuilder) {
        status.innerHTML += `\n<span class="fail">Complete previous steps first</span>`;
        return;
      }
      if (!mnemonic) {
        status.innerHTML += `\n<span class="fail">Enter a recovery phrase in Configuration or the field above</span>`;
        return;
      }

      try {
        status.innerHTML += '\nRegistering...';
        const sdk = await regBuilder.register(mnemonic);
        const appKey = sdk.appKey();
        const seed = hex(appKey.export());
        const pubkey = appKey.publicKey();

        // auto-fill the config app key field and save to localStorage
        document.getElementById('cfg-key').value = seed;
        localStorage.setItem('app-key', seed);

        status.innerHTML += `\n<span class="pass">Registered successfully!</span>`;
        resultDiv.style.display = 'block';
        resultDiv.innerHTML = `<span class="pass">Registration complete!</span>\n\nApp Key Seed (auto-filled in Configuration above):\n${seed}\n\nPublic Key:\n${pubkey}\n\n<span style="color:#fbbf24;">Save your recovery phrase and app key seed securely!</span>`;
        regBuilder = null;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Account Dashboard --
    async function loadAccountDashboard() {
      const status = document.getElementById('account-status');
      const dashboard = document.getElementById('account-dashboard');

      try {
        status.textContent = 'Loading account data...';

        const sdk = await connectSdk(status);
        if (!sdk) {
          return;
        }

        // Fetch account data
        const accountData = await sdk.account();
        console.log('Account data:', accountData);

        // Fetch object count
        const objectsJson = await sdk.listObjects(null); // Get all objects
        const objects = JSON.parse(objectsJson);
        const objectCount = objects.filter(o => !o.deleted).length;

        // Calculate storage metrics (accountData is a Map)
        const usedBytes = accountData.get('pinnedData');
        const maxBytes = accountData.get('maxPinnedData');
        const freeBytes = maxBytes - usedBytes;
        const usedPercent = maxBytes > 0 ? (usedBytes / maxBytes * 100) : 0;
        const totalStoredBytes = usedBytes * 3; // 3x redundancy

        // Update storage bar
        document.getElementById('account-storage-bar').style.width = `${usedPercent}%`;
        document.getElementById('account-storage-text').textContent =
          `${formatSize(usedBytes)} / ${formatSize(maxBytes)} (${usedPercent.toFixed(1)}%)`;
        document.getElementById('account-used-label').textContent = `Used: ${formatSize(usedBytes)}`;
        document.getElementById('account-free-label').textContent = `Free: ${formatSize(freeBytes)}`;

        // Change bar color based on usage
        const bar = document.getElementById('account-storage-bar');
        if (usedPercent >= 90) {
          bar.style.background = 'linear-gradient(90deg, #ef4444, #dc2626)'; // Red
        } else if (usedPercent >= 75) {
          bar.style.background = 'linear-gradient(90deg, #f59e0b, #d97706)'; // Orange
        } else {
          bar.style.background = 'linear-gradient(90deg, #10b981, #059669)'; // Green
        }

        // Update quick stats
        document.getElementById('account-objects-count').textContent = objectCount.toLocaleString();
        document.getElementById('account-used-storage').textContent = formatSize(usedBytes);
        document.getElementById('account-capacity-percent').textContent = `${usedPercent.toFixed(1)}%`;
        document.getElementById('account-total-stored').textContent = formatSize(totalStoredBytes);

        // Update account details (app is also a Map)
        const app = accountData.get('app');
        document.getElementById('account-app-name').textContent = app.get('description') || 'Unknown';

        const accountKey = accountData.get('accountKey');
        const shortKey = accountKey.substring(0, 24) + '...';
        const keyEl = document.getElementById('account-key');
        keyEl.textContent = shortKey;
        keyEl.title = accountKey; // Full key in tooltip

        // Format last used time
        const lastUsed = new Date(accountData.get('lastUsed'));
        const now = new Date();
        const diffMs = now - lastUsed;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        let lastUsedText;
        if (diffMins < 1) lastUsedText = 'Just now';
        else if (diffMins < 60) lastUsedText = `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
        else if (diffHours < 24) lastUsedText = `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
        else lastUsedText = `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;

        document.getElementById('account-last-used').textContent = lastUsedText;
        document.getElementById('account-max-storage').textContent = formatSize(maxBytes);

        // Clear status
        status.innerHTML = '<span class="pass">‚úì Account data loaded</span>';

        // Show warning if storage is almost full
        if (usedPercent >= 80) {
          status.innerHTML = '<span style="color:#f59e0b;">‚ö†Ô∏è Storage is ' + usedPercent.toFixed(1) + '% full. Consider deleting unused objects or pruning slabs.</span>';
        }
      } catch (e) {
        console.error('Failed to load account:', e);
        status.innerHTML = `<span class="fail">Failed to load account: ${e.message}</span>`;
      }
    }

    document.getElementById('btn-refresh-account').addEventListener('click', loadAccountDashboard);

    // -- Prune Slabs --
    document.getElementById('btn-prune-slabs').addEventListener('click', async () => {
      const button = document.getElementById('btn-prune-slabs');
      const status = document.getElementById('account-status');
      const originalText = button.textContent;

      // Confirmation dialog
      if (!confirm('üßπ Prune Unused Slabs?\n\nThis will remove slabs that are not referenced by any pinned objects.\n\nThis operation cannot be undone. Continue?')) {
        return;
      }

      try {
        // Show loading state
        button.textContent = '‚è≥ Pruning...';
        button.disabled = true;
        status.textContent = 'Pruning unused slabs...';

        const sdk = await connectSdk(status);
        if (!sdk) {
          button.textContent = originalText;
          button.disabled = false;
          return;
        }

        // Call prune slabs
        await sdk.pruneSlabs();

        // Success!
        status.innerHTML = '<span class="pass">‚úì Slabs pruned successfully! Refreshing account data...</span>';

        // Restore button
        button.textContent = originalText;
        button.disabled = false;

        // Refresh account data to show updated storage
        setTimeout(() => {
          loadAccountDashboard();
        }, 1000);
      } catch (e) {
        console.error('Failed to prune slabs:', e);
        status.innerHTML = `<span class="fail">Failed to prune slabs: ${e.message}</span>`;
        button.textContent = originalText;
        button.disabled = false;
      }
    });

    // Auto-load account dashboard when SDK is configured
    window.addEventListener('load', async () => {
      // Wait a bit for user to configure SDK
      setTimeout(async () => {
        const url = getUrl();
        const keyHex = getKeyHex();
        if (url && keyHex) {
          await loadAccountDashboard();
        }
      }, 1000);
    });

    // -- CORS Diagnostics --
    document.getElementById('btn-test-post-slab').addEventListener('click', async () => {
      const status = document.getElementById('test-post-slab-status');
      const summary = document.getElementById('cors-summary');
      const btn = document.getElementById('btn-test-post-slab');

      try {
        btn.disabled = true;
        btn.textContent = 'Testing...';
        status.style.display = 'block';
        status.textContent = 'Sending POST /slabs request with auth headers...';

        const url = getUrl();
        const keyHex = getKeyHex();

        if (!url || !keyHex) {
          status.innerHTML = '<span class="fail">Configure indexer URL and app key first</span>';
          btn.disabled = false;
          btn.textContent = 'Test POST /slabs';
          return;
        }

        // Create minimal test payload
        const testPayload = {
          encryptionKey: randomHex(32),
          minShards: 10,
          sectors: [] // Empty - will fail validation, but CORS happens first
        };

        // Use fetch with signed headers to trigger CORS preflight
        const response = await fetch(`${url}/slabs`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Amz-Date': new Date().toISOString() // Trigger preflight
          },
          body: JSON.stringify(testPayload)
        });

        if (response.ok) {
          status.innerHTML = '<span class="pass">‚úì POST /slabs successful! CORS preflight passed.</span>';
          summary.innerHTML = '<span class="pass">‚úì POST /slabs: CORS preflight passed</span>';
        } else {
          const errorText = await response.text();
          status.innerHTML = `<span class="pass">‚úì CORS preflight passed!\n\nServer returned: ${response.status} ${response.statusText}\n${errorText}</span>`;
          summary.innerHTML = '<span class="pass">‚úì POST /slabs: CORS preflight passed (server validation failed as expected)</span>';
        }

        btn.disabled = false;
        btn.textContent = 'Test POST /slabs';
      } catch (e) {
        console.error('Test failed:', e);
        const errorMsg = e.message || e.toString();
        const isCorsError = errorMsg.includes('CORS') ||
                           errorMsg.includes('preflight') ||
                           errorMsg.includes('Failed to fetch') ||
                           errorMsg.includes('NetworkError');

        if (isCorsError) {
          status.innerHTML = `<span class="fail">‚ùå CORS ERROR!\n\n${errorMsg}\n\nThe endpoint is missing an OPTIONS route for preflight.</span>`;
          summary.innerHTML = '<span class="fail">‚ùå POST /slabs: CORS preflight FAILED - needs OPTIONS route</span>';
        } else {
          status.innerHTML = `<span class="fail">Test error: ${errorMsg}</span>`;
        }

        btn.disabled = false;
        btn.textContent = 'Test POST /slabs';
      }
    });

    document.getElementById('btn-test-delete-slab').addEventListener('click', async () => {
      const status = document.getElementById('test-delete-slab-status');
      const summary = document.getElementById('cors-summary');
      const btn = document.getElementById('btn-test-delete-slab');
      const slabIdInput = document.getElementById('test-slab-id').value.trim();

      try {
        btn.disabled = true;
        btn.textContent = 'Testing...';
        status.style.display = 'block';
        status.textContent = 'Sending DELETE /slabs/:slabid request with auth headers...';

        const url = getUrl();
        const keyHex = getKeyHex();

        if (!url || !keyHex) {
          status.innerHTML = '<span class="fail">Configure indexer URL and app key first</span>';
          btn.disabled = false;
          btn.textContent = 'Test DELETE /slabs/:slabid';
          return;
        }

        // Use provided slab ID or generate a random one
        const testSlabId = slabIdInput || randomHex(32);

        // Use fetch with signed headers to trigger CORS preflight
        const response = await fetch(`${url}/slabs/${testSlabId}`, {
          method: 'DELETE',
          headers: {
            'X-Amz-Date': new Date().toISOString() // Trigger preflight
          }
        });

        if (response.ok) {
          status.innerHTML = '<span class="pass">‚úì DELETE successful! CORS preflight passed.</span>';
          summary.innerHTML = '<span class="pass">‚úì DELETE /slabs/:slabid: CORS preflight passed</span>';
        } else {
          const errorText = await response.text();
          status.innerHTML = `<span class="pass">‚úì CORS preflight passed!\n\nServer returned: ${response.status} ${response.statusText}\n${errorText}</span>`;
          summary.innerHTML = '<span class="pass">‚úì DELETE /slabs/:slabid: CORS preflight passed (404 not found is expected)</span>';
        }

        btn.disabled = false;
        btn.textContent = 'Test DELETE /slabs/:slabid';
      } catch (e) {
        console.error('Test failed:', e);
        const errorMsg = e.message || e.toString();
        const isCorsError = errorMsg.includes('CORS') ||
                           errorMsg.includes('preflight') ||
                           errorMsg.includes('Failed to fetch') ||
                           errorMsg.includes('NetworkError');

        if (isCorsError) {
          status.innerHTML = `<span class="fail">‚ùå CORS ERROR!\n\n${errorMsg}\n\nThe endpoint is missing an OPTIONS route for preflight.</span>`;
          summary.innerHTML = '<span class="fail">‚ùå DELETE /slabs/:slabid: CORS preflight FAILED - needs OPTIONS route</span>';
        } else {
          status.innerHTML = `<span class="fail">Test error: ${errorMsg}</span>`;
        }

        btn.disabled = false;
        btn.textContent = 'Test DELETE /slabs/:slabid';
      }
    });

    // -- Upload Text --
    document.getElementById('btn-upload').addEventListener('click', async () => {
      const status = document.getElementById('ul-status');
      const progress = document.getElementById('ul-progress');
      const text = document.getElementById('ul-text').value;

      if (!text) {
        status.innerHTML = '<span class="fail">Enter some text to upload</span>';
        return;
      }

      progress.style.display = 'none';
      progress.value = 0;

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        const data = new TextEncoder().encode(text);
        progress.style.display = 'block';
        status.textContent = 'Uploading...';

        const uploadStart = performance.now();
        const obj = await sdk.uploadWithProgress(data, (current, total) => {
          progress.max = total;
          progress.value = current;
          status.textContent = `Uploading... ${current}/${total} shards`;
        });
        const elapsed = ((performance.now() - uploadStart) / 1000).toFixed(1);
        const objectId = obj.id();
        const size = obj.size();

        progress.value = progress.max;
        status.innerHTML = `Upload complete (${size} bytes) in ${elapsed}s. Pinning to indexer...`;

        await sdk.pinObject(obj);

        status.innerHTML += `\n<span class="pass">Pinned!</span>\n\nObject ID: ${objectId}`;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Upload File --
    let selectedFile = null;
    const dropzone = document.getElementById('uf-dropzone');
    const fileInput = document.getElementById('uf-file');
    const fileInfo = document.getElementById('uf-file-info');

    function setFile(file) {
      selectedFile = file;
      fileInfo.textContent = `${file.name} (${formatSize(file.size)})`;
    }

    dropzone.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', () => {
      if (fileInput.files.length) setFile(fileInput.files[0]);
    });
    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.classList.add('dragover');
    });
    dropzone.addEventListener('dragleave', () => {
      dropzone.classList.remove('dragover');
    });
    dropzone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropzone.classList.remove('dragover');
      if (e.dataTransfer.files.length) setFile(e.dataTransfer.files[0]);
    });

    document.getElementById('btn-upload-file').addEventListener('click', async () => {
      const status = document.getElementById('uf-status');
      const progress = document.getElementById('uf-progress');

      if (!selectedFile) {
        status.innerHTML = '<span class="fail">Select a file first</span>';
        return;
      }

      progress.style.display = 'none';
      progress.value = 0;

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        const fileSize = selectedFile.size;
        const STREAMING_THRESHOLD = 1.5 * 1024 * 1024 * 1024; // 1.5 GB
        const useStreaming = fileSize > STREAMING_THRESHOLD;

        status.innerHTML = `Uploading ${selectedFile.name} (${formatSize(fileSize)})...\n`;
        if (useStreaming) {
          status.innerHTML += '<span style="color:#60a5fa">Using streaming mode (no memory accumulation)</span>\n';
        }

        const CHUNK_SIZE = 128 * 1024 * 1024; // 128 MB chunks
        const totalChunks = Math.ceil(fileSize / CHUNK_SIZE);
        const uploadStart = performance.now();
        let obj;

        if (useStreaming) {
          // === STREAMING UPLOAD (for files > 1.5GB) ===
          // This mode reads chunks and uploads them concurrently without accumulating in memory

          status.innerHTML += 'Initializing streaming upload...\n';
          progress.style.display = 'block';

          const upload = sdk.streamingUpload(fileSize, (current, total) => {
            progress.max = total;
            progress.value = current;
            status.textContent = `Uploading ${selectedFile.name}... ${current}/${total} shards`;
          });

          // Start reading and pushing chunks asynchronously
          (async () => {
            try {
              for (let i = 0; i < totalChunks; i++) {
                const start = i * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, fileSize);
                const chunk = selectedFile.slice(start, end);
                const buffer = await chunk.arrayBuffer();
                const data = new Uint8Array(buffer);

                await upload.pushChunk(data);  // ‚Üê CRITICAL: await for backpressure!
                console.log(`üì§ Pushed chunk ${i + 1}/${totalChunks} (${formatSize(end)})`);
              }
              await upload.pushChunk(null); // Signal EOF
              console.log('‚úì All chunks pushed, waiting for upload to complete');
            } catch (e) {
              console.error('Error pushing chunks:', e);
              status.innerHTML += `\n<span class="fail">Error reading file: ${e.message}</span>`;
            }
          })();

          // Wait for upload to complete
          obj = await upload.promise;
        } else {
          // === CHUNKED UPLOAD (for files ‚â§ 1.5GB) ===
          // This mode accumulates the file in WASM memory before uploading

          status.innerHTML += `Reading file in ${totalChunks} chunk(s)...\n`;

          const sessionId = sdk.startChunkedUpload(fileSize);

          for (let i = 0; i < totalChunks; i++) {
            const start = i * CHUNK_SIZE;
            const end = Math.min(start + CHUNK_SIZE, fileSize);
            const chunk = selectedFile.slice(start, end);
            const buffer = await chunk.arrayBuffer();
            const data = new Uint8Array(buffer);

            const currentOffset = sdk.uploadChunk(sessionId, data);
            status.textContent = `Reading file... ${i + 1}/${totalChunks} chunks (${formatSize(currentOffset)})`;
          }

          status.innerHTML += '\nUploading to Sia network...\n';
          progress.style.display = 'block';

          obj = await sdk.finalizeChunkedUpload(sessionId, (current, total) => {
            progress.max = total;
            progress.value = current;
            status.textContent = `Uploading ${selectedFile.name}... ${current}/${total} shards`;
          });
        }

        const elapsed = ((performance.now() - uploadStart) / 1000).toFixed(1);
        const objectId = obj.id();
        const size = obj.size();

        progress.value = progress.max;
        status.innerHTML = `Upload complete (${formatSize(size)}) in ${elapsed}s. Pinning to indexer...`;

        await sdk.pinObject(obj);

        status.innerHTML = `File: ${selectedFile.name}\nSize: ${formatSize(size)}\nUpload + pin completed in ${elapsed}s\n<span class="pass">Pinned!</span>\n\nObject ID: ${objectId}`;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Download File --
    document.getElementById('btn-download').addEventListener('click', async () => {
      const status = document.getElementById('dl-status');
      const progress = document.getElementById('dl-progress');
      const input = document.getElementById('dl-url').value.trim();
      const filename = document.getElementById('dl-filename').value.trim() || 'download';

      progress.style.display = 'none';
      progress.value = 0;

      if (!input) {
        status.innerHTML = '<span class="fail">Enter an Object ID or Share URL</span>';
        return;
      }

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.innerHTML += '\nFetching object metadata...';

        // Auto-detect: if starts with sia:// or https://, it's a share URL, otherwise object ID
        const isShareUrl = input.startsWith('sia://') || input.startsWith('https://');
        const obj = isShareUrl
          ? await sdk.sharedObject(input)
          : await sdk.object(input);
        const size = obj.size();
        status.innerHTML = `Object found: ${formatSize(size)}`;

        // Check if File System Access API is available and warn about large files
        const hasFileSystemAPI = !!window.showSaveFilePicker;
        const sizeMB = size / (1024 * 1024);

        if (!hasFileSystemAPI) {
          const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');
          const browserName = isFirefox ? 'Firefox' : 'Your browser';

          status.innerHTML = `<span style="color:#ef4444; font-weight:bold;">‚ùå ${browserName} doesn't support streaming to disk</span>\n\n` +
            `File size: ${formatSize(size)}\n\n` +
            `<strong>This will crash your browser!</strong> Files over ~500MB cannot be downloaded in Firefox because it lacks File System Access API support.\n\n` +
            `<span style="color:#10b981; font-weight:bold;">‚úì Solution: Use Chrome or Edge</span>`;
          return;
        }

        progress.style.display = 'block';
        status.textContent = 'Downloading...';

        const downloadStart = performance.now();
        let bytesDownloaded = 0; // Track actual bytes downloaded
        let currentSlab = 0;
        let totalSlabs = 0;

        // Update progress display
        const updateProgress = () => {
          if (totalSlabs === 0) return; // Wait until we know total

          const now = performance.now();
          progress.max = totalSlabs;
          progress.value = currentSlab;

          // Calculate metrics using actual bytes downloaded
          const percentage = ((currentSlab / totalSlabs) * 100).toFixed(1);
          const elapsed = (now - downloadStart) / 1000; // seconds
          const speed = bytesDownloaded / elapsed; // bytes per second
          const remaining = size - bytesDownloaded;
          const eta = remaining / speed; // seconds

          // Format time helper
          const formatTime = (seconds) => {
            if (seconds < 60) return `${seconds.toFixed(0)}s`;
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
          };

          // Format speed
          const speedMBps = (speed / (1024 * 1024)).toFixed(2);

          // Build status text
          const line1 = `Downloading... ${currentSlab}/${totalSlabs} slabs (${percentage}%) ‚Ä¢ ${formatSize(bytesDownloaded)} / ${formatSize(size)}`;
          const line2 = `${speedMBps} MB/s ‚Ä¢ ${formatTime(elapsed)} elapsed ‚Ä¢ ~${formatTime(eta)} remaining`;
          status.textContent = `${line1}\n${line2}`;
        };

        // Force updates every 100ms for smooth real-time display
        const progressInterval = setInterval(updateProgress, 100);

        // Use the File System Access API to stream directly to disk when
        // available (Chrome/Edge). Chunks are batched per slab (~40 MB) and
        // written as a single Blob so memory stays bounded to ~1-2 slabs.
        if (window.showSaveFilePicker) {
          const handle = await window.showSaveFilePicker({
            suggestedName: filename,
          });
          const writable = await handle.createWritable();
          try {
            // Accumulate chunks for the current slab; flush on progress
            let slabChunks = [];
            let lastWrite = Promise.resolve();

            await sdk.downloadStreaming(obj,
              (chunk) => {
                // chunk is already a JS-owned copy from Rust ‚Äî no extra copy needed
                slabChunks.push(chunk);
                bytesDownloaded += chunk.length; // Track actual bytes
              },
              (current, total) => {
                // Update slab tracking (setInterval will pick this up)
                currentSlab = current;
                totalSlabs = total;
                // Flush accumulated chunks to disk as one Blob per slab
                if (slabChunks.length > 0) {
                  const blob = new Blob(slabChunks);
                  slabChunks = [];
                  // Chain writes so they execute in order; the bounded queue
                  // means at most a few slabs of data are held in memory.
                  lastWrite = lastWrite.then(() => writable.write(blob));
                }
              },
            );
            // Flush any remaining buffered data
            if (slabChunks.length > 0) {
              const blob = new Blob(slabChunks);
              slabChunks = [];
              lastWrite = lastWrite.then(() => writable.write(blob));
            }
            await lastWrite;
            await writable.close();
          } catch (e) {
            await writable.abort();
            throw e;
          }
        } else {
          // Fallback: accumulate in memory (works everywhere, but limited by RAM)
          const blobParts = [];
          await sdk.downloadStreaming(obj,
            (chunk) => {
              blobParts.push(chunk);
              bytesDownloaded += chunk.length; // Track actual bytes
            },
            (current, total) => {
              currentSlab = current;
              totalSlabs = total;
            },
          );
          const blob = new Blob(blobParts);
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = filename;
          a.click();
          URL.revokeObjectURL(a.href);
        }

        clearInterval(progressInterval); // Stop progress updates
        const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
        progress.value = progress.max;
        status.innerHTML = `File: ${filename}\nSize: ${formatSize(size)}\nDownloaded in ${elapsed}s\n<span class="pass">Saved to disk!</span>`;
      } catch (e) {
        clearInterval(progressInterval); // Stop progress updates on error
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- List Objects --
    document.getElementById('btn-list-objects').addEventListener('click', async () => {
      const status = document.getElementById('list-status');
      const objectsList = document.getElementById('objects-list');
      const limit = parseInt(document.getElementById('list-limit').value) || 50;

      status.textContent = 'Loading...';
      objectsList.innerHTML = '';

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.textContent = 'Fetching objects...';
        const objectsJson = await sdk.listObjects(limit);
        const objects = JSON.parse(objectsJson);

        if (objects.length === 0) {
          objectsList.innerHTML = '<div style="padding:1rem; color:#888; text-align:center;">No objects found. Upload something first!</div>';
          status.innerHTML = '<span style="color:#888;">No objects found</span>';
          return;
        }

        // Display objects in a table
        let html = `
          <table style="width:100%; border-collapse:collapse; font-size:0.9rem;">
            <thead>
              <tr style="border-bottom:2px solid #333; text-align:left;">
                <th style="padding:0.5rem;">Object ID</th>
                <th style="padding:0.5rem;">Size</th>
                <th style="padding:0.5rem;">Updated</th>
                <th style="padding:0.5rem;">Status</th>
                <th style="padding:0.5rem;">Actions</th>
              </tr>
            </thead>
            <tbody>
        `;

        for (const obj of objects) {
          const shortId = obj.id.substring(0, 8) + '...' + obj.id.substring(obj.id.length - 8);
          const size = obj.size ? formatSize(obj.size) : 'N/A';
          const date = new Date(obj.updated_at).toLocaleString();
          const status = obj.deleted ? '<span class="fail">Deleted</span>' : '<span class="pass">Active</span>';

          html += `
            <tr style="border-bottom:1px solid #222;">
              <td style="padding:0.5rem; font-family:monospace; font-size:0.85rem;" title="${obj.id}">${shortId}</td>
              <td style="padding:0.5rem;">${size}</td>
              <td style="padding:0.5rem;">${date}</td>
              <td style="padding:0.5rem;">${status}</td>
              <td style="padding:0.5rem;">
                ${!obj.deleted ? `
                  <button onclick="viewObjectById('${obj.id}')" style="padding:0.25rem 0.5rem; font-size:0.85rem; background:#3b82f6; color:white;" title="Open in browser viewer">View</button>
                  <button onclick="shareObjectById('${obj.id}')" style="padding:0.25rem 0.5rem; font-size:0.85rem; background:#10b981; color:white; margin-left:0.25rem;" title="Generate share URL">Share</button>
                  <button onclick="showObjectInfo('${obj.id}')" style="padding:0.25rem 0.5rem; font-size:0.85rem; background:#8b5cf6; color:white; margin-left:0.25rem;" title="Show details">Info</button>
                  <button onclick="downloadObjectById('${obj.id}')" style="padding:0.25rem 0.5rem; font-size:0.85rem; margin-left:0.25rem;">Download</button>
                  <button onclick="copyToClipboard('${obj.id}')" style="padding:0.25rem 0.5rem; font-size:0.85rem; margin-left:0.25rem;">Copy ID</button>
                  <button onclick="deleteObjectById('${obj.id}')" style="padding:0.25rem 0.5rem; font-size:0.85rem; margin-left:0.25rem; background:#dc2626; color:white;">Delete</button>
                ` : ''}
              </td>
            </tr>
          `;
        }

        html += `
            </tbody>
          </table>
        `;

        objectsList.innerHTML = html;
        status.innerHTML = `<span class="pass">‚úì Found ${objects.length} object${objects.length !== 1 ? 's' : ''}</span>`;
      } catch (e) {
        status.innerHTML = `<span class="fail">Error: ${e.message}</span>`;
        objectsList.innerHTML = '';
      }
    });

    // Helper function to download an object by ID
    window.downloadObjectById = async (objectId) => {
      const dlUrl = document.getElementById('dl-url');
      const dlFilename = document.getElementById('dl-filename');

      dlUrl.value = objectId;
      dlFilename.value = 'download_' + objectId.substring(0, 8);

      // Scroll to download section
      document.querySelector('#btn-download').parentElement.parentElement.scrollIntoView({ behavior: 'smooth' });

      // Trigger download after a brief delay to let scroll finish
      setTimeout(() => {
        document.getElementById('btn-download').click();
      }, 500);
    };

    // Helper function to copy to clipboard
    window.copyToClipboard = async (text) => {
      try {
        await navigator.clipboard.writeText(text);
        alert('Object ID copied to clipboard!');
      } catch (e) {
        // Fallback for older browsers
        const textarea = document.createElement('textarea');
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        alert('Object ID copied to clipboard!');
      }
    };

    // Helper function to delete an object
    window.deleteObjectById = async (objectId) => {
      const shortId = objectId.substring(0, 8) + '...' + objectId.substring(objectId.length - 8);

      if (!confirm(`‚ö†Ô∏è Are you sure you want to delete object ${shortId}?\n\nThis action cannot be undone!`)) {
        return;
      }

      const status = document.getElementById('list-status');
      const originalStatus = status.innerHTML;

      try {
        status.innerHTML = '<span style="color:#f59e0b;">‚è≥ Deleting...</span>';

        const sdk = await connectSdk(status);
        if (!sdk) return;

        await sdk.deleteObject(objectId);

        status.innerHTML = '<span class="pass">‚úì Object deleted successfully!</span>';

        // Refresh the list after a short delay
        setTimeout(() => {
          document.getElementById('btn-list-objects').click();
        }, 500);
      } catch (e) {
        status.innerHTML = `<span class="fail">Delete failed: ${e.message}</span>`;

        // Restore original status after showing error for 3 seconds
        setTimeout(() => {
          status.innerHTML = originalStatus;
        }, 3000);
      }
    };

    // Helper function to view an object in the browser
    window.viewObjectById = async (objectId) => {
      const addressBar = document.getElementById('address-bar');
      addressBar.value = objectId;

      // Scroll to browser section
      document.querySelector('#browser-nav').scrollIntoView({ behavior: 'smooth' });

      // Trigger view after a brief delay
      setTimeout(() => {
        loadContentWithAutoDetect();
      }, 500);
    };

    // Helper function to share an object (generate share URL)
    window.shareObjectById = async (objectId) => {
      const shortId = objectId.substring(0, 8) + '...' + objectId.substring(objectId.length - 8);

      // Show configuration modal first
      const configModal = document.createElement('div');
      configModal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.8); display: flex; align-items: center;
        justify-content: center; z-index: 1000;
      `;

      configModal.innerHTML = `
        <div style="background:#1a1a1a; padding:2rem; border-radius:8px; max-width:500px; width:90%; border:1px solid #333;">
          <h3 style="margin:0 0 1rem 0; color:#10b981;">üîó Generate Share URL</h3>
          <p style="color:#888; margin-bottom:1.5rem;">Object: ${shortId}</p>

          <div style="margin-bottom:1.5rem;">
            <div style="color:#e0e0e0; margin-bottom:0.5rem; font-size:0.9rem;">Expires in</div>
            <div style="display:flex; gap:0.5rem; align-items:center;">
              <input id="share-modal-duration" type="number" value="24" min="1" style="width:5rem; padding:0.5rem; background:#0a0a0a; color:#e0e0e0; border:1px solid #333; border-radius:4px; font-size:1rem;" />
              <select id="share-modal-unit" style="flex:1; padding:0.5rem; background:#0a0a0a; color:#e0e0e0; border:1px solid #333; border-radius:4px; font-size:1rem;">
                <option value="3600000">hours</option>
                <option value="86400000" selected>days</option>
                <option value="604800000">weeks</option>
              </select>
            </div>
          </div>

          <div style="display:flex; gap:0.5rem;">
            <button id="btn-generate-share" style="flex:1; padding:0.75rem; background:#10b981; color:white; border:none; border-radius:4px; cursor:pointer; font-size:1rem; font-weight:500;">
              Generate Link
            </button>
            <button id="btn-cancel-share" style="flex:1; padding:0.75rem; background:#333; color:white; border:none; border-radius:4px; cursor:pointer; font-size:1rem;">
              Cancel
            </button>
          </div>
        </div>
      `;

      document.body.appendChild(configModal);

      // Close on background click
      configModal.addEventListener('click', (e) => {
        if (e.target === configModal) configModal.remove();
      });

      // Cancel button
      configModal.querySelector('#btn-cancel-share').addEventListener('click', () => {
        configModal.remove();
      });

      // Generate button
      configModal.querySelector('#btn-generate-share').addEventListener('click', async () => {
        const generateBtn = configModal.querySelector('#btn-generate-share');
        const originalText = generateBtn.textContent;
        generateBtn.textContent = '‚è≥ Generating...';
        generateBtn.disabled = true;

        try {
          const duration = parseFloat(configModal.querySelector('#share-modal-duration').value);
          const unit = parseInt(configModal.querySelector('#share-modal-unit').value);

          const status = document.getElementById('list-status');
          const sdk = await connectSdk(status);
          if (!sdk) {
            configModal.remove();
            return;
          }

          // Fetch the object
          const obj = await sdk.object(objectId);

          // Generate share URL with configured duration
          const validUntilMs = Date.now() + (duration * unit);
          const shareUrl = sdk.shareObject(obj, validUntilMs);

          // Calculate human-readable duration
          let durationText = `${duration} ${configModal.querySelector('#share-modal-unit').selectedOptions[0].text}`;

          // Remove config modal
          configModal.remove();

          // Show result modal
          const resultModal = document.createElement('div');
          resultModal.style.cssText = `
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8); display: flex; align-items: center;
            justify-content: center; z-index: 1000;
          `;

          resultModal.innerHTML = `
            <div style="background:#1a1a1a; padding:2rem; border-radius:8px; max-width:600px; width:90%; border:1px solid #333;">
              <h3 style="margin:0 0 1rem 0; color:#10b981;">üîó Share URL Generated</h3>
              <p style="color:#888; margin-bottom:1rem;">Object: ${shortId}</p>
              <div style="background:#0a0a0a; padding:1rem; border-radius:4px; margin-bottom:1rem; word-break:break-all; font-family:monospace; font-size:0.9rem;">
                ${shareUrl}
              </div>
              <p style="color:#888; font-size:0.9rem; margin-bottom:1rem;">
                ‚è∞ Valid for ${durationText}<br>
                üîí Includes encryption key in URL
              </p>
              <div style="display:flex; gap:0.5rem;">
                <button onclick="navigator.clipboard.writeText('${shareUrl.replace(/'/g, "\\'")}').then(() => alert('Share URL copied!')); this.parentElement.parentElement.parentElement.remove();" style="flex:1; padding:0.75rem; background:#10b981; color:white; border:none; border-radius:4px; cursor:pointer; font-size:1rem;">
                  üìã Copy URL
                </button>
                <button onclick="this.parentElement.parentElement.parentElement.remove();" style="flex:1; padding:0.75rem; background:#333; color:white; border:none; border-radius:4px; cursor:pointer; font-size:1rem;">
                  Close
                </button>
              </div>
            </div>
          `;

          document.body.appendChild(resultModal);

          // Close on background click
          resultModal.addEventListener('click', (e) => {
            if (e.target === resultModal) resultModal.remove();
          });
        } catch (e) {
          configModal.remove();
          alert(`Share failed: ${e.message}`);
        }
      });
    };

    // Helper function to show object info/details
    window.showObjectInfo = async (objectId) => {
      const shortId = objectId.substring(0, 8) + '...' + objectId.substring(objectId.length - 8);

      try {
        // Show loading state
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '‚è≥';
        button.disabled = true;

        const status = document.getElementById('list-status');
        const sdk = await connectSdk(status);
        if (!sdk) {
          button.textContent = originalText;
          button.disabled = false;
          return;
        }

        // Fetch the object
        const obj = await sdk.object(objectId);
        const size = obj.size();

        // Calculate number of slabs (each slab holds 10 shards * 4MB = ~40MB of data)
        const SLAB_DATA_SIZE = 10 * 4 * 1024 * 1024; // 40 MB
        const numSlabs = size === 0 ? 0 : Math.ceil(size / SLAB_DATA_SIZE);

        // Show info in a modal
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed; top: 0; left: 0; right: 0; bottom: 0;
          background: rgba(0,0,0,0.8); display: flex; align-items: center;
          justify-content: center; z-index: 1000;
        `;

        modal.innerHTML = `
          <div style="background:#1a1a1a; padding:2rem; border-radius:8px; max-width:600px; width:90%; border:1px solid #333;">
            <h3 style="margin:0 0 1rem 0; color:#8b5cf6;">‚ÑπÔ∏è Object Details</h3>
            <div style="background:#0a0a0a; padding:1rem; border-radius:4px; margin-bottom:1rem;">
              <div style="margin-bottom:0.75rem;">
                <div style="color:#888; font-size:0.85rem; margin-bottom:0.25rem;">Object ID:</div>
                <div style="font-family:monospace; font-size:0.9rem; word-break:break-all;">${objectId}</div>
              </div>
              <div style="margin-bottom:0.75rem;">
                <div style="color:#888; font-size:0.85rem; margin-bottom:0.25rem;">Size:</div>
                <div>${formatSize(size)} (${size.toLocaleString()} bytes)</div>
              </div>
              <div style="margin-bottom:0.75rem;">
                <div style="color:#888; font-size:0.85rem; margin-bottom:0.25rem;">Slabs:</div>
                <div>${numSlabs} slab${numSlabs !== 1 ? 's' : ''} (~${(numSlabs * 40).toFixed(0)} MB encoded)</div>
              </div>
              <div style="margin-bottom:0.75rem;">
                <div style="color:#888; font-size:0.85rem; margin-bottom:0.25rem;">Redundancy:</div>
                <div>10 data shards + 20 parity shards (need any 10 of 30)</div>
              </div>
              <div>
                <div style="color:#888; font-size:0.85rem; margin-bottom:0.25rem;">Storage Efficiency:</div>
                <div>3x redundancy (${formatSize(size * 3)} total stored)</div>
              </div>
            </div>
            <button onclick="this.parentElement.parentElement.remove();" style="width:100%; padding:0.75rem; background:#333; color:white; border:none; border-radius:4px; cursor:pointer; font-size:1rem;">
              Close
            </button>
          </div>
        `;

        document.body.appendChild(modal);

        // Close on background click
        modal.addEventListener('click', (e) => {
          if (e.target === modal) modal.remove();
        });

        // Restore button
        button.textContent = originalText;
        button.disabled = false;
      } catch (e) {
        alert(`Failed to load info: ${e.message}`);
        event.target.textContent = 'Info';
        event.target.disabled = false;
      }
    };

    // -- Share Object --
    document.getElementById('btn-share').addEventListener('click', async () => {
      const status = document.getElementById('share-status');
      const objectId = document.getElementById('share-object-id').value.trim();
      const duration = parseFloat(document.getElementById('share-duration').value);
      const unit = parseInt(document.getElementById('share-unit').value);

      if (!objectId) {
        status.innerHTML = '<span class="fail">Enter an Object ID</span>';
        return;
      }

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.textContent = 'Fetching object...';
        const obj = await sdk.object(objectId);

        const validUntilMs = Date.now() + (duration * unit);
        const shareUrl = sdk.shareObject(obj, validUntilMs);

        const expiresAt = new Date(validUntilMs).toLocaleString();
        status.innerHTML = `<span class="pass">Share link created!</span>\nExpires: ${expiresAt}\n\n<a href="${shareUrl}" target="_blank" rel="noopener" style="color:#60a5fa; word-break:break-all;">${shareUrl}</a>`;

        document.getElementById('share-url').value = shareUrl;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Decentralized Browser (HTML Viewer with Navigation) --
    const HISTORY_STORAGE_KEY = 'sia-browser-history';
    const browserHistory = [];
    let currentHistoryIndex = -1;

    // Load history from localStorage on page load
    function loadHistoryFromStorage() {
      try {
        const saved = localStorage.getItem(HISTORY_STORAGE_KEY);
        if (saved) {
          const parsed = JSON.parse(saved);
          // Restore history items (blob URLs will be null after refresh)
          browserHistory.push(...parsed);
          console.log(`üìö Restored ${browserHistory.length} history items from localStorage`);
          updateBrowserUI();
        }
      } catch (e) {
        console.error('Failed to load history from storage:', e);
      }
    }

    // Save history to localStorage
    function saveHistoryToStorage() {
      try {
        // Save history without blob URLs (they're temporary)
        const toSave = browserHistory.map(item => ({
          displayUrl: item.displayUrl,
          title: item.title,
          external: item.external,
          originalUrl: item.originalUrl,
          fileType: item.fileType,
          blobUrl: null  // Don't save blob URLs - they won't work after refresh
        }));
        localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(toSave));
      } catch (e) {
        console.error('Failed to save history to storage:', e);
      }
    }

    // Load history when page loads
    loadHistoryFromStorage();

    // If history is empty, add the welcome page to history
    if (browserHistory.length === 0) {
      const welcomeUrl = 'sia://app.sia.storage/objects/20a4f56e14c0cf3a3e010370bceb5e665cf997ca8acbd1c7c2e5543bfe0da499/shared?sv=1785641173&sc=nmS95u9mPXfFkjj8fkVfCw28mgyVgq9IQOUQYBykQNs%3D&ss=NrjLZkHG8kCKBUdIOcqhlRriIOED_gCjIi_cn9HSwGCPwbCKDJAXZow7f8FYf4govWHC2M25n9EgPQZlz9eKDA%3D%3D#encryption_key=zdDhoRMpzziTJ7xPD1_Cy3QN0pZtuyg_1ElWPopvIRM=';

      // Add welcome page to history (without blob URL - user will click to load)
      browserHistory.push({
        displayUrl: welcomeUrl,
        blobUrl: null,
        title: 'Welcome to Sia Browser',
        external: false,
        originalUrl: welcomeUrl,
        fileType: 'html'
      });

      currentHistoryIndex = 0;
      updateBrowserUI();
      saveHistoryToStorage();

      console.log('üìÑ Welcome page added to history');
    }

    function updateBrowserUI() {
      const addressBar = document.getElementById('address-bar');
      const historyList = document.getElementById('history-list');

      // Update address bar with raw URL (so user can click Go or External Tab)
      if (currentHistoryIndex >= 0 && browserHistory[currentHistoryIndex]) {
        const current = browserHistory[currentHistoryIndex];
        addressBar.value = current.originalUrl || current.displayUrl;
        addressBar.title = current.displayUrl; // Tooltip shows formatted version
      } else {
        addressBar.value = '';
        addressBar.placeholder = 'Paste Sia share URL or object ID...';
      }

      // Update history list
      historyList.innerHTML = '';
      browserHistory.forEach((item, index) => {
        const historyItem = document.createElement('div');
        let classes = 'history-item';
        if (index === currentHistoryIndex) classes += ' active';
        if (item.blobUrl) classes += ' downloaded';
        historyItem.className = classes;

        // Only show warning for external HTML tabs, not for PDFs (which are safe)
        const isPdf = item.displayUrl && item.displayUrl.startsWith('PDF:');
        const showWarning = item.external && !isPdf;

        const itemText = (showWarning ? '‚ö†Ô∏è ' : '') + (item.title || item.displayUrl);
        historyItem.innerHTML = `
          <span class="history-title">${itemText}</span>
          ${item.blobUrl ? '<button class="history-download" style="opacity: 0; transition: opacity 0.2s; background: none; border: none; color: #10b981; cursor: pointer; padding: 0 0.5rem; font-size: 1rem; line-height: 1;" title="Download">‚¨á</button>' : ''}
          <button class="history-delete" style="opacity: 0; transition: opacity 0.2s; background: none; border: none; color: #ef4444; cursor: pointer; padding: 0 0.5rem; font-size: 1.2rem; line-height: 1;" title="Delete">√ó</button>
        `;
        historyItem.title = (showWarning ? '[External Tab] ' : '') + item.displayUrl;

        // Show buttons on hover
        historyItem.addEventListener('mouseenter', () => {
          const deleteBtn = historyItem.querySelector('.history-delete');
          const downloadBtn = historyItem.querySelector('.history-download');
          if (deleteBtn) deleteBtn.style.opacity = '1';
          if (downloadBtn) downloadBtn.style.opacity = '1';
        });
        historyItem.addEventListener('mouseleave', () => {
          const deleteBtn = historyItem.querySelector('.history-delete');
          const downloadBtn = historyItem.querySelector('.history-download');
          if (deleteBtn) deleteBtn.style.opacity = '0';
          if (downloadBtn) downloadBtn.style.opacity = '0';
        });

        // Navigate on title click
        historyItem.querySelector('.history-title').addEventListener('click', () => navigateToHistory(index));

        // Download on ‚¨á click
        const downloadBtn = historyItem.querySelector('.history-download');
        if (downloadBtn) {
          downloadBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            downloadHistoryItem(index);
          });
        }

        // Delete on X click
        historyItem.querySelector('.history-delete').addEventListener('click', (e) => {
          e.stopPropagation();
          deleteHistoryItem(index);
        });

        historyList.appendChild(historyItem);
      });
    }

    function deleteHistoryItem(index) {
      if (index < 0 || index >= browserHistory.length) return;

      // Revoke the blob URL to free memory
      const item = browserHistory[index];
      if (item.blobUrl && item.blobUrl.startsWith('blob:')) {
        URL.revokeObjectURL(item.blobUrl);
      }

      // Remove the item
      browserHistory.splice(index, 1);

      // Update current index
      if (currentHistoryIndex === index) {
        // Deleted the current item - move to previous or clear
        currentHistoryIndex = Math.max(0, index - 1);
        if (browserHistory.length === 0) {
          currentHistoryIndex = -1;
          // Clear the iframe
          const iframe = document.getElementById('html-iframe');
          const videoContainer = document.getElementById('video-container');
          const video = document.getElementById('mse-video');
          iframe.src = '';
          iframe.style.display = 'block';
          videoContainer.style.display = 'none';
          video.src = '';
        }
      } else if (currentHistoryIndex > index) {
        // Deleted an item before the current - adjust index
        currentHistoryIndex--;
      }

      updateBrowserUI();
      saveHistoryToStorage();
    }

    function downloadHistoryItem(index) {
      if (index < 0 || index >= browserHistory.length) return;

      const item = browserHistory[index];
      if (!item.blobUrl) {
        alert('This item has not been downloaded yet. Click on it to load it first.');
        return;
      }

      // Generate a filename from the display URL or object ID
      let filename = 'download';
      try {
        // Try to extract a meaningful filename
        const url = item.originalUrl || item.displayUrl;
        if (url.includes('/')) {
          // Get the last part of the URL
          const parts = url.split('/');
          filename = parts[parts.length - 1];
        } else if (url.length === 64) {
          // Looks like an object ID - use shortened version
          filename = `object_${url.substring(0, 8)}`;
        } else {
          filename = 'download';
        }

        // Add extension based on file type if we can guess it
        if (item.fileType && !filename.includes('.')) {
          const extensions = {
            'image': '.jpg',
            'video': '.mp4',
            'audio': '.mp3',
            'pdf': '.pdf',
            'html': '.html',
            'text': '.txt'
          };
          if (extensions[item.fileType]) {
            filename += extensions[item.fileType];
          }
        }
      } catch (e) {
        console.error('Error generating filename:', e);
      }

      // Trigger download
      const a = document.createElement('a');
      a.href = item.blobUrl;
      a.download = filename;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);

      console.log(`üì• Downloaded history item: ${filename}`);
    }

    async function navigateToHistory(index) {
      if (index < 0 || index >= browserHistory.length) return;
      currentHistoryIndex = index;
      const item = browserHistory[index];

      // If blob URL is null (e.g., after page refresh), re-download the file
      if (!item.blobUrl) {
        console.log('üîÑ Blob URL missing, re-downloading:', item.originalUrl);
        await redownloadHistoryItem(item, index);
        return;
      }

      // If this is an external tab item, reopen it in external tab
      if (item.external) {
        window.open(item.blobUrl, '_blank');
      } else {
        // Show iframe, hide video
        const iframe = document.getElementById('html-iframe');
        const videoContainer = document.getElementById('video-container');
        const video = document.getElementById('mse-video');

        iframe.style.display = 'block';
        videoContainer.style.display = 'none';
        video.src = ''; // Clear video source

        // Load in iframe
        iframe.src = item.blobUrl;
      }
      updateBrowserUI();
    }

    // Re-download a history item (when blob URL is missing after refresh)
    async function redownloadHistoryItem(item, index) {
      const status = document.getElementById('iframe-status');
      const progress = document.getElementById('iframe-progress');
      const iframe = document.getElementById('html-iframe');

      progress.style.display = 'none';
      progress.value = 0;

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.textContent = `Re-downloading ${item.fileType}...`;

        const obj = item.originalUrl.startsWith('sia://')
          ? await sdk.sharedObject(item.originalUrl)
          : await sdk.object(item.originalUrl);

        const { blob: downloadedBlob } = await streamingDownload(sdk, obj, status, progress, 'Downloading');
        const data = new Uint8Array(await downloadedBlob.arrayBuffer());

        // Create blob with appropriate MIME type and wrapper
        let mimeType = 'text/html';
        if (item.fileType === 'pdf') mimeType = 'application/pdf';
        else if (item.fileType === 'image') mimeType = 'image/jpeg';
        else if (item.fileType === 'video') mimeType = 'video/mp4';
        else if (item.fileType === 'audio') mimeType = 'audio/mpeg';
        else if (item.fileType === 'text') mimeType = 'text/plain';

        // Create blob with appropriate wrapper for better display
        let blobUrl;
        if (item.fileType === 'text') {
          // Wrap text in styled HTML for better readability
          const text = new TextDecoder().decode(data);
          const escapedText = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
          const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{font-family:'Courier New',monospace;padding:1.5rem;background:#0a0a0a;color:#e0e0e0;margin:0;}pre{white-space:pre-wrap;word-wrap:break-word;margin:0;line-height:1.5;}</style></head><body><pre>${escapedText}</pre></body></html>`;
          const blob = new Blob([html], { type: 'text/html' });
          blobUrl = URL.createObjectURL(blob);
        } else if (item.fileType === 'audio') {
          // Wrap audio in HTML with styled player
          const audioBlob = new Blob([data], { type: mimeType });
          const audioUrl = URL.createObjectURL(audioBlob);
          const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;margin:0;background:#0a0a0a;color:#e0e0e0;font-family:system-ui,sans-serif;}audio{width:90%;max-width:600px;}</style></head><body><h2 style="margin-bottom:2rem;">üéµ Audio Player</h2><audio controls autoplay><source src="${audioUrl}" type="${mimeType}">Your browser does not support the audio element.</audio></body></html>`;
          const blob = new Blob([html], { type: 'text/html' });
          blobUrl = URL.createObjectURL(blob);
        } else {
          // For other types, load directly
          const blob = new Blob([data], { type: mimeType });
          blobUrl = URL.createObjectURL(blob);
        }

        // Update history item with new blob URL
        browserHistory[index].blobUrl = blobUrl;

        // Load the file
        if (item.external || item.fileType === 'pdf') {
          window.open(blobUrl, '_blank');
          status.innerHTML = '<span class="pass">‚úì Reopened in new tab!</span>';
        } else {
          iframe.src = blobUrl;
          status.innerHTML = '<span class="pass">‚úì Loaded!</span>';
        }

        updateBrowserUI();
      } catch (e) {
        status.innerHTML = `<span class="fail">Error re-downloading: ${e.message}</span>`;
      }
    }

    function addToHistory(displayUrl, blobUrl, title = null, external = false, originalUrl = '', fileType = 'html') {
      console.log('üîç addToHistory called:', {
        displayUrl,
        external,
        originalUrl,
        fileType,
        currentHistoryIndex,
        historyLength: browserHistory.length
      });

      // Check if this URL already exists in history (by original URL, not blob URL)
      const existingIndex = browserHistory.findIndex(item =>
        item.originalUrl === originalUrl && item.fileType === fileType
      );

      if (existingIndex !== -1) {
        // URL already exists - update it with the new blob URL
        console.log(`üìç URL already exists at index ${existingIndex}, updating blob URL`);
        browserHistory[existingIndex].blobUrl = blobUrl;
        browserHistory[existingIndex].title = title || displayUrl;
        currentHistoryIndex = existingIndex;
        updateBrowserUI();
        saveHistoryToStorage();
        return;
      }

      // New URL - always append to the end (tab bar behavior)
      browserHistory.push({
        displayUrl,
        blobUrl,
        title: title || displayUrl,
        external,
        originalUrl,
        fileType
      });
      currentHistoryIndex = browserHistory.length - 1;

      console.log('‚úÖ History updated:', {
        newHistoryLength: browserHistory.length,
        newCurrentIndex: currentHistoryIndex,
        allTitles: browserHistory.map(h => h.title || h.displayUrl)
      });

      updateBrowserUI();
      saveHistoryToStorage();
    }

    // Address bar navigation (Enter key) - uses auto-detection
    document.getElementById('address-bar').addEventListener('keypress', async (e) => {
      if (e.key === 'Enter') {
        loadContentWithAutoDetect();
      }
    });

    // Generic function to load content with specified MIME type
    async function loadContentAs(mimeType, typeLabel) {
      const addressBar = document.getElementById('address-bar');
      const url = addressBar.value.trim();

      if (!url) {
        const status = document.getElementById('iframe-status');
        status.innerHTML = '<span style="color:#f59e0b">‚ö†Ô∏è Enter a URL in the address bar first.</span>';
        return;
      }

      const status = document.getElementById('iframe-status');
      const progress = document.getElementById('iframe-progress');
      const iframe = document.getElementById('html-iframe');

      progress.style.display = 'none';
      progress.value = 0;

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.textContent = `Fetching ${typeLabel}...`;
        const obj = url.startsWith('sia://')
          ? await sdk.sharedObject(url)
          : await sdk.object(url);
        const size = obj.size();

        const { blob: downloadedBlob, elapsed } = await streamingDownload(sdk, obj, status, progress, 'Downloading');

        // Create blob with appropriate wrapper for better display
        let blobUrl;
        if (mimeType === 'text/plain') {
          // Wrap text in styled HTML for better readability
          const text = new TextDecoder().decode(new Uint8Array(await downloadedBlob.arrayBuffer()));
          const escapedText = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
          const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{font-family:'Courier New',monospace;padding:1.5rem;background:#0a0a0a;color:#e0e0e0;margin:0;}pre{white-space:pre-wrap;word-wrap:break-word;margin:0;line-height:1.5;}</style></head><body><pre>${escapedText}</pre></body></html>`;
          const blob = new Blob([html], { type: 'text/html' });
          blobUrl = URL.createObjectURL(blob);
        } else if (mimeType === 'audio/mpeg') {
          // Wrap audio in HTML with styled player
          const audioBlob = new Blob([downloadedBlob], { type: mimeType });
          const audioUrl = URL.createObjectURL(audioBlob);
          const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;margin:0;background:#0a0a0a;color:#e0e0e0;font-family:system-ui,sans-serif;}audio{width:90%;max-width:600px;}</style></head><body><h2 style="margin-bottom:2rem;">üéµ Audio Player</h2><audio controls autoplay><source src="${audioUrl}" type="${mimeType}">Your browser does not support the audio element.</audio></body></html>`;
          const blob = new Blob([html], { type: 'text/html' });
          blobUrl = URL.createObjectURL(blob);
        } else {
          // For other types (image, video, html), load directly
          blobUrl = URL.createObjectURL(new Blob([downloadedBlob], { type: mimeType }));
        }

        iframe.src = blobUrl;

        // Add to history
        const displayUrl = `${typeLabel}: ${url}`;
        const fileType = typeLabel.toLowerCase();
        addToHistory(displayUrl, blobUrl, displayUrl, false, url, fileType);

        status.innerHTML = `Size: ${formatSize(size)}\nLoaded in ${elapsed}s\n<span class="pass">${typeLabel} loaded!</span>`;
      } catch (e) {
        status.innerHTML = `<span class="fail">Error: ${e.message}</span>`;
      }
    }

    // PDF loader - opens in new tab (Chrome blocks PDFs in sandboxed iframes)
    async function loadPdfInNewTab() {
      const addressBar = document.getElementById('address-bar');
      const url = addressBar.value.trim();

      if (!url) {
        const status = document.getElementById('iframe-status');
        status.innerHTML = '<span style="color:#f59e0b">‚ö†Ô∏è Enter a URL in the address bar first.</span>';
        return;
      }

      const status = document.getElementById('iframe-status');
      const progress = document.getElementById('iframe-progress');

      progress.style.display = 'none';
      progress.value = 0;

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.textContent = 'Fetching PDF...';
        const obj = url.startsWith('sia://')
          ? await sdk.sharedObject(url)
          : await sdk.object(url);
        const size = obj.size();

        const { blob: downloadedBlob, elapsed } = await streamingDownload(sdk, obj, status, progress, 'Downloading PDF');

        // Open PDF in new tab
        const blob = new Blob([downloadedBlob], { type: 'application/pdf' });
        const blobUrl = URL.createObjectURL(blob);
        window.open(blobUrl, '_blank');

        // Add to history with external flag (PDFs open in new tabs)
        const displayUrl = `PDF: ${url}`;
        addToHistory(displayUrl, blobUrl, displayUrl, true, url, 'pdf');

        status.innerHTML = `Size: ${formatSize(size)}\nLoaded in ${elapsed}s\n<span class="pass">PDF opened in new tab!</span>`;
      } catch (e) {
        status.innerHTML = `<span class="fail">Error: ${e.message}</span>`;
      }
    }

    // Progressive video streaming using Media Source Extensions
    async function streamVideo(sdk, obj, mimeType, status, progress) {
      // TODO: MSE requires proper MP4 initialization segments (moov/ftyp boxes)
      // The raw slab data doesn't have the correct MP4 structure for MSE
      // For now, disable MSE - full download works reliably
      console.log('‚ö†Ô∏è  MSE disabled (needs MP4 fragmentation) - using full download');
      return null;

      /* Disabled until we can generate proper fragmented MP4
      if (!window.MediaSource) {
        console.log('MSE not available - falling back to full download');
        return null;
      }

      // Test codec support BEFORE creating MediaSource
      const codecStrings = [
        'video/mp4; codecs="avc1.42E01E, mp4a.40.2"', // H.264 Baseline + AAC-LC
        'video/mp4; codecs="avc1.640028, mp4a.40.2"', // H.264 High + AAC-LC
        'video/mp4; codecs="avc1.64001F, mp4a.40.2"', // H.264 High 3.1
        'video/mp4; codecs="hvc1.1.6.L153.B0, mp4a.40.2"', // HEVC Main + AAC
        'video/mp4; codecs="hev1.1.6.L153.B0, mp4a.40.2"', // HEVC alternative
      ];

      console.log('üîç Testing codec support...');
      let selectedCodec = null;
      for (const codec of codecStrings) {
        const isSupported = MediaSource.isTypeSupported(codec);
        console.log(`  ${isSupported ? '‚úÖ' : '‚ùå'} ${codec}`);
        if (isSupported && !selectedCodec) {
          selectedCodec = codec;
        }
      }

      if (!selectedCodec) {
        console.log('‚ùå No supported codec - falling back');
        return null;
      }

      console.log('‚ú® Will use codec:', selectedCodec);

      // Now create MediaSource
      return new Promise((resolve, reject) => {
        const mediaSource = new MediaSource();
        const videoUrl = URL.createObjectURL(mediaSource);

        // CRITICAL: Attach to video element BEFORE waiting for sourceopen
        // The sourceopen event won't fire until the video starts loading the MediaSource
        const video = document.getElementById('mse-video');
        const videoContainer = document.getElementById('video-container');
        const iframe = document.getElementById('html-iframe');

        // Show video, hide iframe
        iframe.style.display = 'none';
        videoContainer.style.display = 'block';
        video.src = videoUrl; // This triggers sourceopen!
        console.log('üì∫ Video element attached, waiting for sourceopen...');

        let sourceBuffer = null;
        let downloadComplete = false;
        let appendQueue = [];
        let isAppending = false;

        mediaSource.addEventListener('sourceopen', async () => {
          console.log('‚úÖ MediaSource opened!');
          try {
            sourceBuffer = mediaSource.addSourceBuffer(selectedCodec);
            console.log('üé¨ SourceBuffer created, starting download...')

            // Process append queue when buffer is ready
            sourceBuffer.addEventListener('updateend', () => {
              isAppending = false;
              processQueue();
            });

            sourceBuffer.addEventListener('error', (e) => {
              console.error('SourceBuffer error:', e);
              reject(new Error('SourceBuffer error'));
            });

            // Start downloading
            const chunks = [];
            await sdk.downloadStreaming(obj,
              (chunk) => {
                // Accumulate chunks for current slab
                chunks.push(chunk);
              },
              (current, total) => {
                // On slab completion, queue the slab data for append
                if (chunks.length > 0) {
                  const slabData = new Uint8Array(
                    chunks.reduce((acc, c) => acc + c.length, 0)
                  );
                  let offset = 0;
                  for (const chunk of chunks) {
                    slabData.set(chunk, offset);
                    offset += chunk.length;
                  }
                  appendQueue.push(slabData);
                  chunks.length = 0;
                  processQueue();
                }

                // Update progress
                progress.max = total;
                progress.value = current;
                status.textContent = `Streaming video... ${current}/${total} slabs`;
              }
            );

            // Append any remaining chunks
            if (chunks.length > 0) {
              const slabData = new Uint8Array(
                chunks.reduce((acc, c) => acc + c.length, 0)
              );
              let offset = 0;
              for (const chunk of chunks) {
                slabData.set(chunk, offset);
                offset += chunk.length;
              }
              appendQueue.push(slabData);
              chunks.length = 0;
            }

            downloadComplete = true;
            processQueue();

            resolve({ videoUrl, mediaSource });

          } catch (error) {
            console.error('MSE setup error:', error);
            reject(error);
          }
        });

        function processQueue() {
          if (isAppending || !sourceBuffer || appendQueue.length === 0) {
            // Check if we're done
            if (downloadComplete && appendQueue.length === 0 && !isAppending) {
              if (mediaSource.readyState === 'open') {
                mediaSource.endOfStream();
                console.log('Video streaming complete');
              }
            }
            return;
          }

          const data = appendQueue.shift();
          isAppending = true;

          try {
            sourceBuffer.appendBuffer(data);
          } catch (e) {
            console.error('appendBuffer error:', e);
            isAppending = false;
            // Try again after a delay
            setTimeout(() => processQueue(), 100);
          }
        }

        mediaSource.addEventListener('error', (e) => {
          console.error('MediaSource error:', e);
          reject(new Error('MediaSource error'));
        });
      });
      */
    }

    // Auto-detect file type using MIME sniffing
    async function loadContentWithAutoDetect() {
      const addressBar = document.getElementById('address-bar');
      const url = addressBar.value.trim();

      if (!url) {
        const status = document.getElementById('iframe-status');
        status.innerHTML = '<span style="color:#f59e0b">‚ö†Ô∏è Enter a URL in the address bar first.</span>';
        return;
      }

      const status = document.getElementById('iframe-status');
      const progress = document.getElementById('iframe-progress');
      const iframe = document.getElementById('html-iframe');
      const videoContainer = document.getElementById('video-container');
      const video = document.getElementById('mse-video');

      // Reset display: show iframe, hide video
      iframe.style.display = 'block';
      videoContainer.style.display = 'none';
      video.src = '';

      progress.style.display = 'none';
      progress.value = 0;

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.textContent = 'Fetching object...';
        const obj = url.startsWith('sia://')
          ? await sdk.sharedObject(url)
          : await sdk.object(url);
        const size = obj.size();

        // Since we're not doing progressive streaming (MSE disabled),
        // just download the entire file first, then detect type
        status.textContent = 'Downloading...';
        const result = await streamingDownload(sdk, obj, status, progress, 'Downloading');
        const downloadedBlob = result.blob;

        // Detect type from the full file
        status.textContent = 'Detecting file type...';
        const detectedType = await fileTypeFromBlob(downloadedBlob);

        let mimeType = 'application/octet-stream';
        let typeLabel = 'Unknown';
        let fileType = 'unknown';

        if (detectedType) {
          mimeType = detectedType.mime;
          typeLabel = detectedType.ext.toUpperCase();

          // Categorize for history tracking
          if (mimeType.startsWith('image/')) {
            fileType = 'image';
            typeLabel = 'Image';
          } else if (mimeType.startsWith('video/')) {
            fileType = 'video';
            typeLabel = 'Video';
          } else if (mimeType.startsWith('audio/')) {
            fileType = 'audio';
            typeLabel = 'Audio';
          } else if (mimeType === 'application/pdf') {
            fileType = 'pdf';
            typeLabel = 'PDF';
          } else if (mimeType === 'text/html') {
            fileType = 'html';
            typeLabel = 'HTML';
          } else if (mimeType.startsWith('text/')) {
            fileType = 'text';
            typeLabel = 'Text';
          }

          status.textContent = `Detected: ${mimeType} (${detectedType.ext})`;
          console.log('üîç Type detected:', { mimeType, typeLabel, fileType, ext: detectedType.ext });
        } else {
          // Fallback: try to detect text by checking if it's valid UTF-8
          try {
            const sample = await downloadedBlob.slice(0, 1024).arrayBuffer();
            const text = new TextDecoder('utf-8', { fatal: true }).decode(sample);
            // If we got here, it's valid UTF-8 text
            if (text.includes('<html') || text.includes('<!DOCTYPE')) {
              mimeType = 'text/html';
              typeLabel = 'HTML';
              fileType = 'html';
            } else {
              mimeType = 'text/plain';
              typeLabel = 'Text';
              fileType = 'text';
            }
            status.textContent = `Detected: ${typeLabel} (fallback UTF-8 detection)`;
          } catch {
            // Not text, treat as binary
            status.textContent = 'Could not detect file type, treating as binary';
          }
        }

        // Create blob with appropriate wrapper for better display
        let blobUrl;
        const downloadStart = performance.now();

        if (fileType === 'video') {
          // Create video player HTML with the already-downloaded blob
          const videoBlob = new Blob([downloadedBlob], { type: mimeType });
          const videoUrl = URL.createObjectURL(videoBlob);
          const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;margin:0;background:#0a0a0a;color:#e0e0e0;font-family:system-ui,sans-serif;padding:2rem;}video{width:100%;max-width:1200px;background:#000;}</style></head><body><h2 style="margin-bottom:1rem;">üé¨ Video Player</h2><video controls autoplay><source src="${videoUrl}" type="${mimeType}">Your browser does not support the video element.</video><p style="margin-top:1rem;color:#888;">File size: ${formatSize(size)} | Type: ${mimeType}</p></body></html>`;
          const blob = new Blob([html], { type: 'text/html' });
          blobUrl = URL.createObjectURL(blob);

        } else if (fileType === 'text') {
          // Decode text from the already-downloaded blob
          const text = new TextDecoder().decode(new Uint8Array(await downloadedBlob.arrayBuffer()));
          const escapedText = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
          const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{font-family:'Courier New',monospace;padding:1.5rem;background:#0a0a0a;color:#e0e0e0;margin:0;}pre{white-space:pre-wrap;word-wrap:break-word;margin:0;line-height:1.5;}</style></head><body><pre>${escapedText}</pre></body></html>`;
          const blob = new Blob([html], { type: 'text/html' });
          blobUrl = URL.createObjectURL(blob);

        } else if (fileType === 'audio') {
          const audioBlob = new Blob([downloadedBlob], { type: mimeType });
          const audioUrl = URL.createObjectURL(audioBlob);
          const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;margin:0;background:#0a0a0a;color:#e0e0e0;font-family:system-ui,sans-serif;}audio{width:90%;max-width:600px;}</style></head><body><h2 style="margin-bottom:2rem;">üéµ Audio Player</h2><audio controls autoplay><source src="${audioUrl}" type="${mimeType}">Your browser does not support the audio element.</audio></body></html>`;
          const blob = new Blob([html], { type: 'text/html' });
          blobUrl = URL.createObjectURL(blob);

        } else if (fileType === 'pdf') {
          const pdfBlob = new Blob([downloadedBlob], { type: 'application/pdf' });
          blobUrl = URL.createObjectURL(pdfBlob);
          window.open(blobUrl, '_blank');

          const displayUrl = `PDF: ${url}`;
          addToHistory(displayUrl, blobUrl, displayUrl, true, url, 'pdf');

          const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
          status.innerHTML = `Size: ${formatSize(size)}\nDetected: ${mimeType}\nLoaded in ${elapsed}s\n<span class="pass">PDF opened in new tab!</span>`;
          return;

        } else {
          // For other types (image, html, unknown), load directly
          blobUrl = URL.createObjectURL(new Blob([downloadedBlob], { type: mimeType }));
        }

        console.log(`üé¨ LINE 1712 - Setting iframe.src for ${fileType} (non-MSE path)`);
        iframe.src = blobUrl;

        const displayUrl = `${typeLabel}: ${url}`;
        addToHistory(displayUrl, blobUrl, displayUrl, false, url, fileType);

        const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
        status.innerHTML = `Size: ${formatSize(size)}\nDetected: ${mimeType}\nLoaded in ${elapsed}s\n<span class="pass">${typeLabel} loaded!</span>`;
      } catch (e) {
        status.innerHTML = `<span class="fail">Error: ${e.message}</span>`;
      }
    }

    // Go button - auto-detects file type
    document.getElementById('btn-go').addEventListener('click', loadContentWithAutoDetect);

    // Open in external tab (with warning)
    document.getElementById('btn-external-tab').addEventListener('click', async () => {
      // Show warning first
      const confirmed = confirm('‚ö†Ô∏è WARNING: This will allow the downloaded page to execute JavaScript!\n\nOpening content in an external tab removes all sandbox protections. Only proceed if you trust the content.\n\nUse the Go button (sandboxed iframe) for untrusted content.');

      if (!confirmed) return;

      const status = document.getElementById('iframe-status');

      // Check if we have a current history item with blob URL - reuse it!
      if (currentHistoryIndex >= 0 && browserHistory[currentHistoryIndex]) {
        const currentItem = browserHistory[currentHistoryIndex];
        if (currentItem.blobUrl) {
          console.log('Reusing already-downloaded blob for external tab');
          window.open(currentItem.blobUrl, '_blank');
          status.innerHTML = '<span class="pass">‚úì Opened in external tab (reused downloaded file)!</span>';
          return;
        }
      }

      // No current blob URL - need to download from address bar
      const addressBar = document.getElementById('address-bar');
      const url = addressBar.value.trim();

      if (!url) {
        status.innerHTML = '<span style="color:#f59e0b">‚ö†Ô∏è Enter a URL in the address bar first.</span>';
        return;
      }

      // Download and open in new tab
      const progress = document.getElementById('iframe-progress');

      progress.style.display = 'none';
      progress.value = 0;

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.textContent = 'Downloading for external tab...';
        const obj = url.startsWith('sia://')
          ? await sdk.sharedObject(url)
          : await sdk.object(url);

        const { blob: downloadedBlob } = await streamingDownload(sdk, obj, status, progress, 'Downloading');

        // Detect MIME type
        status.textContent = 'Detecting file type...';
        const detectedType = await fileTypeFromBlob(downloadedBlob);

        let mimeType = 'application/octet-stream';
        let fileType = 'external';

        if (detectedType) {
          mimeType = detectedType.mime;
          console.log('External tab - detected MIME type:', mimeType);

          // Categorize for history
          if (mimeType.startsWith('image/')) fileType = 'image';
          else if (mimeType.startsWith('video/')) fileType = 'video';
          else if (mimeType.startsWith('audio/')) fileType = 'audio';
          else if (mimeType === 'application/pdf') fileType = 'pdf';
          else if (mimeType === 'text/html') fileType = 'html';
          else if (mimeType.startsWith('text/')) fileType = 'text';
        } else {
          // Fallback: check if it's valid UTF-8 text
          try {
            const sample = await downloadedBlob.slice(0, 1024).arrayBuffer();
            const text = new TextDecoder('utf-8', { fatal: true }).decode(sample);
            if (text.includes('<html') || text.includes('<!DOCTYPE')) {
              mimeType = 'text/html';
              fileType = 'html';
            } else {
              mimeType = 'text/plain';
              fileType = 'text';
            }
          } catch {
            // Binary file, use default
            console.log('External tab - could not detect type, using default');
          }
        }

        // Open in external tab with detected MIME type
        const blob = new Blob([downloadedBlob], { type: mimeType });
        const blobUrl = URL.createObjectURL(blob);
        window.open(blobUrl, '_blank');

        // Add to history with external flag
        const displayUrl = `External (${fileType}): ${url}`;
        addToHistory(displayUrl, blobUrl, displayUrl, true, url, fileType);

        status.innerHTML = `<span class="pass">‚úì Opened in external tab as ${mimeType}!</span>`;
      } catch (e) {
        status.innerHTML = `<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // Listen for messages from iframe (e.g., from example.html buttons)
    window.addEventListener('message', async (event) => {
      const { type, url, title } = event.data;

      if (type === 'LOAD_IN_VIEWER') {
        // Load the share URL in the iframe viewer
        const status = document.getElementById('iframe-status');
        const progress = document.getElementById('iframe-progress');
        const iframe = document.getElementById('html-iframe');
        const browserNav = document.getElementById('browser-nav');
        const browserContainer = document.getElementById('browser-container');

        progress.style.display = 'none';
        progress.value = 0;

        try {
          const sdk = await connectSdk(status);
          if (!sdk) return;

          status.textContent = `Loading ${title || 'file'}...`;
          const obj = await sdk.sharedObject(url);
          const size = obj.size();

          const { blob, elapsed } = await streamingDownload(sdk, obj, status, progress, 'Downloading');

          // Load into iframe (let browser detect content type)
          const blobUrl = URL.createObjectURL(blob);
          iframe.src = blobUrl;

          // Add to history
          const displayUrl = title || url;
          addToHistory(displayUrl, blobUrl, title, false, url, 'html');

          status.innerHTML = `Size: ${formatSize(size)}\nLoaded in ${elapsed}s\n<span class="pass">${title || 'File'} loaded!</span>`;
        } catch (e) {
          status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
        }
      } else if (type === 'LOAD_IN_NEW_TAB') {
        // Download and open in new tab
        const status = document.getElementById('iframe-status');
        const progress = document.getElementById('iframe-progress');

        progress.style.display = 'none';
        progress.value = 0;

        try {
          const sdk = await connectSdk(status);
          if (!sdk) return;

          status.textContent = `Downloading ${title || 'file'}...`;
          const obj = await sdk.sharedObject(url);
          const size = obj.size();

          const { blob, elapsed } = await streamingDownload(sdk, obj, status, progress, 'Downloading');

          // Open in new tab (let browser detect content type)
          const blobUrl = URL.createObjectURL(blob);
          window.open(blobUrl, '_blank');

          status.innerHTML = `Size: ${formatSize(size)}\nDownloaded in ${elapsed}s\n<span class="pass">${title || 'File'} opened in new tab!</span>`;

          // Clean up blob URL after a delay
          setTimeout(() => URL.revokeObjectURL(blobUrl), 1000);
        } catch (e) {
          status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
        }
      }
    });

  </script>
</body>
</html>
