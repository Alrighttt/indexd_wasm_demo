<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>indexd WASM Demo</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #0a0a0a; color: #e0e0e0; padding: 2rem; max-width: 800px; margin: 0 auto; }
    h1 { font-size: 1.5rem; margin-bottom: 1.5rem; color: #fff; }
    h2 { font-size: 1.1rem; margin-bottom: 0.75rem; color: #b0b0b0; }
    section { background: #151515; border: 1px solid #2a2a2a; border-radius: 8px; padding: 1.25rem; margin-bottom: 1.25rem; }
    button { background: #1a6b3c; color: #fff; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer; font-size: 0.875rem; }
    button:hover { background: #1f8148; }
    button:disabled { background: #333; color: #666; cursor: not-allowed; }
    input, textarea { background: #1a1a1a; color: #e0e0e0; border: 1px solid #333; border-radius: 4px; padding: 0.5rem; width: 100%; font-family: monospace; font-size: 0.8rem; }
    textarea { resize: vertical; min-height: 3rem; }
    .row { display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem; }
    .output { background: #0d0d0d; border: 1px solid #222; border-radius: 4px; padding: 0.75rem; margin-top: 0.75rem; font-family: monospace; font-size: 0.8rem; white-space: pre-wrap; word-break: break-all; min-height: 2rem; }
    .label { font-size: 0.75rem; color: #888; margin-bottom: 0.25rem; }
    .pass { color: #4ade80; }
    .fail { color: #f87171; }
    #loading { text-align: center; padding: 2rem; color: #888; }
    #app { display: none; }
    .dropzone { border: 2px dashed #333; border-radius: 8px; padding: 2rem; text-align: center; color: #666; cursor: pointer; transition: border-color 0.2s, color 0.2s; }
    .dropzone:hover, .dropzone.dragover { border-color: #1a6b3c; color: #4ade80; }
    .dropzone .file-info { color: #e0e0e0; font-size: 0.85rem; margin-top: 0.5rem; }
    hr { border: none; border-top: 1px solid #2a2a2a; margin: 1rem 0; }
    progress { width: 100%; height: 8px; appearance: none; border: none; border-radius: 4px; overflow: hidden; margin-top: 0.5rem; }
    progress::-webkit-progress-bar { background: #1a1a1a; border-radius: 4px; }
    progress::-webkit-progress-value { background: #1a6b3c; border-radius: 4px; }
    progress::-moz-progress-bar { background: #1a6b3c; border-radius: 4px; }

    /* Browser Navigation Controls */
    .browser-nav { display: flex; flex-direction: column; gap: 0.5rem; margin-top: 1rem; padding: 0.5rem; background: #0d0d0d; border: 1px solid #222; border-radius: 4px; }
    .browser-nav-row { display: flex; gap: 0.5rem; align-items: center; }
    .browser-nav button { padding: 0.4rem 0.75rem; font-size: 0.8rem; min-width: auto; }
    .browser-nav .address-bar { flex: 1; background: #1a1a1a; border: 1px solid #333; border-radius: 4px; padding: 0.4rem 0.6rem; font-family: monospace; font-size: 0.75rem; color: #ddd; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .browser-nav .address-bar:focus { outline: none; border-color: #667eea; background: #222; }
    .browser-container { display: flex; gap: 1rem; margin-top: 1rem; }
    .browser-main { flex: 1; min-width: 0; }
    .browser-history { width: 200px; background: #0d0d0d; border: 1px solid #222; border-radius: 4px; padding: 0.75rem; max-height: 600px; overflow-y: auto; }
    .browser-history h3 { font-size: 0.85rem; color: #b0b0b0; margin-bottom: 0.5rem; }
    .history-item { font-size: 0.75rem; padding: 0.4rem; margin-bottom: 0.25rem; background: #151515; border: 1px solid #2a2a2a; border-radius: 4px; cursor: pointer; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; transition: background 0.2s; }
    .history-item:hover { background: #1a1a1a; }
    .history-item.active { background: #1a6b3c; border-color: #1f8148; }
  </style>
</head>
<body>
  <h1>indexd WASM Demo</h1>

  <div id="loading">Loading WASM module...</div>

  <div id="app">
    <!-- Configuration -->
    <section>
      <h2>Configuration</h2>
      <div class="label">Indexer URL</div>
      <input id="cfg-url" type="text" placeholder="https://indexer.example.com" style="margin-bottom:0.5rem" />
      <div class="label">App Key (hex seed)</div>
      <input id="cfg-key" type="text" placeholder="e.g. ab12cd34..." style="margin-bottom:0.5rem" />
      <hr />
      <div class="label" style="cursor:pointer; user-select:none;" id="performance-toggle">
        <span id="performance-arrow" style="display:inline-block; transition:transform 0.2s;">‚ñ∂</span> Performance
      </div>
      <div id="performance-section" style="display:none;">
        <div style="display:flex; gap:0.5rem; margin-bottom:0.75rem; margin-top:0.5rem;">
          <button id="preset-conservative" style="flex:1; padding:0.6rem; background:#10b981; color:white; border:none; border-radius:4px; cursor:pointer; font-size:0.85rem;">
            üê¢ Conservative<br><span style="font-size:0.7rem; opacity:0.9;">Most Stable</span>
          </button>
          <button id="preset-balanced" style="flex:1; padding:0.6rem; background:#3b82f6; color:white; border:none; border-radius:4px; cursor:pointer; font-size:0.85rem;">
            ‚öñÔ∏è Balanced<br><span style="font-size:0.7rem; opacity:0.9;">Recommended</span>
          </button>
          <button id="preset-fast" style="flex:1; padding:0.6rem; background:#f59e0b; color:white; border:none; border-radius:4px; cursor:pointer; font-size:0.85rem;">
            üöÄ Fast<br><span style="font-size:0.7rem; opacity:0.9;">May Be Unstable</span>
          </button>
        </div>
        <div class="label" style="margin-top:0.5rem;">Concurrency Limits</div>
        <div style="display:grid; grid-template-columns: 2fr 1fr; gap:0.5rem; align-items:center; margin-bottom:0.5rem;">
          <label style="font-size:0.85rem; color:#999;">Max Price Fetches:</label>
          <input id="cfg-max-price-fetches" type="number" min="1" max="10" value="10" style="padding:0.4rem; text-align:center;" />
          <label style="font-size:0.85rem; color:#999;">Max Downloads:</label>
          <input id="cfg-max-downloads" type="number" min="1" max="20" value="20" style="padding:0.4rem; text-align:center;" />
          <label style="font-size:0.85rem; color:#999;">Max Uploads:</label>
          <input id="cfg-max-uploads" type="number" min="1" max="20" value="16" style="padding:0.4rem; text-align:center;" />
        </div>
        <div style="font-size:0.75rem; color:#999; margin-bottom:0.75rem; line-height:1.4;">
          üí° Lower = more stable, higher = faster. Changes require reconnecting SDK.
        </div>
      </div>
      <hr />
      <div class="label">Recovery Phrase</div>
      <div class="row">
        <input id="phrase" type="text" placeholder="recovery phrase appears here" />
        <button id="btn-generate">Generate</button>
        <button id="btn-validate">Validate</button>
      </div>
      <div class="output" id="phrase-output"></div>
    </section>

    <!-- Register -->
    <section>
      <h2>Register App</h2>
      <div class="label">App Name</div>
      <input id="reg-name" type="text" placeholder="My App" style="margin-bottom:0.5rem" />
      <div class="label">App Description</div>
      <input id="reg-desc" type="text" placeholder="A brief description of your app" style="margin-bottom:0.5rem" />
      <div class="label">Service URL</div>
      <input id="reg-service-url" type="text" placeholder="https://myapp.example.com" style="margin-bottom:0.5rem" />
      <div class="row">
        <button id="btn-gen-curl">1. Generate curl command</button>
      </div>
      <div class="output" id="reg-curl" style="display:none; cursor:pointer;" title="Click to copy"></div>
      <div id="reg-paste-section" style="display:none; margin-top:0.75rem;">
        <div class="label">Paste the JSON response from curl here:</div>
        <textarea id="reg-response" rows="3" placeholder='{"responseURL":"...","statusURL":"...","registerURL":"...","expiration":"..."}'></textarea>
        <div class="row" style="margin-top:0.5rem">
          <button id="btn-set-response">2. Continue</button>
        </div>
      </div>
      <div class="output" id="reg-status" style="display:none;"></div>
      <div id="reg-approval" style="display:none; margin-top:0.75rem;">
        <div class="label">Approve the connection by visiting the link above, then:</div>
        <div class="row">
          <button id="btn-wait-approval">3. Wait for Approval</button>
        </div>
      </div>
      <div id="reg-finalize" style="display:none; margin-top:0.75rem;">
        <div class="label">Recovery Phrase (uses the phrase from Configuration above, or enter one here)</div>
        <div class="row">
          <input id="reg-mnemonic" type="text" placeholder="leave blank to use the phrase above" />
          <button id="btn-reg-generate">Generate</button>
        </div>
        <div class="row" style="margin-top:0.5rem">
          <button id="btn-register">4. Register</button>
        </div>
      </div>
      <div class="output" id="reg-result" style="display:none; margin-top:0.75rem;"></div>
    </section>

    <!-- Upload Text -->
    <section>
      <h2>Upload Text</h2>
      <div class="label">Text to upload</div>
      <textarea id="ul-text" rows="4" placeholder="Type or paste text here..."></textarea>
      <div class="row" style="margin-top:0.5rem">
        <button id="btn-upload">Upload</button>
      </div>
      <progress id="ul-progress" max="100" value="0" style="display:none"></progress>
      <div class="output" id="ul-status"></div>
    </section>

    <!-- Download Text -->
    <section>
      <h2>Download Text</h2>
      <div class="label">Object ID (hex)</div>
      <div class="row">
        <input id="dt-object-id" type="text" placeholder="e.g. 0e90d697f504..." />
        <button id="btn-download-text">Download</button>
      </div>
      <progress id="dt-progress" max="100" value="0" style="display:none"></progress>
      <div class="output" id="dt-status"></div>
      <div class="label" style="margin-top:0.75rem">Contents</div>
      <div class="output" id="dt-contents" style="min-height:6rem; max-height:24rem; overflow-y:auto;"></div>
    </section>

    <!-- Upload File -->
    <section>
      <h2>Upload File</h2>
      <div class="dropzone" id="uf-dropzone">
        Drop a file here or click to select
        <input type="file" id="uf-file" style="display:none" />
        <div class="file-info" id="uf-file-info"></div>
      </div>
      <div class="row" style="margin-top:0.5rem">
        <button id="btn-upload-file">Upload</button>
      </div>
      <progress id="uf-progress" max="100" value="0" style="display:none"></progress>
      <div class="output" id="uf-status"></div>
    </section>

    <!-- Download File -->
    <section>
      <h2>Download File</h2>
      <div class="label">Object ID (hex)</div>
      <input id="dl-object-id" type="text" placeholder="e.g. 0e90d697f504..." style="margin-bottom:0.5rem" />
      <div class="label" style="margin-top:0.75rem">OR Share URL</div>
      <input id="dl-share-url" type="text" placeholder="sia:// or https:// share URL" style="margin-bottom:0.5rem" />
      <div class="label">Filename</div>
      <div class="row">
        <input id="dl-filename" type="text" placeholder="e.g. photo.jpg" />
        <button id="btn-download">Download</button>
      </div>
      <progress id="dl-progress" max="100" value="0" style="display:none"></progress>
      <div class="output" id="dl-status"></div>
    </section>

    <!-- Share Object -->
    <section>
      <h2>Share Object</h2>
      <div class="label">Object ID (hex)</div>
      <input id="share-object-id" type="text" placeholder="e.g. 0e90d697f504..." style="margin-bottom:0.5rem" />
      <div class="label">Expires in</div>
      <div class="row">
        <input id="share-duration" type="number" value="24" min="1" style="width:5rem" />
        <select id="share-unit" style="background:#1a1a1a; color:#e0e0e0; border:1px solid #333; border-radius:4px; padding:0.5rem;">
          <option value="3600000">hours</option>
          <option value="86400000" selected>days</option>
          <option value="604800000">weeks</option>
        </select>
        <button id="btn-share">Generate Link</button>
      </div>
      <div class="output" id="share-status"></div>
    </section>

    <!-- Media -->
    <section>
      <h2>Media</h2>
      <div class="label">Media Type</div>
      <select id="stream-media-type" style="width:100%; padding:0.5rem; background:#1a1a1a; color:#e0e0e0; border:1px solid #333; border-radius:4px; font-family:inherit; font-size:0.9rem; margin-bottom:0.75rem;">
        <option value="html">HTML Page</option>
        <option value="image">Image (jpg, png, gif, svg, webp)</option>
        <option value="video">Video (mp4, webm, ogg)</option>
        <option value="audio">Audio (mp3, wav, ogg)</option>
        <option value="pdf">PDF Document</option>
        <option value="text">Text File</option>
      </select>
      <div class="label">Object ID</div>
      <input id="stream-object-id" type="text" placeholder="hex object id" />
      <div class="label" style="margin-top:0.75rem">OR Share URL</div>
      <input id="stream-share-url" type="text" placeholder="sia:// or https:// share URL" />
      <div class="row" style="margin-top:0.5rem">
        <button id="btn-stream-media">View Media</button>
      </div>
      <progress id="stream-progress" max="100" value="0" style="display:none"></progress>
      <div class="output" id="stream-status"></div>
      <div id="stream-container" style="display:none; width:100%; margin-top:1rem; border:1px solid #333; border-radius:4px; overflow:hidden;"></div>
    </section>

    <!-- HTML Viewer (Decentralized Browser) -->
    <section>
      <h2>üåê Decentralized Browser</h2>

      <!-- Browser Navigation Controls -->
      <div class="browser-nav" id="browser-nav">
        <div class="browser-nav-row">
          <button id="btn-back" title="Go Back" disabled>‚óÄ Back</button>
          <button id="btn-forward" title="Go Forward" disabled>Forward ‚ñ∂</button>
          <input type="text" class="address-bar" id="address-bar" placeholder="Paste Sia share URL or object ID..." title="Press Enter or click a file type button">
        </div>
        <div class="browser-nav-row">
          <button id="btn-load-html" title="Load as HTML">üìÑ HTML</button>
          <button id="btn-load-pdf" title="Download and open PDF in new tab">üìï PDF</button>
          <button id="btn-load-image" title="Load as Image">üñºÔ∏è Image</button>
          <button id="btn-load-video" title="Load as Video">üé¨ Video</button>
          <button id="btn-external-tab" title="Open in External Tab (‚ö†Ô∏è JavaScript enabled)" style="background:#f59e0b; border-color:#f59e0b;">HTML in External Tab</button>
        </div>
      </div>

      <progress id="iframe-progress" max="100" value="0" style="display:none; margin-top:1rem"></progress>
      <div class="output" id="iframe-status"></div>

      <!-- Browser Container with Iframe and History -->
      <div class="browser-container" id="browser-container">
        <div class="browser-main">
          <iframe id="html-iframe" style="width:100%; height:600px; border:1px solid #333; border-radius:4px; background:white;" sandbox="allow-same-origin"></iframe>
        </div>
        <div class="browser-history">
          <h3>üìú History</h3>
          <div id="history-list"></div>
        </div>
      </div>
    </section>

  </div>

  <script type="module">
    import init, {
      generateRecoveryPhrase,
      validateRecoveryPhrase,
      AppKey,
      Builder,
    } from './pkg/indexd_wasm.js';

    let currentKey = null;

    function hex(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function randomHex(len) {
      const arr = new Uint8Array(len);
      crypto.getRandomValues(arr);
      return hex(arr);
    }

    function fromHex(h) {
      const bytes = new Uint8Array(h.length / 2);
      for (let i = 0; i < bytes.length; i++) {
        bytes[i] = parseInt(h.substr(i * 2, 2), 16);
      }
      return bytes;
    }

    function formatSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
      return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
    }

    // Auto-restore config from localStorage on page load
    const urlInput = document.getElementById('cfg-url');
    const keyInput = document.getElementById('cfg-key');
    const maxPriceFetchesInput = document.getElementById('cfg-max-price-fetches');
    const maxDownloadsInput = document.getElementById('cfg-max-downloads');
    const maxUploadsInput = document.getElementById('cfg-max-uploads');

    const savedUrl = localStorage.getItem('indexer-url');
    const savedKey = localStorage.getItem('app-key');
    const savedMaxPriceFetches = localStorage.getItem('max-price-fetches');
    const savedMaxDownloads = localStorage.getItem('max-downloads');
    const savedMaxUploads = localStorage.getItem('max-uploads');

    if (savedUrl) urlInput.value = savedUrl;
    if (savedKey) keyInput.value = savedKey;
    if (savedMaxPriceFetches) maxPriceFetchesInput.value = savedMaxPriceFetches;
    if (savedMaxDownloads) maxDownloadsInput.value = savedMaxDownloads;
    if (savedMaxUploads) maxUploadsInput.value = savedMaxUploads;

    // Performance section toggle
    document.getElementById('performance-toggle').addEventListener('click', () => {
      const section = document.getElementById('performance-section');
      const arrow = document.getElementById('performance-arrow');
      if (section.style.display === 'none') {
        section.style.display = 'block';
        arrow.style.transform = 'rotate(90deg)';
      } else {
        section.style.display = 'none';
        arrow.style.transform = 'rotate(0deg)';
      }
    });

    // Save to localStorage when config changes
    urlInput.addEventListener('input', () => {
      localStorage.setItem('indexer-url', urlInput.value.trim());
    });
    keyInput.addEventListener('input', () => {
      localStorage.setItem('app-key', keyInput.value.trim());
    });
    maxPriceFetchesInput.addEventListener('input', () => {
      localStorage.setItem('max-price-fetches', maxPriceFetchesInput.value);
      cachedSdk = null; // Invalidate SDK cache when concurrency settings change
    });
    maxDownloadsInput.addEventListener('input', () => {
      localStorage.setItem('max-downloads', maxDownloadsInput.value);
      cachedSdk = null; // Invalidate SDK cache when concurrency settings change
    });
    maxUploadsInput.addEventListener('input', () => {
      localStorage.setItem('max-uploads', maxUploadsInput.value);
      cachedSdk = null; // Invalidate SDK cache when concurrency settings change
    });

    // helpers to read shared config
    function getUrl() { return document.getElementById('cfg-url').value.trim(); }
    function getKeyHex() { return document.getElementById('cfg-key').value.trim(); }
    function getMaxPriceFetches() { return parseInt(document.getElementById('cfg-max-price-fetches').value) || 10; }
    function getMaxDownloads() { return parseInt(document.getElementById('cfg-max-downloads').value) || 20; }
    function getMaxUploads() { return parseInt(document.getElementById('cfg-max-uploads').value) || 16; }

    // SDK cache to avoid recreating and re-initializing
    let cachedSdk = null;
    let cachedConfig = null;

    async function connectSdk(statusEl) {
      const url = getUrl();
      const keyHex = getKeyHex();
      if (!url || !keyHex) {
        statusEl.innerHTML = '<span class="fail">Set Indexer URL and App Key in Configuration first</span>';
        return null;
      }

      // Return cached SDK if config hasn't changed (include concurrency settings in cache key)
      const maxPriceFetches = getMaxPriceFetches();
      const maxDownloads = getMaxDownloads();
      const maxUploads = getMaxUploads();
      const currentConfig = `${url}|${keyHex}|${maxPriceFetches}|${maxDownloads}|${maxUploads}`;
      if (cachedSdk && cachedConfig === currentConfig) {
        statusEl.innerHTML = '<span class="pass">Using cached connection</span>';
        return cachedSdk;
      }

      statusEl.textContent = 'Creating app key...';
      const seed = fromHex(keyHex);
      const appKey = new AppKey(seed);
      statusEl.textContent = `App key created. Public key: ${appKey.publicKey()}\nConnecting to indexer...`;
      const builder = new Builder(url);

      // Configure concurrency limits
      builder.withMaxPriceFetches(maxPriceFetches);
      builder.withMaxDownloads(maxDownloads);
      builder.withMaxUploads(maxUploads);

      const sdk = await builder.connected(appKey);
      if (!sdk) {
        statusEl.innerHTML = '<span class="fail">App key not recognized by this indexer. Register first.</span>';
        return null;
      }

      // Cache the SDK
      cachedSdk = sdk;
      cachedConfig = currentConfig;
      statusEl.innerHTML = '<span class="pass">Connected!</span>';
      return sdk;
    }

    await init();
    console.log('[JS] WASM module initialized successfully');
    document.getElementById('loading').style.display = 'none';
    document.getElementById('app').style.display = 'block';

    // -- Performance Presets --
    function setPreset(priceFetches, downloads, uploads) {
      document.getElementById('cfg-max-price-fetches').value = priceFetches;
      document.getElementById('cfg-max-downloads').value = downloads;
      document.getElementById('cfg-max-uploads').value = uploads;
      localStorage.setItem('max-price-fetches', priceFetches);
      localStorage.setItem('max-downloads', downloads);
      localStorage.setItem('max-uploads', uploads);
      cachedSdk = null; // Invalidate SDK cache
    }

    document.getElementById('preset-conservative').addEventListener('click', () => setPreset(5, 10, 8));
    document.getElementById('preset-balanced').addEventListener('click', () => setPreset(10, 20, 16));
    document.getElementById('preset-fast').addEventListener('click', () => setPreset(10, 20, 20));

    // -- Recovery Phrase --
    document.getElementById('btn-generate').addEventListener('click', () => {
      const phrase = generateRecoveryPhrase();
      document.getElementById('phrase').value = phrase;
      document.getElementById('phrase-output').innerHTML = '<span class="pass">Generated successfully</span>';
    });

    document.getElementById('btn-validate').addEventListener('click', () => {
      const phrase = document.getElementById('phrase').value.trim();
      const out = document.getElementById('phrase-output');
      if (!phrase) {
        out.innerHTML = '<span class="fail">Enter a phrase first</span>';
        return;
      }
      try {
        validateRecoveryPhrase(phrase);
        out.innerHTML = '<span class="pass">Valid recovery phrase</span>';
      } catch (e) {
        out.innerHTML = `<span class="fail">Invalid: ${e.message}</span>`;
      }
    });

    // -- Register --
    let regBuilder = null;
    let regAppId = null;

    document.getElementById('btn-gen-curl').addEventListener('click', () => {
      const curlDiv = document.getElementById('reg-curl');
      const pasteSection = document.getElementById('reg-paste-section');
      const status = document.getElementById('reg-status');
      const approvalDiv = document.getElementById('reg-approval');
      const finalizeDiv = document.getElementById('reg-finalize');
      const resultDiv = document.getElementById('reg-result');
      const url = getUrl();
      const name = document.getElementById('reg-name').value.trim();
      const desc = document.getElementById('reg-desc').value.trim();
      const serviceUrl = document.getElementById('reg-service-url').value.trim();

      status.style.display = 'none';
      approvalDiv.style.display = 'none';
      finalizeDiv.style.display = 'none';
      resultDiv.style.display = 'none';

      if (!url || !name || !desc || !serviceUrl) {
        curlDiv.style.display = 'block';
        curlDiv.innerHTML = '<span class="fail">Indexer URL (in Configuration) and all fields are required</span>';
        return;
      }

      regAppId = randomHex(32);
      const body = JSON.stringify({
        appID: regAppId,
        name: name,
        description: desc,
        serviceURL: serviceUrl,
      });

      const curlCmd = `curl -s -X POST ${url}/auth/connect -H 'Content-Type: application/json' -d '${body}'`;
      curlDiv.style.display = 'block';
      curlDiv.textContent = curlCmd;
      pasteSection.style.display = 'block';

      curlDiv.onclick = () => {
        navigator.clipboard.writeText(curlCmd);
        curlDiv.innerHTML = curlDiv.textContent + '\n<span class="pass">Copied!</span>';
      };
    });

    document.getElementById('btn-set-response').addEventListener('click', () => {
      const status = document.getElementById('reg-status');
      const approvalDiv = document.getElementById('reg-approval');
      const responseJson = document.getElementById('reg-response').value.trim();
      const url = getUrl();

      if (!responseJson) {
        status.style.display = 'block';
        status.innerHTML = '<span class="fail">Paste the JSON response first</span>';
        return;
      }

      try {
        const parsed = JSON.parse(responseJson);
        if (!parsed.responseURL || !parsed.statusURL || !parsed.registerURL) {
          throw new Error('Response must contain responseURL, statusURL, and registerURL');
        }

        regBuilder = new Builder(url);
        regBuilder.setConnectionResponse(regAppId, responseJson);

        const responseUrl = regBuilder.responseUrl();
        status.style.display = 'block';
        status.innerHTML = `<span class="pass">Connection response accepted!</span>\n\nApprove this app by visiting:\n<a href="${responseUrl}" target="_blank" rel="noopener" style="color:#60a5fa; word-break:break-all;">${responseUrl}</a>`;
        approvalDiv.style.display = 'block';
      } catch (e) {
        status.style.display = 'block';
        status.innerHTML = `<span class="fail">Error: ${e.message}</span>`;
      }
    });

    document.getElementById('btn-wait-approval').addEventListener('click', async () => {
      const status = document.getElementById('reg-status');
      const finalizeDiv = document.getElementById('reg-finalize');
      const btn = document.getElementById('btn-wait-approval');

      if (!regBuilder) {
        status.innerHTML += `\n<span class="fail">Complete steps 1 and 2 first</span>`;
        return;
      }

      try {
        btn.disabled = true;
        btn.textContent = 'Waiting for approval...';
        status.innerHTML += '\n\nPolling for approval (this may take a while)...';

        await regBuilder.waitForApproval();

        status.innerHTML += `\n<span class="pass">Approved!</span>`;
        btn.textContent = 'Approved!';
        finalizeDiv.style.display = 'block';
      } catch (e) {
        btn.disabled = false;
        btn.textContent = '3. Wait for Approval';
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    document.getElementById('btn-reg-generate').addEventListener('click', () => {
      document.getElementById('reg-mnemonic').value = generateRecoveryPhrase();
    });

    document.getElementById('btn-register').addEventListener('click', async () => {
      const status = document.getElementById('reg-status');
      const resultDiv = document.getElementById('reg-result');
      // use register-specific mnemonic if provided, otherwise fall back to config phrase
      const mnemonic = document.getElementById('reg-mnemonic').value.trim()
        || document.getElementById('phrase').value.trim();

      if (!regBuilder) {
        status.innerHTML += `\n<span class="fail">Complete previous steps first</span>`;
        return;
      }
      if (!mnemonic) {
        status.innerHTML += `\n<span class="fail">Enter a recovery phrase in Configuration or the field above</span>`;
        return;
      }

      try {
        status.innerHTML += '\nRegistering...';
        const sdk = await regBuilder.register(mnemonic);
        const appKey = sdk.appKey();
        const seed = hex(appKey.export());
        const pubkey = appKey.publicKey();

        // auto-fill the config app key field and save to localStorage
        document.getElementById('cfg-key').value = seed;
        localStorage.setItem('app-key', seed);

        status.innerHTML += `\n<span class="pass">Registered successfully!</span>`;
        resultDiv.style.display = 'block';
        resultDiv.innerHTML = `<span class="pass">Registration complete!</span>\n\nApp Key Seed (auto-filled in Configuration above):\n${seed}\n\nPublic Key:\n${pubkey}\n\n<span style="color:#fbbf24;">Save your recovery phrase and app key seed securely!</span>`;
        regBuilder = null;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Upload Text --
    document.getElementById('btn-upload').addEventListener('click', async () => {
      const status = document.getElementById('ul-status');
      const progress = document.getElementById('ul-progress');
      const text = document.getElementById('ul-text').value;

      if (!text) {
        status.innerHTML = '<span class="fail">Enter some text to upload</span>';
        return;
      }

      progress.style.display = 'none';
      progress.value = 0;

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        const data = new TextEncoder().encode(text);
        progress.style.display = 'block';
        status.textContent = 'Uploading...';

        const uploadStart = performance.now();
        const obj = await sdk.uploadWithProgress(data, (current, total) => {
          progress.max = total;
          progress.value = current;
          status.textContent = `Uploading... ${current}/${total} shards`;
        });
        const elapsed = ((performance.now() - uploadStart) / 1000).toFixed(1);
        const objectId = obj.id();
        const size = obj.size();

        progress.value = progress.max;
        status.innerHTML = `Upload complete (${size} bytes) in ${elapsed}s. Pinning to indexer...`;

        await sdk.pinObject(obj);

        status.innerHTML += `\n<span class="pass">Pinned!</span>\n\nObject ID: ${objectId}`;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Download Text --
    document.getElementById('btn-download-text').addEventListener('click', async () => {
      const status = document.getElementById('dt-status');
      const progress = document.getElementById('dt-progress');
      const contents = document.getElementById('dt-contents');
      const objectId = document.getElementById('dt-object-id').value.trim();

      contents.textContent = '';
      progress.style.display = 'none';
      progress.value = 0;

      if (!objectId) {
        status.innerHTML = '<span class="fail">Enter an Object ID</span>';
        return;
      }

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.innerHTML += '\nFetching object metadata...';

        const obj = await sdk.object(objectId);
        const size = obj.size();
        status.innerHTML = `Object found: ${formatSize(size)}`;

        progress.style.display = 'block';
        status.textContent = 'Downloading...';

        const downloadStart = performance.now();
        const data = await sdk.downloadWithProgress(obj, (current, total) => {
          progress.max = total;
          progress.value = current;
          status.textContent = `Downloading... ${current}/${total} slabs`;
        });
        const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
        const text = new TextDecoder('utf-8', { fatal: false }).decode(data);

        progress.value = progress.max;
        status.innerHTML = `Size: ${formatSize(size)}\nDownloaded in ${elapsed}s\n<span class="pass">Download complete!</span>`;
        contents.textContent = text;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Upload File --
    let selectedFile = null;
    const dropzone = document.getElementById('uf-dropzone');
    const fileInput = document.getElementById('uf-file');
    const fileInfo = document.getElementById('uf-file-info');

    function setFile(file) {
      selectedFile = file;
      fileInfo.textContent = `${file.name} (${formatSize(file.size)})`;
    }

    dropzone.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', () => {
      if (fileInput.files.length) setFile(fileInput.files[0]);
    });
    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.classList.add('dragover');
    });
    dropzone.addEventListener('dragleave', () => {
      dropzone.classList.remove('dragover');
    });
    dropzone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropzone.classList.remove('dragover');
      if (e.dataTransfer.files.length) setFile(e.dataTransfer.files[0]);
    });

    document.getElementById('btn-upload-file').addEventListener('click', async () => {
      const status = document.getElementById('uf-status');
      const progress = document.getElementById('uf-progress');
      const MAX_FILE_SIZE = 2 * 1024 * 1024 * 1024; // 2 GB - wasm32 memory limit

      if (!selectedFile) {
        status.innerHTML = '<span class="fail">Select a file first</span>';
        return;
      }

      if (selectedFile.size > MAX_FILE_SIZE) {
        status.innerHTML = `<span class="fail">File too large (${formatSize(selectedFile.size)}). Maximum is 2 GB due to WASM memory limits.</span>`;
        return;
      }

      progress.style.display = 'none';
      progress.value = 0;

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.innerHTML += '\nReading file...';

        const buffer = await selectedFile.arrayBuffer();
        const data = new Uint8Array(buffer);

        progress.style.display = 'block';
        status.textContent = `Uploading ${selectedFile.name} (${formatSize(data.length)})...`;

        const uploadStart = performance.now();
        const obj = await sdk.uploadWithProgress(data, (current, total) => {
          progress.max = total;
          progress.value = current;
          status.textContent = `Uploading ${selectedFile.name}... ${current}/${total} shards`;
        });
        const elapsed = ((performance.now() - uploadStart) / 1000).toFixed(1);
        const objectId = obj.id();
        const size = obj.size();

        progress.value = progress.max;
        status.innerHTML = `Upload complete (${formatSize(size)}) in ${elapsed}s. Pinning to indexer...`;

        await sdk.pinObject(obj);

        status.innerHTML = `File: ${selectedFile.name}\nSize: ${formatSize(size)}\nUpload + pin completed in ${elapsed}s\n<span class="pass">Pinned!</span>\n\nObject ID: ${objectId}`;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Download File --
    document.getElementById('btn-download').addEventListener('click', async () => {
      const status = document.getElementById('dl-status');
      const progress = document.getElementById('dl-progress');
      const objectId = document.getElementById('dl-object-id').value.trim();
      const shareUrl = document.getElementById('dl-share-url').value.trim();
      const filename = document.getElementById('dl-filename').value.trim() || 'download';

      progress.style.display = 'none';
      progress.value = 0;

      if (!objectId && !shareUrl) {
        status.innerHTML = '<span class="fail">Enter an Object ID or Share URL</span>';
        return;
      }

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.innerHTML += '\nFetching object metadata...';

        const obj = shareUrl
          ? await sdk.sharedObject(shareUrl)
          : await sdk.object(objectId);
        const size = obj.size();
        status.innerHTML = `Object found: ${formatSize(size)}`;

        progress.style.display = 'block';
        status.textContent = 'Downloading...';

        const downloadStart = performance.now();
        let lastProgressUpdate = 0;
        const PROGRESS_THROTTLE_MS = 100;

        const data = await sdk.downloadWithProgress(obj, (current, total) => {
          const now = performance.now();
          if (now - lastProgressUpdate >= PROGRESS_THROTTLE_MS || current === total) {
            progress.max = total;
            progress.value = current;
            status.textContent = `Downloading... ${current}/${total} slabs`;
            lastProgressUpdate = now;
            console.log(`Download progress: ${current}/${total}`);
          }
        });
        const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);

        // trigger browser save dialog
        const blob = new Blob([data]);
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
        URL.revokeObjectURL(a.href);

        progress.value = progress.max;
        status.innerHTML = `File: ${filename}\nSize: ${formatSize(size)}\nDownloaded in ${elapsed}s\n<span class="pass">Saved to disk!</span>`;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Share Object --
    document.getElementById('btn-share').addEventListener('click', async () => {
      const status = document.getElementById('share-status');
      const objectId = document.getElementById('share-object-id').value.trim();
      const duration = parseFloat(document.getElementById('share-duration').value);
      const unit = parseInt(document.getElementById('share-unit').value);

      if (!objectId) {
        status.innerHTML = '<span class="fail">Enter an Object ID</span>';
        return;
      }

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.textContent = 'Fetching object...';
        const obj = await sdk.object(objectId);

        const validUntilMs = Date.now() + (duration * unit);
        const shareUrl = sdk.shareObject(obj, validUntilMs);

        const expiresAt = new Date(validUntilMs).toLocaleString();
        status.innerHTML = `<span class="pass">Share link created!</span>\nExpires: ${expiresAt}\n\n<a href="${shareUrl}" target="_blank" rel="noopener" style="color:#60a5fa; word-break:break-all;">${shareUrl}</a>`;

        document.getElementById('share-url').value = shareUrl;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Media --
    document.getElementById('btn-stream-media').addEventListener('click', async () => {
      const status = document.getElementById('stream-status');
      const progress = document.getElementById('stream-progress');
      const container = document.getElementById('stream-container');
      const objectId = document.getElementById('stream-object-id').value.trim();
      const shareUrl = document.getElementById('stream-share-url').value.trim();
      const mediaType = document.getElementById('stream-media-type').value;

      progress.style.display = 'none';
      progress.value = 0;
      container.style.display = 'none';
      container.innerHTML = '';

      if (!objectId && !shareUrl) {
        status.innerHTML = '<span class="fail">Enter an Object ID or Share URL</span>';
        return;
      }

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.textContent = 'Fetching object metadata...';
        const obj = shareUrl
          ? await sdk.sharedObject(shareUrl)
          : await sdk.object(objectId);
        const size = obj.size();
        status.innerHTML = `Object found: ${formatSize(size)}`;

        progress.style.display = 'block';
        container.style.display = 'block';
        status.textContent = 'Streaming...';

        const chunks = [];
        const streamStart = performance.now();
        let lastProgressUpdate = 0;
        const PROGRESS_THROTTLE_MS = 100; // Throttle progress updates to prevent browser flooding

        // Create appropriate element based on media type
        let element;
        let mimeType;

        switch (mediaType) {
          case 'html':
            element = document.createElement('iframe');
            element.sandbox = 'allow-same-origin';
            element.style.cssText = 'width:100%; height:400px; border:none;';
            mimeType = 'text/html';
            break;
          case 'image':
            element = document.createElement('img');
            element.style.cssText = 'max-width:100%; height:auto; display:block;';
            mimeType = 'image/*';
            break;
          case 'video':
            element = document.createElement('video');
            element.controls = true;
            element.style.cssText = 'width:100%; max-height:500px;';
            mimeType = 'video/*';
            break;
          case 'audio':
            element = document.createElement('audio');
            element.controls = true;
            element.style.cssText = 'width:100%;';
            mimeType = 'audio/*';
            break;
          case 'pdf':
            element = document.createElement('iframe');
            element.style.cssText = 'width:100%; height:600px; border:none;';
            mimeType = 'application/pdf';
            break;
          case 'text':
            element = document.createElement('pre');
            element.style.cssText = 'padding:1rem; background:#0a0a0a; color:#e0e0e0; overflow:auto; max-height:500px; margin:0;';
            mimeType = 'text/plain';
            break;
        }

        container.appendChild(element);

        await sdk.downloadStreaming(obj,
          (chunk) => {
            chunks.push(chunk);

            if (mediaType === 'text') {
              // For text, decode and append incrementally
              const decoder = new TextDecoder();
              element.textContent = decoder.decode(new Uint8Array(chunks.flat()));
            } else if (mediaType === 'html') {
              // For HTML, update iframe incrementally
              const blob = new Blob(chunks, { type: mimeType });
              const url = URL.createObjectURL(blob);
              element.src = url;
            }
            // For image/video/audio/pdf, buffer silently and set src once at the end
          },
          (current, total) => {
            // Throttle progress updates to prevent browser navigation throttling
            const now = performance.now();
            if (now - lastProgressUpdate >= PROGRESS_THROTTLE_MS || current === total) {
              progress.max = total;
              progress.value = current;
              status.textContent = `Buffering... ${current}/${total} slabs`;
              lastProgressUpdate = now;
            }
          }
        );

        // Set src for image/video/audio/pdf after all chunks are buffered
        if (mediaType === 'image' || mediaType === 'video' || mediaType === 'audio' || mediaType === 'pdf') {
          const blob = new Blob(chunks, { type: mimeType });
          const url = URL.createObjectURL(blob);
          element.src = url;
        }

        const elapsed = ((performance.now() - streamStart) / 1000).toFixed(1);
        progress.value = progress.max;

        const typeLabel = mediaType.charAt(0).toUpperCase() + mediaType.slice(1);
        status.innerHTML = `Size: ${formatSize(size)}\nBuffered in ${elapsed}s\n<span class="pass">${typeLabel} ready to view!</span>`;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Decentralized Browser (HTML Viewer with Navigation) --
    const HISTORY_STORAGE_KEY = 'sia-browser-history';
    const browserHistory = [];
    let currentHistoryIndex = -1;

    // Load history from localStorage on page load
    function loadHistoryFromStorage() {
      try {
        const saved = localStorage.getItem(HISTORY_STORAGE_KEY);
        if (saved) {
          const parsed = JSON.parse(saved);
          // Restore history items (blob URLs will be null after refresh)
          browserHistory.push(...parsed);
          console.log(`üìö Restored ${browserHistory.length} history items from localStorage`);
          updateBrowserUI();
        }
      } catch (e) {
        console.error('Failed to load history from storage:', e);
      }
    }

    // Save history to localStorage
    function saveHistoryToStorage() {
      try {
        // Save history without blob URLs (they're temporary)
        const toSave = browserHistory.map(item => ({
          displayUrl: item.displayUrl,
          title: item.title,
          external: item.external,
          originalUrl: item.originalUrl,
          fileType: item.fileType,
          blobUrl: null  // Don't save blob URLs - they won't work after refresh
        }));
        localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(toSave));
      } catch (e) {
        console.error('Failed to save history to storage:', e);
      }
    }

    // Load history when page loads
    loadHistoryFromStorage();

    function updateBrowserUI() {
      const backBtn = document.getElementById('btn-back');
      const forwardBtn = document.getElementById('btn-forward');
      const addressBar = document.getElementById('address-bar');
      const historyList = document.getElementById('history-list');

      // Update back/forward buttons
      backBtn.disabled = currentHistoryIndex <= 0;
      forwardBtn.disabled = currentHistoryIndex >= browserHistory.length - 1;

      // Update address bar
      if (currentHistoryIndex >= 0 && browserHistory[currentHistoryIndex]) {
        const current = browserHistory[currentHistoryIndex];
        addressBar.value = current.displayUrl;
        addressBar.title = current.displayUrl;
      } else {
        addressBar.value = '';
        addressBar.placeholder = 'Enter Sia share URL or object ID...';
      }

      // Update history list
      historyList.innerHTML = '';
      browserHistory.forEach((item, index) => {
        const historyItem = document.createElement('div');
        historyItem.className = 'history-item' + (index === currentHistoryIndex ? ' active' : '');

        // Only show warning for external HTML tabs, not for PDFs (which are safe)
        const isPdf = item.displayUrl && item.displayUrl.startsWith('PDF:');
        const showWarning = item.external && !isPdf;

        historyItem.textContent = (showWarning ? '‚ö†Ô∏è ' : '') + (item.title || item.displayUrl);
        historyItem.title = (showWarning ? '[External Tab] ' : '') + item.displayUrl;
        historyItem.addEventListener('click', () => navigateToHistory(index));
        historyList.appendChild(historyItem);
      });
    }

    async function navigateToHistory(index) {
      if (index < 0 || index >= browserHistory.length) return;
      currentHistoryIndex = index;
      const item = browserHistory[index];

      // If blob URL is null (e.g., after page refresh), re-download the file
      if (!item.blobUrl) {
        console.log('üîÑ Blob URL missing, re-downloading:', item.originalUrl);
        await redownloadHistoryItem(item, index);
        return;
      }

      // If this is an external tab item, reopen it in external tab
      if (item.external) {
        window.open(item.blobUrl, '_blank');
      } else {
        // Load in iframe
        const iframe = document.getElementById('html-iframe');
        iframe.src = item.blobUrl;
      }
      updateBrowserUI();
    }

    // Re-download a history item (when blob URL is missing after refresh)
    async function redownloadHistoryItem(item, index) {
      const status = document.getElementById('iframe-status');
      const progress = document.getElementById('iframe-progress');
      const iframe = document.getElementById('html-iframe');

      progress.style.display = 'none';
      progress.value = 0;

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.textContent = `Re-downloading ${item.fileType}...`;

        const obj = item.originalUrl.startsWith('sia://')
          ? await sdk.sharedObject(item.originalUrl)
          : await sdk.object(item.originalUrl);

        progress.style.display = 'block';
        const data = await sdk.downloadWithProgress(obj, (current, total) => {
          progress.max = total;
          progress.value = current;
          status.textContent = `Downloading... ${current}/${total} slabs`;
        });

        progress.value = progress.max;

        // Create blob with appropriate MIME type
        let mimeType = 'text/html';
        if (item.fileType === 'pdf') mimeType = 'application/pdf';
        else if (item.fileType === 'image') mimeType = 'image/jpeg';
        else if (item.fileType === 'video') mimeType = 'video/mp4';

        const blob = new Blob([data], { type: mimeType });
        const blobUrl = URL.createObjectURL(blob);

        // Update history item with new blob URL
        browserHistory[index].blobUrl = blobUrl;

        // Load the file
        if (item.external || item.fileType === 'pdf') {
          window.open(blobUrl, '_blank');
          status.innerHTML = '<span class="pass">‚úì Reopened in new tab!</span>';
        } else {
          iframe.src = blobUrl;
          status.innerHTML = '<span class="pass">‚úì Loaded!</span>';
        }

        updateBrowserUI();
      } catch (e) {
        status.innerHTML = `<span class="fail">Error re-downloading: ${e.message}</span>`;
      }
    }

    function addToHistory(displayUrl, blobUrl, title = null, external = false, originalUrl = '', fileType = 'html') {
      console.log('üîç addToHistory called:', {
        displayUrl,
        external,
        originalUrl,
        fileType,
        currentHistoryIndex,
        historyLength: browserHistory.length
      });

      // Check if this URL already exists in history (by original URL, not blob URL)
      const existingIndex = browserHistory.findIndex(item =>
        item.originalUrl === originalUrl && item.fileType === fileType
      );

      if (existingIndex !== -1) {
        // URL already exists - navigate to that tab instead
        console.log(`üìç URL already exists at index ${existingIndex}, navigating there`);
        navigateToHistory(existingIndex);
        return;
      }

      // New URL - always append to the end (tab bar behavior)
      browserHistory.push({
        displayUrl,
        blobUrl,
        title: title || displayUrl,
        external,
        originalUrl,
        fileType
      });
      currentHistoryIndex = browserHistory.length - 1;

      console.log('‚úÖ History updated:', {
        newHistoryLength: browserHistory.length,
        newCurrentIndex: currentHistoryIndex,
        allTitles: browserHistory.map(h => h.title || h.displayUrl)
      });

      updateBrowserUI();
      saveHistoryToStorage();
    }

    // Back button
    document.getElementById('btn-back').addEventListener('click', () => {
      if (currentHistoryIndex > 0) {
        navigateToHistory(currentHistoryIndex - 1);
      }
    });

    // Forward button
    document.getElementById('btn-forward').addEventListener('click', () => {
      if (currentHistoryIndex < browserHistory.length - 1) {
        navigateToHistory(currentHistoryIndex + 1);
      }
    });

    // Address bar navigation (Enter key)
    document.getElementById('address-bar').addEventListener('keypress', async (e) => {
      if (e.key === 'Enter') {
        const url = e.target.value.trim();
        if (!url) return;

        const status = document.getElementById('iframe-status');
        const progress = document.getElementById('iframe-progress');
        const iframe = document.getElementById('html-iframe');
        const browserNav = document.getElementById('browser-nav');
        const browserContainer = document.getElementById('browser-container');

        progress.style.display = 'none';
        progress.value = 0;

        try {
          const sdk = await connectSdk(status);
          if (!sdk) return;

          status.textContent = 'Fetching object...';
          // Check if it's a share URL or object ID
          const obj = url.startsWith('sia://')
            ? await sdk.sharedObject(url)
            : await sdk.object(url);
          const size = obj.size();

          progress.style.display = 'block';
          status.textContent = 'Downloading...';

          const downloadStart = performance.now();
          let lastProgressUpdate = 0;
          const PROGRESS_THROTTLE_MS = 100;

          const data = await sdk.downloadWithProgress(obj, (current, total) => {
            const now = performance.now();
            if (now - lastProgressUpdate >= PROGRESS_THROTTLE_MS || current === total) {
              progress.max = total;
              progress.value = current;
              status.textContent = `Downloading... ${current}/${total} slabs`;
              lastProgressUpdate = now;
            }
          });

          const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
          progress.value = progress.max;

          // Load into iframe (let browser detect content type)
          const blob = new Blob([data]);
          const blobUrl = URL.createObjectURL(blob);
          iframe.src = blobUrl;

          // Add to history
          const displayUrl = url.startsWith('sia://') ? url : `object://${url}`;
          addToHistory(displayUrl, blobUrl, displayUrl, false, url, 'html');

          status.innerHTML = `Size: ${formatSize(size)}\nLoaded in ${elapsed}s\n<span class="pass">Page loaded!</span>`;
        } catch (e) {
          status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
        }
      }
    });

    // Generic function to load content with specified MIME type
    async function loadContentAs(mimeType, typeLabel) {
      const addressBar = document.getElementById('address-bar');
      const url = addressBar.value.trim();

      if (!url) {
        const status = document.getElementById('iframe-status');
        status.innerHTML = '<span style="color:#f59e0b">‚ö†Ô∏è Enter a URL in the address bar first.</span>';
        return;
      }

      const status = document.getElementById('iframe-status');
      const progress = document.getElementById('iframe-progress');
      const iframe = document.getElementById('html-iframe');

      progress.style.display = 'none';
      progress.value = 0;

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.textContent = `Fetching ${typeLabel}...`;
        const obj = url.startsWith('sia://')
          ? await sdk.sharedObject(url)
          : await sdk.object(url);
        const size = obj.size();

        progress.style.display = 'block';
        status.textContent = 'Downloading...';

        const downloadStart = performance.now();
        let lastProgressUpdate = 0;
        const PROGRESS_THROTTLE_MS = 100;

        const data = await sdk.downloadWithProgress(obj, (current, total) => {
          const now = performance.now();
          if (now - lastProgressUpdate >= PROGRESS_THROTTLE_MS || current === total) {
            progress.max = total;
            progress.value = current;
            status.textContent = `Downloading... ${current}/${total} slabs`;
            lastProgressUpdate = now;
          }
        });

        const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
        progress.value = progress.max;

        // Load into iframe with specified MIME type
        const blob = new Blob([data], { type: mimeType });
        const blobUrl = URL.createObjectURL(blob);
        iframe.src = blobUrl;

        // Add to history
        const displayUrl = `${typeLabel}: ${url}`;
        const fileType = typeLabel.toLowerCase();
        addToHistory(displayUrl, blobUrl, displayUrl, false, url, fileType);

        status.innerHTML = `Size: ${formatSize(size)}\nLoaded in ${elapsed}s\n<span class="pass">${typeLabel} loaded!</span>`;
      } catch (e) {
        status.innerHTML = `<span class="fail">Error: ${e.message}</span>`;
      }
    }

    // PDF loader - opens in new tab (Chrome blocks PDFs in sandboxed iframes)
    async function loadPdfInNewTab() {
      const addressBar = document.getElementById('address-bar');
      const url = addressBar.value.trim();

      if (!url) {
        const status = document.getElementById('iframe-status');
        status.innerHTML = '<span style="color:#f59e0b">‚ö†Ô∏è Enter a URL in the address bar first.</span>';
        return;
      }

      const status = document.getElementById('iframe-status');
      const progress = document.getElementById('iframe-progress');

      progress.style.display = 'none';
      progress.value = 0;

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.textContent = 'Fetching PDF...';
        const obj = url.startsWith('sia://')
          ? await sdk.sharedObject(url)
          : await sdk.object(url);
        const size = obj.size();

        progress.style.display = 'block';
        status.textContent = 'Downloading...';

        const downloadStart = performance.now();
        let lastProgressUpdate = 0;
        const PROGRESS_THROTTLE_MS = 100;

        const data = await sdk.downloadWithProgress(obj, (current, total) => {
          const now = performance.now();
          if (now - lastProgressUpdate >= PROGRESS_THROTTLE_MS || current === total) {
            progress.max = total;
            progress.value = current;
            status.textContent = `Downloading PDF... ${current}/${total} slabs`;
            lastProgressUpdate = now;
          }
        });

        const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
        progress.value = progress.max;

        // Open PDF in new tab
        const blob = new Blob([data], { type: 'application/pdf' });
        const blobUrl = URL.createObjectURL(blob);
        window.open(blobUrl, '_blank');

        // Add to history with external flag (PDFs open in new tabs)
        const displayUrl = `PDF: ${url}`;
        addToHistory(displayUrl, blobUrl, displayUrl, true, url, 'pdf');

        status.innerHTML = `Size: ${formatSize(size)}\nLoaded in ${elapsed}s\n<span class="pass">PDF opened in new tab!</span>`;
      } catch (e) {
        status.innerHTML = `<span class="fail">Error: ${e.message}</span>`;
      }
    }

    // File type buttons
    document.getElementById('btn-load-html').addEventListener('click', () => loadContentAs('text/html', 'HTML'));
    document.getElementById('btn-load-pdf').addEventListener('click', loadPdfInNewTab);
    document.getElementById('btn-load-image').addEventListener('click', () => loadContentAs('image/jpeg', 'Image'));
    document.getElementById('btn-load-video').addEventListener('click', () => loadContentAs('video/mp4', 'Video'));

    // Open in external tab (with warning)
    document.getElementById('btn-external-tab').addEventListener('click', async () => {
      // Show warning first
      const confirmed = confirm('‚ö†Ô∏è WARNING: This will allow the downloaded page to execute JavaScript!\n\nOpening content in an external tab removes all sandbox protections. Only proceed if you trust the content.\n\nUse the regular "New Tab" button for safer viewing, or view inside the iframe viewer if the content is untrusted.');

      if (!confirmed) return;

      // Check if there's a URL in the address bar
      const addressBar = document.getElementById('address-bar');
      const url = addressBar.value.trim();

      if (!url) {
        const status = document.getElementById('iframe-status');
        status.innerHTML = '<span style="color:#f59e0b">‚ö†Ô∏è Enter a URL in the address bar first.</span>';
        return;
      }

      // Download and open in new tab
      const status = document.getElementById('iframe-status');
      const progress = document.getElementById('iframe-progress');

      progress.style.display = 'none';
      progress.value = 0;

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.textContent = 'Downloading for external tab...';
        const obj = url.startsWith('sia://')
          ? await sdk.sharedObject(url)
          : await sdk.object(url);

        progress.style.display = 'block';
        const data = await sdk.downloadWithProgress(obj, (current, total) => {
          progress.max = total;
          progress.value = current;
          status.textContent = `Downloading... ${current}/${total} slabs`;
        });

        progress.value = progress.max;

        // Open in external tab with HTML content type
        const blob = new Blob([data], { type: 'text/html' });
        const blobUrl = URL.createObjectURL(blob);
        window.open(blobUrl, '_blank');

        // Add to history with external flag
        const displayUrl = `External: ${url}`;
        addToHistory(displayUrl, blobUrl, displayUrl, true, url, 'external');

        status.innerHTML = '<span class="pass">‚úì Opened in external tab!</span>';
      } catch (e) {
        status.innerHTML = `<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // Listen for messages from iframe (e.g., from example.html buttons)
    window.addEventListener('message', async (event) => {
      const { type, url, title } = event.data;

      if (type === 'LOAD_IN_VIEWER') {
        // Load the share URL in the iframe viewer
        const status = document.getElementById('iframe-status');
        const progress = document.getElementById('iframe-progress');
        const iframe = document.getElementById('html-iframe');
        const browserNav = document.getElementById('browser-nav');
        const browserContainer = document.getElementById('browser-container');

        progress.style.display = 'none';
        progress.value = 0;

        try {
          const sdk = await connectSdk(status);
          if (!sdk) return;

          status.textContent = `Loading ${title || 'file'}...`;
          const obj = await sdk.sharedObject(url);
          const size = obj.size();

          progress.style.display = 'block';
          status.textContent = 'Downloading...';

          const downloadStart = performance.now();
          let lastProgressUpdate = 0;
          const PROGRESS_THROTTLE_MS = 100;

          const data = await sdk.downloadWithProgress(obj, (current, total) => {
            const now = performance.now();
            if (now - lastProgressUpdate >= PROGRESS_THROTTLE_MS || current === total) {
              progress.max = total;
              progress.value = current;
              status.textContent = `Downloading... ${current}/${total} slabs`;
              lastProgressUpdate = now;
            }
          });

          const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
          progress.value = progress.max;

          // Load into iframe (let browser detect content type)
          const blob = new Blob([data]);
          const blobUrl = URL.createObjectURL(blob);
          iframe.src = blobUrl;

          // Add to history
          const displayUrl = title || url;
          addToHistory(displayUrl, blobUrl, title, false, url, 'html');

          status.innerHTML = `Size: ${formatSize(size)}\nLoaded in ${elapsed}s\n<span class="pass">${title || 'File'} loaded!</span>`;
        } catch (e) {
          status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
        }
      } else if (type === 'LOAD_IN_NEW_TAB') {
        // Download and open in new tab
        const status = document.getElementById('iframe-status');
        const progress = document.getElementById('iframe-progress');

        progress.style.display = 'none';
        progress.value = 0;

        try {
          const sdk = await connectSdk(status);
          if (!sdk) return;

          status.textContent = `Downloading ${title || 'file'}...`;
          const obj = await sdk.sharedObject(url);
          const size = obj.size();

          progress.style.display = 'block';
          status.textContent = 'Downloading...';

          const downloadStart = performance.now();
          let lastProgressUpdate = 0;
          const PROGRESS_THROTTLE_MS = 100;

          const data = await sdk.downloadWithProgress(obj, (current, total) => {
            const now = performance.now();
            if (now - lastProgressUpdate >= PROGRESS_THROTTLE_MS || current === total) {
              progress.max = total;
              progress.value = current;
              status.textContent = `Downloading... ${current}/${total} slabs`;
              lastProgressUpdate = now;
            }
          });

          const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
          progress.value = progress.max;

          // Open in new tab (let browser detect content type)
          const blob = new Blob([data]);
          const blobUrl = URL.createObjectURL(blob);
          window.open(blobUrl, '_blank');

          status.innerHTML = `Size: ${formatSize(size)}\nDownloaded in ${elapsed}s\n<span class="pass">${title || 'File'} opened in new tab!</span>`;

          // Clean up blob URL after a delay
          setTimeout(() => URL.revokeObjectURL(blobUrl), 1000);
        } catch (e) {
          status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
        }
      }
    });

  </script>
</body>
</html>
