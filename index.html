<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>indexd WASM Demo</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      padding: 2rem;
      max-width: 800px;
      margin: 0 auto;
    }

    h1 {
      font-size: 1.5rem;
      margin-bottom: 1.5rem;
      color: #fff;
    }

    h2 {
      font-size: 1.1rem;
      margin-bottom: 0.75rem;
      color: #b0b0b0;
    }

    section {
      background: #151515;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 1.25rem;
      margin-bottom: 1.25rem;
    }

    button {
      background: #1a6b3c;
      color: #fff;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
    }

    button:hover {
      background: #1f8148;
    }

    button:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
    }

    input,
    textarea {
      background: #1a1a1a;
      color: #e0e0e0;
      border: 1px solid #333;
      border-radius: 4px;
      padding: 0.5rem;
      width: 100%;
      font-family: monospace;
      font-size: 0.8rem;
    }

    textarea {
      resize: vertical;
      min-height: 3rem;
    }

    .row {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .output {
      background: #0d0d0d;
      border: 1px solid #222;
      border-radius: 4px;
      padding: 0.75rem;
      margin-top: 0.75rem;
      font-family: monospace;
      font-size: 0.8rem;
      white-space: pre-wrap;
      word-break: break-all;
      min-height: 2rem;
    }

    .label {
      font-size: 0.75rem;
      color: #888;
      margin-bottom: 0.25rem;
    }

    .pass {
      color: #4ade80;
    }

    .fail {
      color: #f87171;
    }

    #loading {
      text-align: center;
      padding: 2rem;
      color: #888;
    }

    #app {
      display: none;
    }

    .info-tip {
      position: relative;
      cursor: help;
      color: #666;
      font-size: 0.75rem;
    }

    .info-tip:hover {
      color: #999;
    }

    .info-tip .info-tip-text {
      display: none;
      position: absolute;
      bottom: calc(100% + 6px);
      left: 50%;
      transform: translateX(-50%);
      background: #1a1a1a;
      color: #e0e0e0;
      font-size: 0.75rem;
      line-height: 1.4;
      padding: 0.5rem 0.65rem;
      border-radius: 4px;
      border: 1px solid #444;
      width: 220px;
      white-space: normal;
      z-index: 100;
      pointer-events: none;
    }

    .info-tip:hover .info-tip-text {
      display: block;
    }

    .dropzone {
      border: 2px dashed #333;
      border-radius: 8px;
      padding: 2rem;
      text-align: center;
      color: #666;
      cursor: pointer;
      transition: border-color 0.2s, color 0.2s;
    }

    .dropzone:hover,
    .dropzone.dragover {
      border-color: #1a6b3c;
      color: #4ade80;
    }

    .dropzone .file-info {
      color: #e0e0e0;
      font-size: 0.85rem;
      margin-top: 0.5rem;
    }

    hr {
      border: none;
      border-top: 1px solid #2a2a2a;
      margin: 1rem 0;
    }

    progress {
      width: 100%;
      height: 8px;
      appearance: none;
      border: none;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 0.5rem;
    }

    progress::-webkit-progress-bar {
      background: #1a1a1a;
      border-radius: 4px;
    }

    progress::-webkit-progress-value {
      background: #1a6b3c;
      border-radius: 4px;
    }

    progress::-moz-progress-bar {
      background: #1a6b3c;
      border-radius: 4px;
    }

    /* Browser Navigation Controls */
    .browser-nav {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 1rem;
      padding: 0.5rem;
      background: #0d0d0d;
      border: 1px solid #222;
      border-radius: 4px;
    }

    .browser-nav-row {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .browser-nav button {
      padding: 0.4rem 0.75rem;
      font-size: 0.8rem;
      min-width: auto;
    }

    .browser-nav .address-bar {
      flex: 1;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 4px;
      padding: 0.4rem 0.6rem;
      font-family: monospace;
      font-size: 0.75rem;
      color: #ddd;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .browser-nav .address-bar:focus {
      outline: none;
      border-color: #667eea;
      background: #222;
    }

    .browser-container {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
    }

    .browser-main {
      flex: 1;
      min-width: 0;
    }

    .browser-history {
      width: 200px;
      background: #0d0d0d;
      border: 1px solid #222;
      border-radius: 4px;
      padding: 0.75rem;
      max-height: 600px;
      overflow-y: auto;
    }

    .browser-history h3 {
      font-size: 0.85rem;
      color: #b0b0b0;
      margin-bottom: 0.5rem;
    }

    .history-item {
      font-size: 0.75rem;
      padding: 0.4rem;
      margin-bottom: 0.25rem;
      background: #151515;
      border: 1px solid #2a2a2a;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .history-item:hover {
      background: #1a1a1a;
    }

    .history-item.active {
      background: #1a6b3c;
      border-color: #1f8148;
    }

    .history-item.downloaded {
      background: #0d3d20;
      border-color: #1a6b3c;
    }

    .history-item.downloaded:hover {
      background: #114d28;
    }

    .history-item.active.downloaded {
      background: #1a6b3c;
      border-color: #1f8148;
    }

    .history-title {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1;
      cursor: pointer;
    }

    .history-delete {
      flex-shrink: 0;
    }

    /* Volume slider: custom styling so thumb visually spans the full track.
       The input is widened by thumb-width (12px) with negative margins so the
       thumb center can reach both edges of the visible 80px track. */
    .vc-vol-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 92px;
      height: 20px;
      background: transparent;
      outline: none;
      cursor: pointer;
      margin: 0 -2px;
    }
    .vc-vol-slider::-webkit-slider-runnable-track {
      height: 4px;
      background: rgba(255,255,255,0.3);
      border-radius: 9999px;
    }
    .vc-vol-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #10b981;
      cursor: pointer;
      margin-top: -4px;
    }
    .vc-vol-slider::-moz-range-track {
      height: 4px;
      background: rgba(255,255,255,0.3);
      border-radius: 9999px;
    }
    .vc-vol-slider::-moz-range-thumb {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #10b981;
      border: none;
      cursor: pointer;
    }

    /* Seek bar */
    #vc-seekbar {
      flex: 1;
      height: 20px;
      display: flex;
      align-items: center;
      cursor: pointer;
      position: relative;
    }
    #vc-seek-track {
      width: 100%;
      height: 4px;
      background: rgba(255,255,255,0.15);
      border-radius: 2px;
      position: relative;
      overflow: visible;
      transition: height 0.15s;
    }
    #vc-seekbar:hover #vc-seek-track {
      height: 6px;
    }
    #vc-seek-buffered {
      position: absolute;
      top: 0; left: 0;
      height: 100%;
      background: rgba(255,255,255,0.25);
      border-radius: 2px;
      width: 0%;
    }
    #vc-seek-played {
      position: absolute;
      top: 0; left: 0;
      height: 100%;
      background: #10b981;
      border-radius: 2px;
      width: 0%;
    }
    #vc-seek-thumb {
      position: absolute;
      top: 50%;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #10b981;
      transform: translate(-50%, -50%);
      left: 0%;
      opacity: 0;
      transition: opacity 0.15s;
    }
    #vc-seekbar:hover #vc-seek-thumb {
      opacity: 1;
    }
  </style>
</head>

<body>
  <h1>indexd WASM Demo</h1>

  <div id="loading">Loading WASM module...</div>

  <div id="app">
    <!-- Configuration -->
    <section>
      <h2>Configuration</h2>
      <div class="label">Indexer URL</div>
      <input id="cfg-url" type="text" placeholder="https://indexer.example.com" style="margin-bottom:0.5rem" />
      <div class="label">App Key (hex seed)</div>
      <input id="cfg-key" type="text" placeholder="e.g. ab12cd34..." style="margin-bottom:0.5rem" />
      <hr />
      <div class="label" style="cursor:pointer; user-select:none;" id="performance-toggle">
        <span id="performance-arrow" style="display:inline-block; transition:transform 0.2s;">‚ñ∂</span> Performance
      </div>
      <div id="performance-section" style="display:none;">
        <div style="display:flex; gap:0.5rem; margin-bottom:0.75rem; margin-top:0.5rem;">
          <button id="preset-conservative"
            style="flex:1; padding:0.6rem; background:#10b981; color:white; border:none; border-radius:4px; cursor:pointer; font-size:0.85rem;">
            üê¢ Conservative<br><span style="font-size:0.7rem; opacity:0.9;">Most Stable</span>
          </button>
          <button id="preset-balanced"
            style="flex:1; padding:0.6rem; background:#3b82f6; color:white; border:none; border-radius:4px; cursor:pointer; font-size:0.85rem;">
            ‚öñÔ∏è Balanced<br><span style="font-size:0.7rem; opacity:0.9;">Recommended</span>
          </button>
          <button id="preset-fast"
            style="flex:1; padding:0.6rem; background:#f59e0b; color:white; border:none; border-radius:4px; cursor:pointer; font-size:0.85rem;">
            üöÄ Fast<br><span style="font-size:0.7rem; opacity:0.9;">May Be Unstable</span>
          </button>
        </div>
        <div class="label" style="margin-top:0.5rem;">Performance</div>
        <div
          style="display:grid; grid-template-columns: 2fr 1fr; gap:0.5rem; align-items:center; margin-bottom:0.5rem;">
          <label style="font-size:0.85rem; color:#999;">Max Downloads: <span class="info-tip">&#9432;<span class="info-tip-text">Maximum concurrent sector downloads per worker. Higher values increase throughput but use more connections.</span></span></label>
          <input id="cfg-max-downloads" type="number" min="1" value="8"
            style="padding:0.4rem; text-align:center;" />
          <label style="font-size:0.85rem; color:#999;">Max Uploads: <span class="info-tip">&#9432;<span class="info-tip-text">Maximum concurrent sector uploads per worker. Higher values increase throughput but use more connections.</span></span></label>
          <input id="cfg-max-uploads" type="number" min="1" value="8"
            style="padding:0.4rem; text-align:center;" />
          <label style="font-size:0.85rem; color:#999;">Download Workers: <span class="info-tip">&#9432;<span class="info-tip-text">Number of Web Workers for parallel slab downloads. More workers allow multiple slabs to download simultaneously, improving speed for large files.</span></span></label>
          <input id="cfg-download-workers" type="number" min="1" value="8"
            style="padding:0.4rem; text-align:center;" />
          <label style="font-size:0.85rem; color:#999;">Upload Workers: <span class="info-tip">&#9432;<span class="info-tip-text">Number of Web Workers for parallel slab uploads. More workers allow multiple slabs to upload simultaneously, improving speed for large files.</span></span></label>
          <input id="cfg-upload-workers" type="number" min="1" value="8"
            style="padding:0.4rem; text-align:center;" />
          <label for="cfg-debug-logging" style="font-size:0.85rem; color:#999; cursor:pointer;">Debug Logging: <span class="info-tip">&#9432;<span class="info-tip-text">Enables verbose debug logging from the SDK. Output is written to the browser console (open DevTools to view).</span></span></label>
          <input id="cfg-debug-logging" type="checkbox" style="cursor:pointer; justify-self:center;" />
        </div>
      </div>
      <hr />
      <div class="label">Recovery Phrase</div>
      <div class="row">
        <input id="phrase" type="text" placeholder="recovery phrase appears here" />
        <button id="btn-generate">Generate</button>
        <button id="btn-validate">Validate</button>
      </div>
      <div class="output" id="phrase-output"></div>

    </section>

    <!-- Register -->
    <section>
      <h2>Register App</h2>
      <div class="label">App Name</div>
      <input id="reg-name" type="text" placeholder="My App" style="margin-bottom:0.5rem" />
      <div class="label">App Description</div>
      <input id="reg-desc" type="text" placeholder="A brief description of your app" style="margin-bottom:0.5rem" />
      <div class="label">Service URL</div>
      <input id="reg-service-url" type="text" placeholder="https://myapp.example.com" style="margin-bottom:0.5rem" />
      <div class="row">
        <button id="btn-request-connection">1. Request Connection</button>
      </div>
      <div class="output" id="reg-status" style="display:none;"></div>
      <div id="reg-approval" style="display:none; margin-top:0.75rem;">
        <div class="label">Approve the connection by visiting the link above, then:</div>
        <div class="row">
          <button id="btn-wait-approval">2. Wait for Approval</button>
        </div>
      </div>
      <div id="reg-finalize" style="display:none; margin-top:0.75rem;">
        <div class="label">Recovery Phrase (uses the phrase from Configuration above, or enter one here)</div>
        <div class="row">
          <input id="reg-mnemonic" type="text" placeholder="leave blank to use the phrase above" />
          <button id="btn-reg-generate">Generate</button>
        </div>
        <div class="row" style="margin-top:0.5rem">
          <button id="btn-register">3. Register</button>
        </div>
      </div>
      <div class="output" id="reg-result" style="display:none; margin-top:0.75rem;"></div>
    </section>

    <!-- Account Dashboard -->
    <section id="account-dashboard">
      <h2>Account Dashboard</h2>
      <div class="row" style="margin-bottom:1rem;">
        <button id="btn-refresh-account">Load Account Data</button>
      </div>

      <!-- Storage Usage Bar -->
      <div style="margin-bottom:1.5rem;">
        <div style="display:flex; justify-content:space-between; margin-bottom:0.5rem; align-items:baseline;">
          <span style="font-weight:500;">Storage Usage</span>
          <span id="account-storage-text" style="color:#888; font-size:0.9rem;">Loading...</span>
        </div>
        <div
          style="width:100%; height:24px; background:#0a0a0a; border-radius:6px; overflow:hidden; border:1px solid #222;">
          <div id="account-storage-bar"
            style="width:0%; height:100%; background:linear-gradient(90deg, #10b981, #059669); transition:width 0.3s;">
          </div>
        </div>
        <div style="display:flex; justify-content:space-between; margin-top:0.25rem; font-size:0.85rem; color:#666;">
          <span id="account-used-label">Used: 0 GB</span>
          <span id="account-free-label">Free: 0 GB</span>
        </div>

        <!-- Prune Slabs -->
        <div style="margin-top:1rem; padding:1rem; background:#0a0a0a; border-radius:6px; border:1px solid #222;">
          <div style="display:flex; justify-content:space-between; align-items:center; gap:1rem;">
            <div style="flex:1;">
              <div style="font-weight:500; margin-bottom:0.25rem; color:#e0e0e0;">Clean Up Storage</div>
              <div style="color:#888; font-size:0.85rem;">Remove unused slabs to reclaim space</div>
            </div>
            <button id="btn-prune-slabs"
              style="padding:0.5rem 1rem; background:#8b5cf6; color:white; border:none; border-radius:4px; cursor:pointer; white-space:nowrap; font-size:0.9rem; font-weight:500;">
              üßπ Prune Slabs
            </button>
          </div>
        </div>
      </div>

      <!-- Quick Stats Grid -->
      <div
        style="display:grid; grid-template-columns:repeat(auto-fit, minmax(150px, 1fr)); gap:1rem; margin-bottom:1.5rem;">
        <div style="background:#0a0a0a; padding:1.25rem; border-radius:6px; border:1px solid #222;">
          <div style="color:#888; font-size:0.85rem; margin-bottom:0.5rem;">Objects Stored</div>
          <div id="account-objects-count" style="font-size:1.75rem; font-weight:600; color:#10b981;">-</div>
        </div>
        <div style="background:#0a0a0a; padding:1.25rem; border-radius:6px; border:1px solid #222;">
          <div style="color:#888; font-size:0.85rem; margin-bottom:0.5rem;">Pinned Data</div>
          <div id="account-pinned-data" style="font-size:1.75rem; font-weight:600; color:#3b82f6;">-</div>
        </div>
        <div style="background:#0a0a0a; padding:1.25rem; border-radius:6px; border:1px solid #222;">
          <div style="color:#888; font-size:0.85rem; margin-bottom:0.5rem;">Capacity</div>
          <div id="account-capacity-percent" style="font-size:1.75rem; font-weight:600; color:#8b5cf6;">-</div>
        </div>
      </div>

      <!-- Account Details -->
      <div style="background:#0a0a0a; padding:1.25rem; border-radius:6px; border:1px solid #222;">
        <h3 style="margin:0 0 1rem 0; font-size:1rem; color:#e0e0e0;">Account Details</h3>
        <div style="display:grid; gap:0.75rem; font-size:0.9rem;">
          <div style="display:flex; justify-content:space-between;">
            <span style="color:#888;">App Name:</span>
            <span id="account-app-name" style="color:#e0e0e0; font-family:monospace;">-</span>
          </div>
          <div style="display:flex; justify-content:space-between;">
            <span style="color:#888;">Account Key:</span>
            <span id="account-key" style="color:#e0e0e0; font-family:monospace; font-size:0.8rem;" title="">-</span>
          </div>
          <div style="display:flex; justify-content:space-between;">
            <span style="color:#888;">Last Used:</span>
            <span id="account-last-used" style="color:#e0e0e0;">-</span>
          </div>
          <div style="display:flex; justify-content:space-between;">
            <span style="color:#888;">Storage Limit:</span>
            <span id="account-max-storage" style="color:#e0e0e0;">-</span>
          </div>
        </div>
      </div>

      <div class="output" id="account-status" style="margin-top:1rem;"></div>
    </section>

    <!-- CORS Diagnostics -->
    <section>
      <h2>üîß CORS Diagnostics</h2>
      <p style="color:#888; font-size:0.9rem; margin-bottom:1rem;">
        Sends an OPTIONS preflight request to every API endpoint. The last two auth UI routes intentionally
        have CORS disabled.
      </p>
      <button id="btn-cors-run-all"
        style="width:100%; padding:0.6rem; background:#3b82f6; color:white; border:none; border-radius:4px; cursor:pointer; margin-bottom:1rem;">
        Run All CORS Tests
      </button>
      <div id="cors-results" style="font-size:0.85rem;"></div>
    </section>


    <!-- Upload Text -->
    <section>
      <h2>Upload Text</h2>
      <div class="label">Text to upload</div>
      <textarea id="ul-text" rows="4" placeholder="Type or paste text here..."></textarea>
      <div class="row" style="margin-top:0.5rem">
        <button id="btn-upload-text-workers">Upload ( web workers )</button>
        <button id="btn-upload">Upload ( single-threaded )</button>
      </div>
      <progress id="ul-progress" max="100" value="0" style="display:none"></progress>
      <div class="output" id="ul-status"></div>
    </section>

    <!-- Upload File -->
    <section>
      <h2>Upload File</h2>
      <div class="dropzone" id="uf-dropzone">
        Drop a file here or click to select
        <input type="file" id="uf-file" style="display:none" />
        <div class="file-info" id="uf-file-info"></div>
      </div>
      <div class="row" style="margin-top:0.5rem">
        <button id="btn-upload-file">Upload ( web workers )</button>
        <button id="btn-upload-file-simple">Upload ( single-threaded )</button>
      </div>
      <progress id="uf-progress" max="100" value="0" style="display:none"></progress>
      <div class="output" id="uf-status"></div>
    </section>


    <!-- Download File -->
    <section>
      <h2>Download File</h2>
      <div class="label">Object ID or Share URL</div>
      <input id="dl-url" type="text" placeholder="Paste sia:// URL or object ID (hex)" style="margin-bottom:0.5rem" />
      <div class="label">Filename</div>
      <div class="row">
        <input id="dl-filename" type="text" placeholder="e.g. photo.jpg" />
        <button id="btn-download">Download</button>
      </div>
      <progress id="dl-progress" max="100" value="0" style="display:none"></progress>
      <div class="output" id="dl-status"></div>
    </section>

    <!-- List Objects -->
    <section>
      <h2>My Objects</h2>
      <div class="row">
        <button id="btn-list-objects">Refresh List</button>
        <input id="list-limit" type="number" value="50" min="1" max="1000" style="width:5rem" placeholder="Limit" />
      </div>
      <div class="output" id="list-status"></div>
      <div id="objects-list" style="margin-top:1rem; max-height:400px; overflow-y:auto;">
        <!-- Objects will be displayed here -->
      </div>
    </section>

    <!-- Share Object -->
    <section>
      <h2>Share Object</h2>
      <div class="label">Object ID (hex)</div>
      <input id="share-object-id" type="text" placeholder="e.g. 0e90d697f504..." style="margin-bottom:0.5rem" />
      <div class="label">Expires in</div>
      <div class="row">
        <input id="share-duration" type="number" value="24" min="1" style="width:5rem" />
        <select id="share-unit"
          style="background:#1a1a1a; color:#e0e0e0; border:1px solid #333; border-radius:4px; padding:0.5rem;">
          <option value="3600000">hours</option>
          <option value="86400000" selected>days</option>
          <option value="604800000">weeks</option>
        </select>
        <button id="btn-share">Generate Link</button>
      </div>
      <div class="output" id="share-status"></div>
    </section>

    <!-- HTML Viewer (Decentralized Browser) -->
    <section>
      <h2>üåê Decentralized Browser</h2>

      <!-- Browser Navigation Controls -->
      <div class="browser-nav" id="browser-nav">
        <div class="browser-nav-row">
          <input type="text" class="address-bar" id="address-bar" placeholder="Paste Sia share URL or object ID..."
            title="Press Enter or click Go to auto-detect file type" style="flex:1;">
          <button id="btn-go" title="Auto-detect file type and load content"
            style="background:#10b981; border-color:#10b981; font-weight:bold; padding:0.5rem 2rem;">Go</button>
        </div>
        <div class="browser-nav-row" style="justify-content:flex-start; gap:0.5rem;">
          <button id="btn-external-tab"
            title="‚ö†Ô∏è Opens in new tab with JavaScript enabled - use only for trusted content"
            style="background:#f59e0b; border-color:#f59e0b; font-size:0.85rem; padding:0.4rem 0.8rem;">‚ö†Ô∏è Open in
            External Tab</button>
          <span style="color:#888; font-size:0.8rem; font-style:italic;">Warning: External tab allows JavaScript
            execution</span>
        </div>
      </div>

      <progress id="iframe-progress" max="100" value="0" style="display:none; margin-top:1rem"></progress>
      <div class="output" id="iframe-status"></div>

      <!-- Browser Container with Iframe and History -->
      <div class="browser-container" id="browser-container">
        <div class="browser-main">
          <iframe id="html-iframe"
            style="width:100%; height:600px; border:1px solid #333; border-radius:4px; background:white;"
            sandbox="allow-same-origin"></iframe>
          <!-- WebCodecs Video Player (outside sandboxed iframe) -->
          <div id="video-container"
            style="display:none; width:100%; height:600px; border:1px solid #333; border-radius:4px; background:#0a0a0a; box-sizing:border-box; position:relative; overflow:hidden;">
            <canvas id="stream-canvas" style="width:100%; height:100%; object-fit:contain; background:#000; display:block; cursor:pointer;"></canvas>
            <!-- Minimal controls overlay -->
            <div id="video-controls" style="position:absolute; bottom:0; left:0; right:0; padding:8px 12px; background:linear-gradient(transparent, rgba(0,0,0,0.8)); display:flex; align-items:center; gap:10px; opacity:0; transition:opacity 0.3s;">
              <button id="vc-playpause" style="background:none; border:none; color:#fff; font-size:18px; cursor:pointer; padding:4px 8px;">&#9654;</button>
              <span id="vc-time" style="color:#ccc; font-size:12px; font-family:monospace; min-width:60px;">0:00</span>
              <div id="vc-seekbar">
                <div id="vc-seek-track">
                  <div id="vc-seek-buffered"></div>
                  <div id="vc-seek-played"></div>
                  <div id="vc-seek-thumb"></div>
                </div>
              </div>
              <input id="vc-volume" type="range" min="0" max="1" step="0.01" value="1" class="vc-vol-slider">
              <button id="vc-fullscreen" style="background:none; border:none; color:#fff; font-size:16px; cursor:pointer; padding:4px 8px;">&#x26F6;</button>
            </div>
            <!-- MSE fallback video (hidden, used only when WebCodecs unavailable) -->
            <video id="mse-video" controls controlsList="nodownload" autoplay style="width:100%; height:100%; background:#000; display:none;"></video>
          </div>
        </div>
        <div class="browser-history">
          <h3>üìú History</h3>
          <div id="history-list"></div>
        </div>
      </div>
    </section>

  </div>

  <script type="module">
    import init, {
      generateRecoveryPhrase,
      validateRecoveryPhrase,
      AppKey,
      Builder,
      UploadOptions,
      DownloadOptions,
      setLogLevel,
    } from './pkg/indexd_wasm.js';

    // Import file-type for MIME detection
    import { fileTypeFromBlob } from './vendor/file-type.bundle.js';

    // Import mp4box for MP4 demuxing (WebCodecs video streaming)
    import { createFile as createMP4Box, DataStream, Endianness } from './vendor/mp4box.bundle.js';

    // Check browser compatibility on page load
    window.addEventListener('DOMContentLoaded', () => {
      console.log('üåê Browser compatibility check:');
      console.log('  WebTransport:', typeof WebTransport !== 'undefined' ? '‚úÖ Available' : '‚ùå Not available');
      console.log('  Secure context:', window.isSecureContext ? '‚úÖ Yes' : '‚ùå No (requires HTTPS)');
      console.log('  Browser:', navigator.userAgent);

      if (typeof WebTransport === 'undefined') {
        const warning = document.createElement('div');
        warning.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#dc2626;color:white;padding:1rem;text-align:center;z-index:9999;font-weight:bold;';
        warning.innerHTML = '‚ö†Ô∏è WebTransport not supported in this browser. Downloads will fail.<br>Please use Chrome 97+, Edge 97+, or check Safari Feature Flags (Develop ‚Üí Feature Flags ‚Üí WebTransport)';
        document.body.prepend(warning);
      } else if (!window.isSecureContext) {
        const warning = document.createElement('div');
        warning.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#dc2626;color:white;padding:1rem;text-align:center;z-index:9999;font-weight:bold;';
        warning.innerHTML = '‚ö†Ô∏è Page must be served over HTTPS for WebTransport to work. Use https://localhost or deploy to HTTPS server.';
        document.body.prepend(warning);
      }
    });

    function hex(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function randomHex(len) {
      const arr = new Uint8Array(len);
      crypto.getRandomValues(arr);
      return hex(arr);
    }

    function fromHex(h) {
      const bytes = new Uint8Array(h.length / 2);
      for (let i = 0; i < bytes.length; i++) {
        bytes[i] = parseInt(h.substr(i * 2, 2), 16);
      }
      return bytes;
    }

    function formatSize(bytes) {
      if (bytes < 1e3) return bytes + ' B';
      if (bytes < 1e6) return (bytes / 1e3).toFixed(1) + ' KB';
      if (bytes < 1e9) return (bytes / 1e6).toFixed(1) + ' MB';
      if (bytes < 1e12) return (bytes / 1e9).toFixed(2) + ' GB';
      return (bytes / 1e12).toFixed(2) + ' TB';
    }

    // Streaming download helper ‚Äî avoids holding the entire file in WASM memory.
    // Returns { blob, elapsed } where blob is assembled from streamed chunks.
    async function streamingDownload(sdk, obj, status, progress, label) {
      progress.style.display = 'block';
      status.textContent = label || 'Downloading...';

      const downloadStart = performance.now();
      let lastProgressUpdate = 0;
      const PROGRESS_THROTTLE_MS = 100;

      const blobParts = [];
      const dlOpts = new DownloadOptions();
      dlOpts.maxInflight = getMaxDownloads();
      await sdk.downloadStreaming(obj, dlOpts,
        (chunk) => { blobParts.push(chunk); },
        (current, total) => {
          const now = performance.now();
          if (now - lastProgressUpdate >= PROGRESS_THROTTLE_MS || current === total) {
            progress.max = total;
            progress.value = current;
            status.textContent = `${label || 'Downloading'}... ${current}/${total} slabs`;
            lastProgressUpdate = now;
          }
        },
      );

      const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
      progress.value = progress.max;
      return { blob: new Blob(blobParts), elapsed };
    }

    // Parallel slab download ‚Äî spawns a pool of Web Workers, each with its own
    // SDK instance and thread, to download slabs in true parallelism.
    // Falls back to streamingDownload for files with <= 2 slabs.
    async function parallelDownload(objectUrl, status, progress, label, numWorkers) {
      numWorkers = numWorkers || getDownloadWorkers();
      progress.style.display = 'block';

      // 1. Get metadata on main thread (uses cached SDK ‚Äî instant)
      const sdk = await connectSdk(status);
      if (!sdk) return null;

      status.textContent = 'Fetching object metadata...';
      const obj = objectUrl.startsWith('sia://')
        ? await sdk.sharedObject(objectUrl)
        : await sdk.object(objectUrl);
      const slabCount = obj.slabCount();
      const totalSize = obj.size();

      // For tiny files, fall back to single-threaded download (worker overhead > benefit)
      if (slabCount <= 2) {
        return streamingDownload(sdk, obj, status, progress, label);
      }

      // 2. Spawn worker pool
      const actualWorkers = numWorkers;

      const config = {
        type: 'init',
        indexerUrl: getUrl(),
        keyHex: getKeyHex(),
        maxDownloads: getMaxDownloads(),
        objectUrl,
        logLevel: getLogLevel(),
      };

      status.textContent = `Connecting ${actualWorkers} download workers...`;
      const workers = [];
      const readyPromises = [];

      for (let i = 0; i < actualWorkers; i++) {
        const w = new Worker('./slab-download-worker.js', { type: 'module' });
        const ready = new Promise((resolve, reject) => {
          const handler = (e) => {
            if (e.data.type === 'ready') { w.removeEventListener('message', handler); resolve(); }
            if (e.data.type === 'error') { w.removeEventListener('message', handler); reject(new Error(e.data.message)); }
          };
          w.addEventListener('message', handler);
        });
        w.postMessage(config);
        workers.push(w);
        readyPromises.push(ready);
      }

      await Promise.all(readyPromises);

      // 3. Assign slabs to workers round-robin and collect results in order
      const downloadStart = performance.now();
      const slabData = new Array(slabCount); // ordered results
      let nextSlab = 0;
      let completedSlabs = 0;

      return new Promise((resolve, reject) => {
        let rejected = false;

        function assignWork(worker) {
          if (nextSlab >= slabCount || rejected) return;
          const idx = nextSlab++;
          worker.postMessage({ type: 'download-slab', slabIndex: idx });
        }

        for (const w of workers) {
          w.onmessage = (e) => {
            if (rejected) return;

            if (e.data.type === 'slab-data') {
              slabData[e.data.slabIndex] = e.data.data;
              completedSlabs++;
              progress.max = slabCount;
              progress.value = completedSlabs;
              status.textContent = `${label || 'Downloading'}... ${completedSlabs}/${slabCount} slabs (${actualWorkers} workers)`;

              if (completedSlabs === slabCount) {
                workers.forEach(w => w.terminate());
                const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
                progress.value = progress.max;
                resolve({ blob: new Blob(slabData), elapsed, size: totalSize });
              } else {
                assignWork(w);
              }
            }

            if (e.data.type === 'slab-error') {
              rejected = true;
              workers.forEach(w => w.terminate());
              reject(new Error(`Slab ${e.data.slabIndex}: ${e.data.message}`));
            }
          };
          // Assign initial work
          assignWork(w);
        }
      });
    }

    // Parallel slab download to disk via File System Access API.
    // Writes slabs to a FileSystemWritableStream in order as they complete.
    async function parallelDownloadToDisk(objectUrl, writable, status, progress, bytesCallback, numWorkers) {
      numWorkers = numWorkers || getDownloadWorkers();

      // Fetch object metadata on main thread (for slab count)
      const sdk = await connectSdk(status);
      if (!sdk) return null;

      const obj = objectUrl.startsWith('sia://')
        ? await sdk.sharedObject(objectUrl)
        : await sdk.object(objectUrl);
      const slabCount = obj.slabCount();
      const slabLengths = Array.from(obj.slabLengths());
      const totalSize = obj.size();

      const actualWorkers = numWorkers;

      const config = {
        type: 'init',
        indexerUrl: getUrl(),
        keyHex: getKeyHex(),
        maxDownloads: getMaxDownloads(),
        objectUrl,
        logLevel: getLogLevel(),
      };

      status.textContent = `Connecting ${actualWorkers} download workers...`;
      const workers = [];
      const readyPromises = [];

      for (let i = 0; i < actualWorkers; i++) {
        const w = new Worker('./slab-download-worker.js', { type: 'module' });
        const ready = new Promise((resolve, reject) => {
          const handler = (e) => {
            if (e.data.type === 'ready') { w.removeEventListener('message', handler); resolve(); }
            if (e.data.type === 'error') { w.removeEventListener('message', handler); reject(new Error(e.data.message)); }
          };
          w.addEventListener('message', handler);
        });
        w.postMessage(config);
        workers.push(w);
        readyPromises.push(ready);
      }

      await Promise.all(readyPromises);

      const downloadStart = performance.now();
      let nextSlab = 0;
      let completedSlabs = 0;
      let nextSlabToWrite = 0;
      let bytesDownloaded = 0;
      const pendingSlabs = new Map(); // slabIndex -> ArrayBuffer
      let lastWrite = Promise.resolve();

      function tryFlush() {
        while (pendingSlabs.has(nextSlabToWrite)) {
          const data = pendingSlabs.get(nextSlabToWrite);
          pendingSlabs.delete(nextSlabToWrite);
          const blob = new Blob([data]);
          lastWrite = lastWrite.then(() => writable.write(blob));
          nextSlabToWrite++;
        }
      }

      return new Promise((resolve, reject) => {
        let rejected = false;

        function assignWork(worker) {
          if (nextSlab >= slabCount || rejected) return;
          const idx = nextSlab++;
          worker.postMessage({ type: 'download-slab', slabIndex: idx });
        }

        for (const w of workers) {
          w.onmessage = (e) => {
            if (rejected) return;

            if (e.data.type === 'slab-data') {
              const idx = e.data.slabIndex;
              pendingSlabs.set(idx, e.data.data);
              completedSlabs++;
              bytesDownloaded += slabLengths[idx];
              if (bytesCallback) bytesCallback(bytesDownloaded);

              progress.max = slabCount;
              progress.value = completedSlabs;

              tryFlush();

              if (completedSlabs === slabCount) {
                lastWrite.then(() => {
                  workers.forEach(w => w.terminate());
                  const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
                  progress.value = progress.max;
                  resolve({ elapsed, size: totalSize });
                }).catch(err => {
                  workers.forEach(w => w.terminate());
                  reject(err);
                });
              } else {
                assignWork(w);
              }
            }

            if (e.data.type === 'slab-error') {
              rejected = true;
              workers.forEach(w => w.terminate());
              reject(new Error(`Slab ${e.data.slabIndex}: ${e.data.message}`));
            }
          };
          assignWork(w);
        }
      });
    }

    // ‚îÄ‚îÄ Parallel Slab Upload via Web Worker Pool ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    //
    // Splits a file into slab-sized chunks (~40 MB each), distributes them
    // to a pool of Web Workers, each with its own SDK instance, and uploads
    // slabs in parallel. Returns a PinnedObject ready to pin to the indexer.
    //
    // For small files (‚â§2 slabs) falls back to single-threaded upload.

    async function parallelUpload(file, status, progress, numWorkers) {
      numWorkers = numWorkers || getUploadWorkers();
      progress.style.display = 'block';

      // 1. Get metadata on main thread
      const sdk = await connectSdk(status);
      if (!sdk) return null;

      const fileSize = file.size;
      const SLAB_DATA_SIZE = sdk.slabDataSize(); // 10 * 4 MiB = 41,943,040
      const slabCount = fileSize === 0 ? 0 : Math.ceil(fileSize / SLAB_DATA_SIZE);

      // 2. Generate shared data key on main thread
      const dataKey = sdk.generateDataKey(); // Uint8Array(32)
      // Copy key to a plain ArrayBuffer for transfer to workers
      const dataKeyBuf = dataKey.buffer.slice(dataKey.byteOffset, dataKey.byteOffset + dataKey.byteLength);

      // 3. Spawn worker pool
      const actualWorkers = numWorkers;

      const config = {
        type: 'init',
        indexerUrl: getUrl(),
        keyHex: getKeyHex(),
        maxUploads: getMaxUploads(),
        logLevel: getLogLevel(),
      };

      status.textContent = `Connecting ${actualWorkers} upload workers...`;
      const workers = [];
      const readyPromises = [];

      for (let i = 0; i < actualWorkers; i++) {
        const w = new Worker('./slab-upload-worker.js', { type: 'module' });
        const ready = new Promise((resolve, reject) => {
          const handler = (e) => {
            if (e.data.type === 'ready') { w.removeEventListener('message', handler); resolve(); }
            if (e.data.type === 'error') { w.removeEventListener('message', handler); reject(new Error(e.data.message)); }
          };
          w.addEventListener('message', handler);
        });
        w.postMessage({ ...config, workerIndex: i, numWorkers: actualWorkers });
        workers.push(w);
        readyPromises.push(ready);
      }

      await Promise.all(readyPromises);

      // 4. Assign slabs to workers round-robin and collect results
      const uploadStart = performance.now();
      const slabJsons = new Array(slabCount);
      const totalShards = slabCount * 30;
      const slabShards = new Array(slabCount).fill(0);
      let nextSlab = 0;
      let completedSlabs = 0;

      return new Promise((resolve, reject) => {
        let rejected = false;

        function sendSlabToWorker(worker, idx) {
          const slabOffset = idx * SLAB_DATA_SIZE;
          const slabEnd = Math.min(slabOffset + SLAB_DATA_SIZE, fileSize);
          const blob = file.slice(slabOffset, slabEnd);
          blob.arrayBuffer().then((buf) => {
            worker.postMessage({
              type: 'upload-slab',
              slabIndex: idx,
              data: buf,
              dataKey: dataKeyBuf,
              streamOffset: slabOffset,
            }, [buf]);
          });
        }

        function assignWork(worker) {
          if (nextSlab >= slabCount || rejected) return;
          const idx = nextSlab++;
          sendSlabToWorker(worker, idx);
        }

        for (const w of workers) {
          w.onmessage = (e) => {
            if (rejected) return;

            if (e.data.type === 'shard-progress') {
              slabShards[e.data.slabIndex] = e.data.current;
              const shardsDone = slabShards.reduce((a, b) => a + b, 0);
              progress.max = totalShards;
              progress.value = shardsDone;
              status.textContent = `Uploading ${file.name}... ${shardsDone}/${totalShards} shards (${actualWorkers} workers)`;
            }

            if (e.data.type === 'slab-uploaded') {
              slabJsons[e.data.slabIndex] = e.data.slabJson;
              completedSlabs++;
              status.textContent = `Uploading ${file.name}... ${completedSlabs}/${slabCount} slabs (${actualWorkers} workers)`;

              if (completedSlabs === slabCount) {
                workers.forEach(w => w.terminate());

                // Assemble the object on the main thread
                try {
                  const combinedSlabs = '[' + slabJsons.join(',') + ']';
                  const obj = sdk.assembleObject(dataKey, combinedSlabs);
                  const elapsed = ((performance.now() - uploadStart) / 1000).toFixed(1);
                  progress.value = progress.max;
                  resolve({ obj, elapsed, size: fileSize });
                } catch (err) {
                  reject(err);
                }
              } else {
                assignWork(w);
              }
            }

            if (e.data.type === 'slab-error') {
              rejected = true;
              workers.forEach(w => w.terminate());
              reject(new Error(`Slab ${e.data.slabIndex}: ${e.data.message}`));
            }
          };
          assignWork(w);
        }
      });
    }

    // Auto-restore config from localStorage on page load
    const urlInput = document.getElementById('cfg-url');
    const keyInput = document.getElementById('cfg-key');
    const maxDownloadsInput = document.getElementById('cfg-max-downloads');
    const maxUploadsInput = document.getElementById('cfg-max-uploads');
    const downloadWorkersInput = document.getElementById('cfg-download-workers');
    const uploadWorkersInput = document.getElementById('cfg-upload-workers');
    const debugLoggingCheckbox = document.getElementById('cfg-debug-logging');

    const savedUrl = localStorage.getItem('indexer-url');
    const savedKey = localStorage.getItem('app-key');
    const savedMaxDownloads = localStorage.getItem('max-downloads');
    const savedMaxUploads = localStorage.getItem('max-uploads');
    const savedDownloadWorkers = localStorage.getItem('download-workers');
    const savedUploadWorkers = localStorage.getItem('upload-workers');
    const savedLogLevel = localStorage.getItem('log-level');

    if (savedUrl) urlInput.value = savedUrl;
    if (savedKey) keyInput.value = savedKey;
    if (savedMaxDownloads) maxDownloadsInput.value = savedMaxDownloads;
    if (savedMaxUploads) maxUploadsInput.value = savedMaxUploads;
    if (savedDownloadWorkers) downloadWorkersInput.value = savedDownloadWorkers;
    if (savedUploadWorkers) uploadWorkersInput.value = savedUploadWorkers;
    if (savedLogLevel === 'debug') {
      debugLoggingCheckbox.checked = true;
    }

    // Performance section toggle
    document.getElementById('performance-toggle').addEventListener('click', () => {
      const section = document.getElementById('performance-section');
      const arrow = document.getElementById('performance-arrow');
      if (section.style.display === 'none') {
        section.style.display = 'block';
        arrow.style.transform = 'rotate(90deg)';
      } else {
        section.style.display = 'none';
        arrow.style.transform = 'rotate(0deg)';
      }
    });

    // Save to localStorage when config changes
    urlInput.addEventListener('input', () => {
      localStorage.setItem('indexer-url', urlInput.value.trim());
    });
    keyInput.addEventListener('input', () => {
      localStorage.setItem('app-key', keyInput.value.trim());
    });
    maxDownloadsInput.addEventListener('input', () => {
      localStorage.setItem('max-downloads', maxDownloadsInput.value);
    });
    maxUploadsInput.addEventListener('input', () => {
      localStorage.setItem('max-uploads', maxUploadsInput.value);
    });
    downloadWorkersInput.addEventListener('input', () => {
      localStorage.setItem('download-workers', downloadWorkersInput.value);
    });
    uploadWorkersInput.addEventListener('input', () => {
      localStorage.setItem('upload-workers', uploadWorkersInput.value);
    });
    debugLoggingCheckbox.addEventListener('change', () => {
      const level = debugLoggingCheckbox.checked ? 'debug' : 'info';
      localStorage.setItem('log-level', level);
      setLogLevel(level);
    });

    // helpers to read shared config
    function getUrl() { return document.getElementById('cfg-url').value.trim(); }
    function getKeyHex() { return document.getElementById('cfg-key').value.trim(); }
    function getMaxDownloads() { return parseInt(document.getElementById('cfg-max-downloads').value) || 8; }
    function getMaxUploads() { return parseInt(document.getElementById('cfg-max-uploads').value) || 8; }
    function getDownloadWorkers() { return parseInt(document.getElementById('cfg-download-workers').value) || 8; }
    function getUploadWorkers() { return parseInt(document.getElementById('cfg-upload-workers').value) || 8; }
    function getLogLevel() { return document.getElementById('cfg-debug-logging').checked ? 'debug' : null; }

    // SDK cache to avoid recreating and re-initializing
    let cachedSdk = null;
    let cachedConfig = null;

    async function connectSdk(statusEl) {
      const url = getUrl();
      const keyHex = getKeyHex();
      if (!url || !keyHex) {
        statusEl.innerHTML = '<span class="fail">Set Indexer URL and App Key in Configuration first</span>';
        return null;
      }

      // Return cached SDK if config hasn't changed
      const currentConfig = `${url}|${keyHex}`;
      if (cachedSdk && cachedConfig === currentConfig) {
        return cachedSdk;
      }

      statusEl.textContent = 'Creating app key...';
      const seed = fromHex(keyHex);
      const appKey = new AppKey(seed);
      statusEl.textContent = `App key created. Public key: ${appKey.publicKey()}\nConnecting to indexer...`;
      const builder = new Builder(url);
      const sdk = await builder.connected(appKey);
      if (!sdk) {
        statusEl.innerHTML = '<span class="fail">App key not recognized by this indexer. Register first.</span>';
        return null;
      }

      // Cache the SDK
      cachedSdk = sdk;
      cachedConfig = currentConfig;
      statusEl.innerHTML = '<span class="pass">Connected!</span>';
      return sdk;
    }

    await init();
    console.log('[JS] WASM module initialized successfully');
    if (debugLoggingCheckbox.checked) setLogLevel('debug');
    document.getElementById('loading').style.display = 'none';
    document.getElementById('app').style.display = 'block';

    // -- Performance Presets --
    function setPreset(maxDl, maxUl, dlWorkers, ulWorkers) {
      document.getElementById('cfg-max-downloads').value = maxDl;
      document.getElementById('cfg-max-uploads').value = maxUl;
      document.getElementById('cfg-download-workers').value = dlWorkers;
      document.getElementById('cfg-upload-workers').value = ulWorkers;
      localStorage.setItem('max-downloads', maxDl);
      localStorage.setItem('max-uploads', maxUl);
      localStorage.setItem('download-workers', dlWorkers);
      localStorage.setItem('upload-workers', ulWorkers);
    }

    document.getElementById('preset-conservative').addEventListener('click', () => setPreset(4, 4, 4, 4));
    document.getElementById('preset-balanced').addEventListener('click', () => setPreset(8, 8, 8, 8));
    document.getElementById('preset-fast').addEventListener('click', () => setPreset(16, 16, 16, 16));

    // -- Recovery Phrase --
    document.getElementById('btn-generate').addEventListener('click', () => {
      const phrase = generateRecoveryPhrase();
      document.getElementById('phrase').value = phrase;
      document.getElementById('phrase-output').innerHTML = '<span class="pass">Generated successfully</span>';
    });

    document.getElementById('btn-validate').addEventListener('click', () => {
      const phrase = document.getElementById('phrase').value.trim();
      const out = document.getElementById('phrase-output');
      if (!phrase) {
        out.innerHTML = '<span class="fail">Enter a phrase first</span>';
        return;
      }
      try {
        validateRecoveryPhrase(phrase);
        out.innerHTML = '<span class="pass">Valid recovery phrase</span>';
      } catch (e) {
        out.innerHTML = `<span class="fail">Invalid: ${e.message}</span>`;
      }
    });

    // -- Register --
    let regBuilder = null;
    let regAppId = null;

    document.getElementById('btn-request-connection').addEventListener('click', async () => {
      const status = document.getElementById('reg-status');
      const approvalDiv = document.getElementById('reg-approval');
      const finalizeDiv = document.getElementById('reg-finalize');
      const resultDiv = document.getElementById('reg-result');
      const btn = document.getElementById('btn-request-connection');

      const url = getUrl();
      const name = document.getElementById('reg-name').value.trim();
      const desc = document.getElementById('reg-desc').value.trim();
      const serviceUrl = document.getElementById('reg-service-url').value.trim();

      status.style.display = 'none';
      approvalDiv.style.display = 'none';
      finalizeDiv.style.display = 'none';
      resultDiv.style.display = 'none';

      if (!url || !name || !desc || !serviceUrl) {
        status.style.display = 'block';
        status.innerHTML = '<span class="fail">Indexer URL (in Configuration) and all fields are required</span>';
        return;
      }

      try {
        btn.disabled = true;
        btn.textContent = 'Requesting connection...';
        status.style.display = 'block';
        status.textContent = 'Requesting connection from indexer...';

        regAppId = randomHex(32);
        regBuilder = new Builder(url);

        const appMetadata = JSON.stringify({
          appID: regAppId,
          name: name,
          description: desc,
          serviceURL: serviceUrl
        });

        await regBuilder.requestConnection(appMetadata);

        const responseUrl = regBuilder.responseUrl();
        status.innerHTML = `<span class="pass">‚úì Connection requested!</span>\n\nApprove this app by visiting:\n<a href="${responseUrl}" target="_blank" rel="noopener" style="color:#60a5fa; word-break:break-all;">${responseUrl}</a>`;
        approvalDiv.style.display = 'block';

        btn.textContent = '1. Request Connection';
        btn.disabled = false;
      } catch (e) {
        status.style.display = 'block';
        status.innerHTML = `<span class="fail">Failed to request connection: ${e.message}</span>`;
        btn.textContent = '1. Request Connection';
        btn.disabled = false;
      }
    });

    document.getElementById('btn-wait-approval').addEventListener('click', async () => {
      const status = document.getElementById('reg-status');
      const finalizeDiv = document.getElementById('reg-finalize');
      const btn = document.getElementById('btn-wait-approval');

      if (!regBuilder) {
        status.innerHTML += `\n<span class="fail">Complete step 1 first</span>`;
        return;
      }

      try {
        btn.disabled = true;
        btn.textContent = 'Waiting for approval...';
        status.innerHTML += '\n\nPolling for approval (this may take a while)...';

        await regBuilder.waitForApproval();

        status.innerHTML += `\n<span class="pass">Approved!</span>`;
        btn.textContent = 'Approved!';
        finalizeDiv.style.display = 'block';
      } catch (e) {
        btn.disabled = false;
        btn.textContent = '3. Wait for Approval';
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    document.getElementById('btn-reg-generate').addEventListener('click', () => {
      document.getElementById('reg-mnemonic').value = generateRecoveryPhrase();
    });

    document.getElementById('btn-register').addEventListener('click', async () => {
      const status = document.getElementById('reg-status');
      const resultDiv = document.getElementById('reg-result');
      // use register-specific mnemonic if provided, otherwise fall back to config phrase
      const mnemonic = document.getElementById('reg-mnemonic').value.trim()
        || document.getElementById('phrase').value.trim();

      if (!regBuilder) {
        status.innerHTML += `\n<span class="fail">Complete previous steps first</span>`;
        return;
      }
      if (!mnemonic) {
        status.innerHTML += `\n<span class="fail">Enter a recovery phrase in Configuration or the field above</span>`;
        return;
      }

      try {
        status.innerHTML += '\nRegistering...';
        const sdk = await regBuilder.register(mnemonic);
        const appKey = sdk.appKey();
        const seed = hex(appKey.export());
        const pubkey = appKey.publicKey();

        // auto-fill the config app key field and save to localStorage
        document.getElementById('cfg-key').value = seed;
        localStorage.setItem('app-key', seed);

        status.innerHTML += `\n<span class="pass">Registered successfully!</span>`;
        resultDiv.style.display = 'block';
        resultDiv.innerHTML = `<span class="pass">Registration complete!</span>\n\nApp Key Seed (auto-filled in Configuration above):\n${seed}\n\nPublic Key:\n${pubkey}\n\n<span style="color:#fbbf24;">Save your recovery phrase and app key seed securely!</span>`;
        regBuilder = null;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Account Dashboard --
    async function loadAccountDashboard() {
      const status = document.getElementById('account-status');
      const dashboard = document.getElementById('account-dashboard');

      try {
        status.textContent = 'Loading account data...';

        const sdk = await connectSdk(status);
        if (!sdk) {
          return;
        }

        // Fetch account data
        const accountData = await sdk.account();
        console.log('Account data:', accountData);

        // Fetch object count
        const objectsJson = await sdk.listObjects(null); // Get all objects
        const objects = JSON.parse(objectsJson);
        const objectCount = objects.filter(o => !o.deleted).length;

        // Calculate storage metrics (accountData is a Map)
        const usedBytes = accountData.get('pinnedData');
        const maxBytes = accountData.get('maxPinnedData');
        const freeBytes = maxBytes - usedBytes;
        const usedPercent = maxBytes > 0 ? (usedBytes / maxBytes * 100) : 0;

        // Update storage bar
        document.getElementById('account-storage-bar').style.width = `${usedPercent}%`;
        document.getElementById('account-storage-text').textContent =
          `${formatSize(usedBytes)} / ${formatSize(maxBytes)} (${usedPercent.toFixed(1)}%)`;
        document.getElementById('account-used-label').textContent = `Used: ${formatSize(usedBytes)}`;
        document.getElementById('account-free-label').textContent = `Free: ${formatSize(freeBytes)}`;

        // Change bar color based on usage
        const bar = document.getElementById('account-storage-bar');
        if (usedPercent >= 90) {
          bar.style.background = 'linear-gradient(90deg, #ef4444, #dc2626)'; // Red
        } else if (usedPercent >= 75) {
          bar.style.background = 'linear-gradient(90deg, #f59e0b, #d97706)'; // Orange
        } else {
          bar.style.background = 'linear-gradient(90deg, #10b981, #059669)'; // Green
        }

        // Update quick stats
        document.getElementById('account-objects-count').textContent = objectCount.toLocaleString();
        document.getElementById('account-pinned-data').textContent = formatSize(usedBytes);
        document.getElementById('account-capacity-percent').textContent = `${usedPercent.toFixed(1)}%`;

        // Update account details (app is also a Map)
        const app = accountData.get('app');
        document.getElementById('account-app-name').textContent = app.get('description') || 'Unknown';

        const accountKey = accountData.get('accountKey');
        const shortKey = accountKey.substring(0, 24) + '...';
        const keyEl = document.getElementById('account-key');
        keyEl.textContent = shortKey;
        keyEl.title = accountKey; // Full key in tooltip

        // Format last used time
        const lastUsed = new Date(accountData.get('lastUsed'));
        const now = new Date();
        const diffMs = now - lastUsed;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        let lastUsedText;
        if (diffMins < 1) lastUsedText = 'Just now';
        else if (diffMins < 60) lastUsedText = `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
        else if (diffHours < 24) lastUsedText = `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
        else lastUsedText = `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;

        document.getElementById('account-last-used').textContent = lastUsedText;
        document.getElementById('account-max-storage').textContent = formatSize(maxBytes);

        // Clear status
        status.innerHTML = '<span class="pass">‚úì Account data loaded</span>';

        // Show warning if storage is almost full
        if (usedPercent >= 80) {
          status.innerHTML = '<span style="color:#f59e0b;">‚ö†Ô∏è Storage is ' + usedPercent.toFixed(1) + '% full. Consider deleting unused objects or pruning slabs.</span>';
        }
      } catch (e) {
        console.error('Failed to load account:', e);
        status.innerHTML = `<span class="fail">Failed to load account: ${e.message}</span>`;
      }
    }

    document.getElementById('btn-refresh-account').addEventListener('click', loadAccountDashboard);

    // -- Prune Slabs --
    document.getElementById('btn-prune-slabs').addEventListener('click', async () => {
      const button = document.getElementById('btn-prune-slabs');
      const status = document.getElementById('account-status');
      const originalText = button.textContent;

      // Confirmation dialog
      if (!confirm('üßπ Prune Unused Slabs?\n\nThis will remove slabs that are not referenced by any pinned objects.\n\nThis operation cannot be undone. Continue?')) {
        return;
      }

      try {
        // Show loading state
        button.textContent = '‚è≥ Pruning...';
        button.disabled = true;
        status.textContent = 'Pruning unused slabs...';

        const sdk = await connectSdk(status);
        if (!sdk) {
          button.textContent = originalText;
          button.disabled = false;
          return;
        }

        // Call prune slabs
        await sdk.pruneSlabs();

        // Success!
        status.innerHTML = '<span class="pass">‚úì Slabs pruned successfully! Refreshing account data...</span>';

        // Restore button
        button.textContent = originalText;
        button.disabled = false;

        // Refresh account data to show updated storage
        setTimeout(() => {
          loadAccountDashboard();
        }, 1000);
      } catch (e) {
        console.error('Failed to prune slabs:', e);
        status.innerHTML = `<span class="fail">Failed to prune slabs: ${e.message}</span>`;
        button.textContent = originalText;
        button.disabled = false;
      }
    });

    // Auto-load account dashboard when SDK is configured
    window.addEventListener('load', async () => {
      // Wait a bit for user to configure SDK
      setTimeout(async () => {
        const url = getUrl();
        const keyHex = getKeyHex();
        if (url && keyHex) {
          await loadAccountDashboard();
        }
      }, 1000);
    });

    // -- CORS Diagnostics --
    document.getElementById('btn-cors-run-all').addEventListener('click', async () => {
      const btn = document.getElementById('btn-cors-run-all');
      const resultsDiv = document.getElementById('cors-results');
      const url = getUrl();

      if (!url) {
        resultsDiv.innerHTML = '<span class="fail">Configure indexer URL first</span>';
        return;
      }

      const fakeId = randomHex(32);
      const fakeReqId = randomHex(16);

      // All routes from the Go server, with the method that triggers preflight
      const tests = [
        // CORS-enabled routes (should pass)
        { method: 'POST',   path: '/auth/connect',                       expect: true },
        { method: 'GET',    path: `/auth/connect/${fakeReqId}/status`,   expect: true },
        { method: 'POST',   path: `/auth/connect/${fakeReqId}/register`, expect: true },
        { method: 'GET',    path: '/auth/check',                         expect: true },
        { method: 'GET',    path: '/hosts',                              expect: true },
        { method: 'GET',    path: '/objects',                            expect: true },
        { method: 'GET',    path: `/objects/${fakeId}`,                  expect: true },
        { method: 'GET',    path: `/objects/${fakeId}/shared`,           expect: true },
        { method: 'POST',   path: '/objects',                            expect: true },
        { method: 'DELETE', path: `/objects/${fakeId}`,                  expect: true },
        { method: 'GET',    path: '/slabs',                              expect: true },
        { method: 'POST',   path: '/slabs',                              expect: true },
        { method: 'POST',   path: '/slabs/prune',                        expect: true },
        { method: 'GET',    path: `/slabs/${fakeId}`,                    expect: true },
        { method: 'DELETE', path: `/slabs/${fakeId}`,                    expect: true },
        // CORS-disabled routes (should fail)
        { method: 'GET',    path: `/auth/connect/${fakeReqId}`,          expect: false, note: 'CORS intentionally disabled (UI route)' },
        { method: 'POST',   path: `/auth/connect/${fakeReqId}`,          expect: false, note: 'CORS intentionally disabled (UI route)' },
      ];

      btn.disabled = true;
      btn.textContent = 'Testing...';
      resultsDiv.innerHTML = '';

      let passed = 0, failed = 0, expectedFails = 0;

      for (const t of tests) {
        const label = `${t.method} ${t.path.replace(fakeId, ':id').replace(fakeReqId, ':reqID')}`;
        const row = document.createElement('div');
        row.style.cssText = 'padding:0.4rem 0.6rem; border-bottom:1px solid #222; display:flex; justify-content:space-between; align-items:center;';
        row.innerHTML = `<span style="font-family:monospace;">${label}</span><span style="color:#888;">testing...</span>`;
        resultsDiv.appendChild(row);

        // Send the actual method with a custom header to force the browser to
        // automatically send an OPTIONS preflight. If preflight fails, fetch throws.
        try {
          const resp = await fetch(`${url}${t.path}`, {
            method: t.method,
            headers: {
              'X-CORS-Test': '1', // non-simple header forces preflight
            },
          });
          // If we got here, preflight succeeded
          if (t.expect) {
            row.lastChild.innerHTML = `<span class="pass">PASS (${resp.status})</span>`;
            passed++;
          } else {
            row.lastChild.innerHTML = `<span style="color:#f59e0b;">UNEXPECTED PASS (${resp.status})</span>`;
            passed++;
          }
        } catch (e) {
          if (!t.expect) {
            row.lastChild.innerHTML = `<span style="color:#888;">BLOCKED (expected) ‚Äî ${t.note}</span>`;
            expectedFails++;
          } else {
            row.lastChild.innerHTML = '<span class="fail">FAIL ‚Äî preflight rejected</span>';
            failed++;
          }
        }
      }

      const summary = document.createElement('div');
      summary.style.cssText = 'padding:0.75rem; margin-top:0.5rem; background:#0a0a0a; border-radius:4px; border:1px solid #222;';
      const color = failed === 0 ? '#10b981' : '#ef4444';
      summary.innerHTML = `<span style="color:${color}; font-weight:600;">${passed} passed, ${failed} failed, ${expectedFails} intentionally blocked</span>`;
      resultsDiv.appendChild(summary);

      btn.disabled = false;
      btn.textContent = 'Run All CORS Tests';
    });


    // -- Upload Text --
    document.getElementById('btn-upload').addEventListener('click', async () => {
      const status = document.getElementById('ul-status');
      const progress = document.getElementById('ul-progress');
      const text = document.getElementById('ul-text').value;

      if (!text) {
        status.innerHTML = '<span class="fail">Enter some text to upload</span>';
        return;
      }

      progress.style.display = 'none';
      progress.value = 0;

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        const data = new TextEncoder().encode(text);
        progress.style.display = 'block';
        status.textContent = 'Uploading...';

        const uploadStart = performance.now();
        const CHUNK_SIZE = 128 * 1024 * 1024;
        const ulOpts = new UploadOptions();
        ulOpts.maxInflight = getMaxUploads();
        const upload = sdk.streamingUpload(data.length, ulOpts, (current, total) => {
          progress.max = total;
          progress.value = current;
          status.textContent = `Uploading... ${current}/${total} shards`;
        });
        (async () => {
          for (let offset = 0; offset < data.length; offset += CHUNK_SIZE) {
            upload.pushChunk(data.subarray(offset, offset + CHUNK_SIZE));
          }
          upload.pushChunk(null);
        })();
        const obj = await upload.promise;
        const elapsed = ((performance.now() - uploadStart) / 1000).toFixed(1);
        const objectId = obj.id();
        const size = obj.size();

        progress.value = progress.max;
        status.innerHTML = `Upload complete (${size} bytes) in ${elapsed}s. Pinning to indexer...`;

        await sdk.pinObject(obj);

        status.innerHTML += `\n<span class="pass">Pinned!</span>\n\nObject ID: ${objectId}`;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Upload Text (web workers) --
    document.getElementById('btn-upload-text-workers').addEventListener('click', async () => {
      const status = document.getElementById('ul-status');
      const progress = document.getElementById('ul-progress');
      const text = document.getElementById('ul-text').value;

      if (!text) {
        status.innerHTML = '<span class="fail">Enter some text to upload</span>';
        return;
      }

      progress.style.display = 'none';
      progress.value = 0;

      try {
        const data = new TextEncoder().encode(text);
        const file = new File([data], 'text');

        status.innerHTML = `Uploading text (${formatSize(data.length)})...\n`;

        const result = await parallelUpload(file, status, progress);
        if (!result) return;

        const { obj, elapsed, size } = result;
        const objectId = obj.id();

        progress.value = progress.max;
        status.innerHTML = `Upload complete (${formatSize(size)}) in ${elapsed}s. Pinning to indexer...`;

        const sdk = await connectSdk(status);
        await sdk.pinObject(obj);

        status.innerHTML = `Upload + pin completed (${formatSize(size)}) in ${elapsed}s\n<span class="pass">Pinned!</span>\n\nObject ID: ${objectId}`;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Upload File --
    let selectedFile = null;
    const dropzone = document.getElementById('uf-dropzone');
    const fileInput = document.getElementById('uf-file');
    const fileInfo = document.getElementById('uf-file-info');

    function setFile(file) {
      selectedFile = file;
      fileInfo.textContent = `${file.name} (${formatSize(file.size)})`;
    }

    dropzone.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', () => {
      if (fileInput.files.length) setFile(fileInput.files[0]);
    });
    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.classList.add('dragover');
    });
    dropzone.addEventListener('dragleave', () => {
      dropzone.classList.remove('dragover');
    });
    dropzone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropzone.classList.remove('dragover');
      if (e.dataTransfer.files.length) setFile(e.dataTransfer.files[0]);
    });

    document.getElementById('btn-upload-file').addEventListener('click', async () => {
      const status = document.getElementById('uf-status');
      const progress = document.getElementById('uf-progress');

      if (!selectedFile) {
        status.innerHTML = '<span class="fail">Select a file first</span>';
        return;
      }

      progress.style.display = 'none';
      progress.value = 0;

      try {
        status.innerHTML = `Uploading ${selectedFile.name} (${formatSize(selectedFile.size)})...\n`;

        const result = await parallelUpload(selectedFile, status, progress);
        if (!result) return;

        const { obj, elapsed, size } = result;
        const objectId = obj.id();

        progress.value = progress.max;
        status.innerHTML = `Upload complete (${formatSize(size)}) in ${elapsed}s. Pinning to indexer...`;

        const sdk = await connectSdk(status);
        await sdk.pinObject(obj);

        status.innerHTML = `File: ${selectedFile.name}\nSize: ${formatSize(size)}\nUpload + pin completed in ${elapsed}s\n<span class="pass">Pinned!</span>\n\nObject ID: ${objectId}`;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Simple File Upload (no workers, single-threaded streaming upload) --
    document.getElementById('btn-upload-file-simple').addEventListener('click', async () => {
      const status = document.getElementById('uf-status');
      const progress = document.getElementById('uf-progress');

      if (!selectedFile) {
        status.innerHTML = '<span class="fail">Select a file first</span>';
        return;
      }

      progress.style.display = 'none';
      progress.value = 0;

      try {
        status.innerHTML = `Uploading ${selectedFile.name} (${formatSize(selectedFile.size)})...`;
        const sdk = await connectSdk(status);
        if (!sdk) return;

        progress.style.display = 'block';

        const uploadStart = performance.now();
        const CHUNK_SIZE = 128 * 1024 * 1024;
        const fileSize = selectedFile.size;
        const ulOpts2 = new UploadOptions();
        ulOpts2.maxInflight = getMaxUploads();
        const upload = sdk.streamingUpload(fileSize, ulOpts2, (current, total) => {
          progress.max = total;
          progress.value = current;
          status.innerHTML = `Uploading ${selectedFile.name} (${formatSize(fileSize)})... ${current}/${total} shards`;
        });
        (async () => {
          for (let offset = 0; offset < fileSize; offset += CHUNK_SIZE) {
            const chunk = selectedFile.slice(offset, offset + CHUNK_SIZE);
            const data = new Uint8Array(await chunk.arrayBuffer());
            upload.pushChunk(data);
          }
          upload.pushChunk(null);
        })();
        const obj = await upload.promise;
        const elapsed = ((performance.now() - uploadStart) / 1000).toFixed(1);
        const objectId = obj.id();
        const size = obj.size();

        progress.value = progress.max;
        status.innerHTML = `Upload complete (${formatSize(size)}) in ${elapsed}s. Pinning to indexer...`;

        await sdk.pinObject(obj);

        status.innerHTML = `File: ${selectedFile.name}\nSize: ${formatSize(size)}\nUpload + pin completed in ${elapsed}s\n<span class="pass">Pinned!</span>\n\nObject ID: ${objectId}`;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Download File --
    document.getElementById('btn-download').addEventListener('click', async () => {
      const status = document.getElementById('dl-status');
      const progress = document.getElementById('dl-progress');
      const input = document.getElementById('dl-url').value.trim();
      const filename = document.getElementById('dl-filename').value.trim() || 'download';

      progress.style.display = 'none';
      progress.value = 0;

      if (!input) {
        status.innerHTML = '<span class="fail">Enter an Object ID or Share URL</span>';
        return;
      }

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.innerHTML += '\nFetching object metadata...';

        // Auto-detect: if starts with sia:// or https://, it's a share URL, otherwise object ID
        const isShareUrl = input.startsWith('sia://') || input.startsWith('https://');
        const obj = isShareUrl
          ? await sdk.sharedObject(input)
          : await sdk.object(input);
        const size = obj.size();
        status.innerHTML = `Object found: ${formatSize(size)}`;

        // Check if File System Access API is available and warn about large files
        const hasFileSystemAPI = !!window.showSaveFilePicker;
        const sizeMB = size / (1024 * 1024);

        if (!hasFileSystemAPI) {
          const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');
          const browserName = isFirefox ? 'Firefox' : 'Your browser';

          status.innerHTML = `<span style="color:#ef4444; font-weight:bold;">‚ùå ${browserName} doesn't support streaming to disk</span>\n\n` +
            `File size: ${formatSize(size)}\n\n` +
            `<strong>This will crash your browser!</strong> Files over ~500MB cannot be downloaded in Firefox because it lacks File System Access API support.\n\n` +
            `<span style="color:#10b981; font-weight:bold;">‚úì Solution: Use Chrome or Edge</span>`;
          return;
        }

        progress.style.display = 'block';
        status.textContent = 'Downloading...';

        const downloadStart = performance.now();
        let bytesDownloaded = 0;
        let progressInterval = null;

        // Update progress display (reads from progress element + bytesDownloaded)
        const updateProgress = () => {
          const currentSlab = progress.value || 0;
          const totalSlabs = progress.max || 0;
          if (totalSlabs === 0) return;

          const now = performance.now();
          const percentage = ((currentSlab / totalSlabs) * 100).toFixed(1);
          const elapsed = (now - downloadStart) / 1000;
          const speed = bytesDownloaded / elapsed;
          const remaining = size - bytesDownloaded;
          const eta = speed > 0 ? remaining / speed : 0;

          const formatTime = (seconds) => {
            if (seconds < 60) return `${seconds.toFixed(0)}s`;
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
          };

          const speedMBps = (speed / 1e6).toFixed(2);
          const workers = getDownloadWorkers();
          const line1 = `Downloading... ${currentSlab}/${totalSlabs} slabs (${percentage}%) ‚Ä¢ ${formatSize(bytesDownloaded)} / ${formatSize(size)}`;
          const line2 = `${speedMBps} MB/s ‚Ä¢ ${formatTime(elapsed)} elapsed ‚Ä¢ ~${formatTime(eta)} remaining (${Math.min(workers, totalSlabs)} workers)`;
          status.textContent = `${line1}\n${line2}`;
        };

        progressInterval = setInterval(updateProgress, 100);

        // Parallel slab download to disk via File System Access API
        if (window.showSaveFilePicker) {
          const handle = await window.showSaveFilePicker({
            suggestedName: filename,
          });
          const writable = await handle.createWritable();
          try {
            await parallelDownloadToDisk(input, writable, status, progress,
              (bytes) => { bytesDownloaded = bytes; });
            await writable.close();
          } catch (e) {
            try { await writable.abort(); } catch (_) {}
            throw e;
          }
        } else {
          // Memory fallback (no File System Access API)
          const result = await parallelDownload(input, status, progress, 'Downloading');
          bytesDownloaded = result.size;
          const blob = result.blob;
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = filename;
          a.click();
          URL.revokeObjectURL(a.href);
        }

        clearInterval(progressInterval);
        const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
        progress.value = progress.max;
        status.innerHTML = `File: ${filename}\nSize: ${formatSize(size)}\nDownloaded in ${elapsed}s\n<span class="pass">Saved to disk!</span>`;
      } catch (e) {
        if (progressInterval) clearInterval(progressInterval);
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- List Objects --
    document.getElementById('btn-list-objects').addEventListener('click', async () => {
      const status = document.getElementById('list-status');
      const objectsList = document.getElementById('objects-list');
      const limit = parseInt(document.getElementById('list-limit').value) || 50;

      status.textContent = 'Loading...';
      objectsList.innerHTML = '';

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.textContent = 'Fetching objects...';
        const objectsJson = await sdk.listObjects(limit);
        const objects = JSON.parse(objectsJson);

        if (objects.length === 0) {
          objectsList.innerHTML = '<div style="padding:1rem; color:#888; text-align:center;">No objects found. Upload something first!</div>';
          status.innerHTML = '<span style="color:#888;">No objects found</span>';
          return;
        }

        // Display objects in a table
        let html = `
          <table style="width:100%; border-collapse:collapse; font-size:0.9rem;">
            <thead>
              <tr style="border-bottom:2px solid #333; text-align:left;">
                <th style="padding:0.5rem;">Object ID</th>
                <th style="padding:0.5rem;">Size</th>
                <th style="padding:0.5rem;">Updated</th>
                <th style="padding:0.5rem;">Status</th>
                <th style="padding:0.5rem;">Actions</th>
              </tr>
            </thead>
            <tbody>
        `;

        for (const obj of objects) {
          const shortId = obj.id.substring(0, 8) + '...' + obj.id.substring(obj.id.length - 8);
          const size = obj.size ? formatSize(obj.size) : 'N/A';
          const date = new Date(obj.updated_at).toLocaleString();
          const status = obj.deleted ? '<span class="fail">Deleted</span>' : '<span class="pass">Active</span>';

          html += `
            <tr style="border-bottom:1px solid #222;">
              <td style="padding:0.5rem; font-family:monospace; font-size:0.85rem;" title="${obj.id}">${shortId}</td>
              <td style="padding:0.5rem;">${size}</td>
              <td style="padding:0.5rem;">${date}</td>
              <td style="padding:0.5rem;">${status}</td>
              <td style="padding:0.5rem;">
                ${!obj.deleted ? `
                  <button onclick="viewObjectById('${obj.id}')" style="padding:0.25rem 0.5rem; font-size:0.85rem; background:#3b82f6; color:white;" title="Open in browser viewer">View</button>
                  <button onclick="shareObjectById('${obj.id}')" style="padding:0.25rem 0.5rem; font-size:0.85rem; background:#10b981; color:white; margin-left:0.25rem;" title="Generate share URL">Share</button>
                  <button onclick="showObjectInfo('${obj.id}')" style="padding:0.25rem 0.5rem; font-size:0.85rem; background:#8b5cf6; color:white; margin-left:0.25rem;" title="Show details">Info</button>
                  <button onclick="downloadObjectById('${obj.id}')" style="padding:0.25rem 0.5rem; font-size:0.85rem; margin-left:0.25rem;">Download</button>
                  <button onclick="copyToClipboard('${obj.id}')" style="padding:0.25rem 0.5rem; font-size:0.85rem; margin-left:0.25rem;">Copy ID</button>
                  <button onclick="deleteObjectById('${obj.id}')" style="padding:0.25rem 0.5rem; font-size:0.85rem; margin-left:0.25rem; background:#dc2626; color:white;">Delete</button>
                ` : ''}
              </td>
            </tr>
          `;
        }

        html += `
            </tbody>
          </table>
        `;

        objectsList.innerHTML = html;
        status.innerHTML = `<span class="pass">‚úì Found ${objects.length} object${objects.length !== 1 ? 's' : ''}</span>`;
      } catch (e) {
        status.innerHTML = `<span class="fail">Error: ${e.message}</span>`;
        objectsList.innerHTML = '';
      }
    });

    // Helper function to download an object by ID
    window.downloadObjectById = async (objectId) => {
      const dlUrl = document.getElementById('dl-url');
      const dlFilename = document.getElementById('dl-filename');

      dlUrl.value = objectId;
      dlFilename.value = 'download_' + objectId.substring(0, 8);

      // Scroll to download section
      document.querySelector('#btn-download').parentElement.parentElement.scrollIntoView({ behavior: 'smooth' });

      // Trigger download after a brief delay to let scroll finish
      setTimeout(() => {
        document.getElementById('btn-download').click();
      }, 500);
    };

    // Helper function to copy to clipboard
    window.copyToClipboard = async (text) => {
      try {
        await navigator.clipboard.writeText(text);
        alert('Object ID copied to clipboard!');
      } catch (e) {
        // Fallback for older browsers
        const textarea = document.createElement('textarea');
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        alert('Object ID copied to clipboard!');
      }
    };

    // Helper function to delete an object
    window.deleteObjectById = async (objectId) => {
      const shortId = objectId.substring(0, 8) + '...' + objectId.substring(objectId.length - 8);

      if (!confirm(`‚ö†Ô∏è Are you sure you want to delete object ${shortId}?\n\nThis action cannot be undone!`)) {
        return;
      }

      const status = document.getElementById('list-status');
      const originalStatus = status.innerHTML;

      try {
        status.innerHTML = '<span style="color:#f59e0b;">‚è≥ Deleting...</span>';

        const sdk = await connectSdk(status);
        if (!sdk) return;

        await sdk.deleteObject(objectId);

        status.innerHTML = '<span class="pass">‚úì Object deleted successfully!</span>';

        // Refresh the list after a short delay
        setTimeout(() => {
          document.getElementById('btn-list-objects').click();
        }, 500);
      } catch (e) {
        status.innerHTML = `<span class="fail">Delete failed: ${e.message}</span>`;

        // Restore original status after showing error for 3 seconds
        setTimeout(() => {
          status.innerHTML = originalStatus;
        }, 3000);
      }
    };

    // Helper function to view an object in the browser
    window.viewObjectById = async (objectId) => {
      const addressBar = document.getElementById('address-bar');
      addressBar.value = objectId;

      // Scroll to browser section
      document.querySelector('#browser-nav').scrollIntoView({ behavior: 'smooth' });

      // Trigger view after a brief delay
      setTimeout(() => {
        loadContentWithAutoDetect();
      }, 500);
    };

    // Helper function to share an object (generate share URL)
    window.shareObjectById = async (objectId) => {
      const shortId = objectId.substring(0, 8) + '...' + objectId.substring(objectId.length - 8);

      // Show configuration modal first
      const configModal = document.createElement('div');
      configModal.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.8); display: flex; align-items: center;
        justify-content: center; z-index: 1000;
      `;

      configModal.innerHTML = `
        <div style="background:#1a1a1a; padding:2rem; border-radius:8px; max-width:500px; width:90%; border:1px solid #333;">
          <h3 style="margin:0 0 1rem 0; color:#10b981;">üîó Generate Share URL</h3>
          <p style="color:#888; margin-bottom:1.5rem;">Object: ${shortId}</p>

          <div style="margin-bottom:1.5rem;">
            <div style="color:#e0e0e0; margin-bottom:0.5rem; font-size:0.9rem;">Expires in</div>
            <div style="display:flex; gap:0.5rem; align-items:center;">
              <input id="share-modal-duration" type="number" value="24" min="1" style="width:5rem; padding:0.5rem; background:#0a0a0a; color:#e0e0e0; border:1px solid #333; border-radius:4px; font-size:1rem;" />
              <select id="share-modal-unit" style="flex:1; padding:0.5rem; background:#0a0a0a; color:#e0e0e0; border:1px solid #333; border-radius:4px; font-size:1rem;">
                <option value="3600000">hours</option>
                <option value="86400000" selected>days</option>
                <option value="604800000">weeks</option>
              </select>
            </div>
          </div>

          <div style="display:flex; gap:0.5rem;">
            <button id="btn-generate-share" style="flex:1; padding:0.75rem; background:#10b981; color:white; border:none; border-radius:4px; cursor:pointer; font-size:1rem; font-weight:500;">
              Generate Link
            </button>
            <button id="btn-cancel-share" style="flex:1; padding:0.75rem; background:#333; color:white; border:none; border-radius:4px; cursor:pointer; font-size:1rem;">
              Cancel
            </button>
          </div>
        </div>
      `;

      document.body.appendChild(configModal);

      // Close on background click
      configModal.addEventListener('click', (e) => {
        if (e.target === configModal) configModal.remove();
      });

      // Cancel button
      configModal.querySelector('#btn-cancel-share').addEventListener('click', () => {
        configModal.remove();
      });

      // Generate button
      configModal.querySelector('#btn-generate-share').addEventListener('click', async () => {
        const generateBtn = configModal.querySelector('#btn-generate-share');
        const originalText = generateBtn.textContent;
        generateBtn.textContent = '‚è≥ Generating...';
        generateBtn.disabled = true;

        try {
          const duration = parseFloat(configModal.querySelector('#share-modal-duration').value);
          const unit = parseInt(configModal.querySelector('#share-modal-unit').value);

          const status = document.getElementById('list-status');
          const sdk = await connectSdk(status);
          if (!sdk) {
            configModal.remove();
            return;
          }

          // Fetch the object
          const obj = await sdk.object(objectId);

          // Generate share URL with configured duration
          const validUntilMs = Date.now() + (duration * unit);
          const shareUrl = sdk.shareObject(obj, validUntilMs);

          // Calculate human-readable duration
          let durationText = `${duration} ${configModal.querySelector('#share-modal-unit').selectedOptions[0].text}`;

          // Remove config modal
          configModal.remove();

          // Show result modal
          const resultModal = document.createElement('div');
          resultModal.style.cssText = `
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8); display: flex; align-items: center;
            justify-content: center; z-index: 1000;
          `;

          resultModal.innerHTML = `
            <div style="background:#1a1a1a; padding:2rem; border-radius:8px; max-width:600px; width:90%; border:1px solid #333;">
              <h3 style="margin:0 0 1rem 0; color:#10b981;">üîó Share URL Generated</h3>
              <p style="color:#888; margin-bottom:1rem;">Object: ${shortId}</p>
              <div style="background:#0a0a0a; padding:1rem; border-radius:4px; margin-bottom:1rem; word-break:break-all; font-family:monospace; font-size:0.9rem;">
                ${shareUrl}
              </div>
              <p style="color:#888; font-size:0.9rem; margin-bottom:1rem;">
                ‚è∞ Valid for ${durationText}<br>
                üîí Includes encryption key in URL
              </p>
              <div style="display:flex; gap:0.5rem;">
                <button onclick="navigator.clipboard.writeText('${shareUrl.replace(/'/g, "\\'")}').then(() => alert('Share URL copied!')); this.parentElement.parentElement.parentElement.remove();" style="flex:1; padding:0.75rem; background:#10b981; color:white; border:none; border-radius:4px; cursor:pointer; font-size:1rem;">
                  üìã Copy URL
                </button>
                <button onclick="this.parentElement.parentElement.parentElement.remove();" style="flex:1; padding:0.75rem; background:#333; color:white; border:none; border-radius:4px; cursor:pointer; font-size:1rem;">
                  Close
                </button>
              </div>
            </div>
          `;

          document.body.appendChild(resultModal);

          // Close on background click
          resultModal.addEventListener('click', (e) => {
            if (e.target === resultModal) resultModal.remove();
          });
        } catch (e) {
          configModal.remove();
          alert(`Share failed: ${e.message}`);
        }
      });
    };

    // Helper function to show object info/details
    window.showObjectInfo = async (objectId) => {
      const shortId = objectId.substring(0, 8) + '...' + objectId.substring(objectId.length - 8);

      try {
        // Show loading state
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '‚è≥';
        button.disabled = true;

        const status = document.getElementById('list-status');
        const sdk = await connectSdk(status);
        if (!sdk) {
          button.textContent = originalText;
          button.disabled = false;
          return;
        }

        // Fetch the object
        const obj = await sdk.object(objectId);
        const size = obj.size();

        // Calculate number of slabs (each slab holds 10 shards * 4MB = ~40MB of data)
        const SLAB_DATA_SIZE = 10 * 4 * 1024 * 1024; // 40 MB
        const numSlabs = size === 0 ? 0 : Math.ceil(size / SLAB_DATA_SIZE);

        // Show info in a modal
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed; top: 0; left: 0; right: 0; bottom: 0;
          background: rgba(0,0,0,0.8); display: flex; align-items: center;
          justify-content: center; z-index: 1000;
        `;

        modal.innerHTML = `
          <div style="background:#1a1a1a; padding:2rem; border-radius:8px; max-width:600px; width:90%; border:1px solid #333;">
            <h3 style="margin:0 0 1rem 0; color:#8b5cf6;">‚ÑπÔ∏è Object Details</h3>
            <div style="background:#0a0a0a; padding:1rem; border-radius:4px; margin-bottom:1rem;">
              <div style="margin-bottom:0.75rem;">
                <div style="color:#888; font-size:0.85rem; margin-bottom:0.25rem;">Object ID:</div>
                <div style="font-family:monospace; font-size:0.9rem; word-break:break-all;">${objectId}</div>
              </div>
              <div style="margin-bottom:0.75rem;">
                <div style="color:#888; font-size:0.85rem; margin-bottom:0.25rem;">Size:</div>
                <div>${formatSize(size)} (${size.toLocaleString()} bytes)</div>
              </div>
              <div style="margin-bottom:0.75rem;">
                <div style="color:#888; font-size:0.85rem; margin-bottom:0.25rem;">Slabs:</div>
                <div>${numSlabs} slab${numSlabs !== 1 ? 's' : ''} (~${(numSlabs * 40).toFixed(0)} MB encoded)</div>
              </div>
              <div style="margin-bottom:0.75rem;">
                <div style="color:#888; font-size:0.85rem; margin-bottom:0.25rem;">Redundancy:</div>
                <div>10 data shards + 20 parity shards (need any 10 of 30)</div>
              </div>
              <div>
                <div style="color:#888; font-size:0.85rem; margin-bottom:0.25rem;">Redundancy:</div>
                <div>10 data + 20 parity (${formatSize(size)} pinned)</div>
              </div>
            </div>
            <button onclick="this.parentElement.parentElement.remove();" style="width:100%; padding:0.75rem; background:#333; color:white; border:none; border-radius:4px; cursor:pointer; font-size:1rem;">
              Close
            </button>
          </div>
        `;

        document.body.appendChild(modal);

        // Close on background click
        modal.addEventListener('click', (e) => {
          if (e.target === modal) modal.remove();
        });

        // Restore button
        button.textContent = originalText;
        button.disabled = false;
      } catch (e) {
        alert(`Failed to load info: ${e.message}`);
        event.target.textContent = 'Info';
        event.target.disabled = false;
      }
    };

    // -- Share Object --
    document.getElementById('btn-share').addEventListener('click', async () => {
      const status = document.getElementById('share-status');
      const objectId = document.getElementById('share-object-id').value.trim();
      const duration = parseFloat(document.getElementById('share-duration').value);
      const unit = parseInt(document.getElementById('share-unit').value);

      if (!objectId) {
        status.innerHTML = '<span class="fail">Enter an Object ID</span>';
        return;
      }

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.textContent = 'Fetching object...';
        const obj = await sdk.object(objectId);

        const validUntilMs = Date.now() + (duration * unit);
        const shareUrl = sdk.shareObject(obj, validUntilMs);

        const expiresAt = new Date(validUntilMs).toLocaleString();
        status.innerHTML = `<span class="pass">Share link created!</span>\nExpires: ${expiresAt}\n\n<a href="${shareUrl}" target="_blank" rel="noopener" style="color:#60a5fa; word-break:break-all;">${shareUrl}</a>`;
      } catch (e) {
        status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // -- Decentralized Browser (HTML Viewer with Navigation) --
    const HISTORY_STORAGE_KEY = 'sia-browser-history';
    const browserHistory = [];
    let currentHistoryIndex = -1;

    // Load history from localStorage on page load
    function loadHistoryFromStorage() {
      try {
        const saved = localStorage.getItem(HISTORY_STORAGE_KEY);
        if (saved) {
          const parsed = JSON.parse(saved);
          // Restore history items (blob URLs will be null after refresh)
          browserHistory.push(...parsed);
          console.log(`üìö Restored ${browserHistory.length} history items from localStorage`);
          updateBrowserUI();
        }
      } catch (e) {
        console.error('Failed to load history from storage:', e);
      }
    }

    // Save history to localStorage
    function saveHistoryToStorage() {
      try {
        // Save history without blob URLs (they're temporary)
        const toSave = browserHistory.map(item => ({
          displayUrl: item.displayUrl,
          title: item.title,
          external: item.external,
          originalUrl: item.originalUrl,
          fileType: item.fileType,
          blobUrl: null  // Don't save blob URLs - they won't work after refresh
        }));
        localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(toSave));
      } catch (e) {
        console.error('Failed to save history to storage:', e);
      }
    }

    // Load history when page loads
    loadHistoryFromStorage();

    // If history is empty, add the welcome page to history
    if (browserHistory.length === 0) {
      const welcomeUrl = 'sia://app.sia.storage/objects/09ea72b591744fc1743c31464691b1ec5980fcb095599f457997e9ad37577f7e/shared?sv=1802936115&sc=nmS95u9mPXfFkjj8fkVfCw28mgyVgq9IQOUQYBykQNs%3D&ss=slOkbXbAiHIouqyFvSIG2q-tCbKGXMMSHN_2jE2H9BI_f-siLvrGpvh-3uwzZXwwxbpUSSqCLM0t_lUqQm1RCw%3D%3D#encryption_key=vateUaubfTjtSy5o6yG2sk37UX2s9KBZaUenzd9OP68=';

      // Add welcome page to history (without blob URL - user will click to load)
      browserHistory.push({
        displayUrl: welcomeUrl,
        blobUrl: null,
        title: 'Welcome to Sia Browser',
        external: false,
        originalUrl: welcomeUrl,
        fileType: 'html'
      });

      currentHistoryIndex = 0;
      updateBrowserUI();
      saveHistoryToStorage();

      console.log('üìÑ Welcome page added to history');
    }

    function updateBrowserUI() {
      const addressBar = document.getElementById('address-bar');
      const historyList = document.getElementById('history-list');

      // Update address bar with raw URL (so user can click Go or External Tab)
      if (currentHistoryIndex >= 0 && browserHistory[currentHistoryIndex]) {
        const current = browserHistory[currentHistoryIndex];
        addressBar.value = current.originalUrl || current.displayUrl;
        addressBar.title = current.displayUrl; // Tooltip shows formatted version
      } else {
        addressBar.value = '';
        addressBar.placeholder = 'Paste Sia share URL or object ID...';
      }

      // Update history list
      historyList.innerHTML = '';
      browserHistory.forEach((item, index) => {
        const historyItem = document.createElement('div');
        let classes = 'history-item';
        if (index === currentHistoryIndex) classes += ' active';
        if (item.blobUrl) classes += ' downloaded';
        historyItem.className = classes;

        // Only show warning for external HTML tabs, not for PDFs (which are safe)
        const isPdf = item.displayUrl && item.displayUrl.startsWith('PDF:');
        const showWarning = item.external && !isPdf;

        const itemText = (showWarning ? '‚ö†Ô∏è ' : '') + (item.title || item.displayUrl);
        historyItem.innerHTML = `
          <span class="history-title">${itemText}</span>
          ${item.blobUrl ? '<button class="history-download" style="opacity: 0; transition: opacity 0.2s; background: none; border: none; color: #10b981; cursor: pointer; padding: 0 0.5rem; font-size: 1rem; line-height: 1;" title="Download">‚¨á</button>' : ''}
          <button class="history-delete" style="opacity: 0; transition: opacity 0.2s; background: none; border: none; color: #ef4444; cursor: pointer; padding: 0 0.5rem; font-size: 1.2rem; line-height: 1;" title="Delete">√ó</button>
        `;
        historyItem.title = (showWarning ? '[External Tab] ' : '') + item.displayUrl;

        // Show buttons on hover
        historyItem.addEventListener('mouseenter', () => {
          const deleteBtn = historyItem.querySelector('.history-delete');
          const downloadBtn = historyItem.querySelector('.history-download');
          if (deleteBtn) deleteBtn.style.opacity = '1';
          if (downloadBtn) downloadBtn.style.opacity = '1';
        });
        historyItem.addEventListener('mouseleave', () => {
          const deleteBtn = historyItem.querySelector('.history-delete');
          const downloadBtn = historyItem.querySelector('.history-download');
          if (deleteBtn) deleteBtn.style.opacity = '0';
          if (downloadBtn) downloadBtn.style.opacity = '0';
        });

        // Navigate on title click
        historyItem.querySelector('.history-title').addEventListener('click', () => navigateToHistory(index));

        // Download on ‚¨á click
        const downloadBtn = historyItem.querySelector('.history-download');
        if (downloadBtn) {
          downloadBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            downloadHistoryItem(index);
          });
        }

        // Delete on X click
        historyItem.querySelector('.history-delete').addEventListener('click', (e) => {
          e.stopPropagation();
          deleteHistoryItem(index);
        });

        historyList.appendChild(historyItem);
      });
    }

    function deleteHistoryItem(index) {
      if (index < 0 || index >= browserHistory.length) return;

      // Revoke the blob URL to free memory
      const item = browserHistory[index];
      if (item.blobUrl && item.blobUrl.startsWith('blob:')) {
        URL.revokeObjectURL(item.blobUrl);
      }

      // Remove the item
      browserHistory.splice(index, 1);

      // Update current index
      if (currentHistoryIndex === index) {
        // Deleted the current item - move to previous or clear
        currentHistoryIndex = Math.max(0, index - 1);
        if (browserHistory.length === 0) {
          currentHistoryIndex = -1;
          // Clear the iframe
          const iframe = document.getElementById('html-iframe');
          const videoContainer = document.getElementById('video-container');
          const video = document.getElementById('mse-video');
          iframe.src = '';
          iframe.style.display = 'block';
          videoContainer.style.display = 'none';
          video.src = '';
        }
      } else if (currentHistoryIndex > index) {
        // Deleted an item before the current - adjust index
        currentHistoryIndex--;
      }

      updateBrowserUI();
      saveHistoryToStorage();
    }

    function downloadHistoryItem(index) {
      if (index < 0 || index >= browserHistory.length) return;

      const item = browserHistory[index];
      if (!item.blobUrl) {
        alert('This item has not been downloaded yet. Click on it to load it first.');
        return;
      }

      // Generate a filename from the display URL or object ID
      let filename = 'download';
      try {
        // Try to extract a meaningful filename
        const url = item.originalUrl || item.displayUrl;
        if (url.includes('/')) {
          // Get the last part of the URL
          const parts = url.split('/');
          filename = parts[parts.length - 1];
        } else if (url.length === 64) {
          // Looks like an object ID - use shortened version
          filename = `object_${url.substring(0, 8)}`;
        } else {
          filename = 'download';
        }

        // Add extension based on file type if we can guess it
        if (item.fileType && !filename.includes('.')) {
          const extensions = {
            'image': '.jpg',
            'video': '.mp4',
            'audio': '.mp3',
            'pdf': '.pdf',
            'html': '.html',
            'text': '.txt'
          };
          if (extensions[item.fileType]) {
            filename += extensions[item.fileType];
          }
        }
      } catch (e) {
        console.error('Error generating filename:', e);
      }

      // Trigger download
      const a = document.createElement('a');
      a.href = item.blobUrl;
      a.download = filename;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);

      console.log(`üì• Downloaded history item: ${filename}`);
    }

    async function navigateToHistory(index) {
      if (index < 0 || index >= browserHistory.length) return;
      currentHistoryIndex = index;
      const item = browserHistory[index];

      // Stop any active browser stream when navigating away
      if (activeBrowserStreamAbort) {
        activeBrowserStreamAbort.abort();
        activeBrowserStreamAbort = null;
      }

      // If blob URL is null (e.g., after page refresh or streaming video), re-download the file
      if (!item.blobUrl) {
        console.log('üîÑ Blob URL missing, re-downloading:', item.originalUrl);
        await redownloadHistoryItem(item, index);
        return;
      }

      // If this is an external tab item, reopen it in external tab
      if (item.external) {
        window.open(item.blobUrl, '_blank');
      } else {
        // Show iframe, hide video
        const iframe = document.getElementById('html-iframe');
        const videoContainer = document.getElementById('video-container');
        const video = document.getElementById('mse-video');

        iframe.style.display = 'block';
        videoContainer.style.display = 'none';
        video.src = '';

        // Load in iframe
        iframe.src = item.blobUrl;
      }
      updateBrowserUI();
    }

    // Re-download a history item (when blob URL is missing after refresh)
    async function redownloadHistoryItem(item, index) {
      const status = document.getElementById('iframe-status');
      const progress = document.getElementById('iframe-progress');
      const iframe = document.getElementById('html-iframe');
      const videoContainer = document.getElementById('video-container');
      const canvas = document.getElementById('stream-canvas');
      const video = document.getElementById('mse-video');

      progress.style.display = 'none';
      progress.value = 0;

      // Stop any active browser stream
      if (activeBrowserStreamAbort) {
        activeBrowserStreamAbort.abort();
        activeBrowserStreamAbort = null;
      }

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        // For video items, re-stream via WebCodecs (or MSE fallback)
        if (item.fileType === 'video') {
          status.textContent = 'Re-streaming video...';
          const obj = item.originalUrl.startsWith('sia://')
            ? await sdk.sharedObject(item.originalUrl)
            : await sdk.object(item.originalUrl);

          iframe.style.display = 'none';
          videoContainer.style.display = 'block';

          // Try WebCodecs first
          if (typeof VideoDecoder !== 'undefined') {
            try {
              canvas.style.display = 'block';
              video.style.display = 'none';
              const result = await webcodecStream(sdk, obj, canvas, status, progress, item.originalUrl);
              activeBrowserStreamAbort = result;
              status.innerHTML = `<span class="pass">${status.textContent}</span>`;
              updateBrowserUI();
              return;
            } catch (e) {
              console.error('[browser] WebCodecs re-stream failed:', e);
            }
          }

          // Fall back to MSE
          try {
            canvas.style.display = 'none';
            video.style.display = 'block';
            const result = await transmuxAndStream(sdk, obj, video, status, progress);
            activeBrowserStreamAbort = result;
            status.innerHTML = `<span class="pass">${status.textContent}</span>`;
            updateBrowserUI();
            return;
          } catch (e) {
            console.error('[browser] MSE re-stream failed:', e);
            videoContainer.style.display = 'none';
            iframe.style.display = 'block';
            status.textContent = 'Streaming failed, re-downloading...';
          }
        }

        status.textContent = `Re-downloading ${item.fileType}...`;

        const { blob: downloadedBlob } = await parallelDownload(item.originalUrl, status, progress, 'Downloading');
        const data = new Uint8Array(await downloadedBlob.arrayBuffer());

        // Create blob with appropriate MIME type and wrapper
        let mimeType = 'text/html';
        if (item.fileType === 'pdf') mimeType = 'application/pdf';
        else if (item.fileType === 'image') mimeType = 'image/jpeg';
        else if (item.fileType === 'video') mimeType = 'video/mp4';
        else if (item.fileType === 'audio') mimeType = 'audio/mpeg';
        else if (item.fileType === 'text') mimeType = 'text/plain';

        // Create blob with appropriate wrapper for better display
        let blobUrl;
        if (item.fileType === 'text') {
          // Wrap text in styled HTML for better readability
          const text = new TextDecoder().decode(data);
          const escapedText = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
          const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{font-family:'Courier New',monospace;padding:1.5rem;background:#0a0a0a;color:#e0e0e0;margin:0;}pre{white-space:pre-wrap;word-wrap:break-word;margin:0;line-height:1.5;}</style></head><body><pre>${escapedText}</pre></body></html>`;
          const blob = new Blob([html], { type: 'text/html' });
          blobUrl = URL.createObjectURL(blob);
        } else if (item.fileType === 'audio') {
          // Wrap audio in HTML with styled player
          const audioBlob = new Blob([data], { type: mimeType });
          const audioUrl = URL.createObjectURL(audioBlob);
          const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;margin:0;background:#0a0a0a;color:#e0e0e0;font-family:system-ui,sans-serif;}audio{width:90%;max-width:600px;}</style></head><body><h2 style="margin-bottom:2rem;">üéµ Audio Player</h2><audio controls autoplay><source src="${audioUrl}" type="${mimeType}">Your browser does not support the audio element.</audio></body></html>`;
          const blob = new Blob([html], { type: 'text/html' });
          blobUrl = URL.createObjectURL(blob);
        } else {
          // For other types, load directly
          const blob = new Blob([data], { type: mimeType });
          blobUrl = URL.createObjectURL(blob);
        }

        // Update history item with new blob URL
        browserHistory[index].blobUrl = blobUrl;

        // Load the file
        if (item.external || item.fileType === 'pdf') {
          window.open(blobUrl, '_blank');
          status.innerHTML = '<span class="pass">‚úì Reopened in new tab!</span>';
        } else {
          iframe.src = blobUrl;
          status.innerHTML = '<span class="pass">‚úì Loaded!</span>';
        }

        updateBrowserUI();
      } catch (e) {
        status.innerHTML = `<span class="fail">Error re-downloading: ${e.message}</span>`;
      }
    }

    function addToHistory(displayUrl, blobUrl, title = null, external = false, originalUrl = '', fileType = 'html') {
      console.log('üîç addToHistory called:', {
        displayUrl,
        external,
        originalUrl,
        fileType,
        currentHistoryIndex,
        historyLength: browserHistory.length
      });

      // Check if this URL already exists in history (by original URL, not blob URL)
      const existingIndex = browserHistory.findIndex(item =>
        item.originalUrl === originalUrl && item.fileType === fileType
      );

      if (existingIndex !== -1) {
        // URL already exists - update it with the new blob URL
        console.log(`üìç URL already exists at index ${existingIndex}, updating blob URL`);
        browserHistory[existingIndex].blobUrl = blobUrl;
        browserHistory[existingIndex].title = title || displayUrl;
        currentHistoryIndex = existingIndex;
        updateBrowserUI();
        saveHistoryToStorage();
        return;
      }

      // New URL - always append to the end (tab bar behavior)
      browserHistory.push({
        displayUrl,
        blobUrl,
        title: title || displayUrl,
        external,
        originalUrl,
        fileType
      });
      currentHistoryIndex = browserHistory.length - 1;

      console.log('‚úÖ History updated:', {
        newHistoryLength: browserHistory.length,
        newCurrentIndex: currentHistoryIndex,
        allTitles: browserHistory.map(h => h.title || h.displayUrl)
      });

      updateBrowserUI();
      saveHistoryToStorage();
    }

    // Address bar navigation (Enter key) - uses auto-detection
    document.getElementById('address-bar').addEventListener('keypress', async (e) => {
      if (e.key === 'Enter') {
        loadContentWithAutoDetect();
      }
    });


    // Auto-detect file type using MIME sniffing
    let loadContentInProgress = false;
    async function loadContentWithAutoDetect() {
      if (loadContentInProgress) {
        console.log('[browser] loadContentWithAutoDetect already in progress, ignoring');
        return;
      }
      loadContentInProgress = true;

      const addressBar = document.getElementById('address-bar');
      const url = addressBar.value.trim();

      if (!url) {
        const status = document.getElementById('iframe-status');
        status.innerHTML = '<span style="color:#f59e0b">‚ö†Ô∏è Enter a URL in the address bar first.</span>';
        loadContentInProgress = false;
        return;
      }

      const status = document.getElementById('iframe-status');
      const progress = document.getElementById('iframe-progress');
      const iframe = document.getElementById('html-iframe');
      const videoContainer = document.getElementById('video-container');
      const canvas = document.getElementById('stream-canvas');
      const video = document.getElementById('mse-video');

      // Reset display: show iframe, hide video
      iframe.style.display = 'block';
      videoContainer.style.display = 'none';
      canvas.style.display = 'block';
      video.style.display = 'none';
      video.src = '';

      progress.style.display = 'none';
      progress.value = 0;

      // Stop any active browser stream
      if (activeBrowserStreamAbort) {
        activeBrowserStreamAbort.abort();
        activeBrowserStreamAbort = null;
      }

      try {
        const sdk = await connectSdk(status);
        if (!sdk) return;

        status.textContent = 'Fetching object...';
        const obj = url.startsWith('sia://')
          ? await sdk.sharedObject(url)
          : await sdk.object(url);
        const size = obj.size();

        // Large files: try streaming via WebCodecs (preferred) or MSE (fallback)
        const canStream = size > 40000000;
        if (canStream) {
          // Try WebCodecs first (handles B-frames, all codecs the browser supports)
          if (typeof VideoDecoder !== 'undefined') {
            status.textContent = 'Large file detected. Attempting WebCodecs streaming...';
            try {
              iframe.style.display = 'none';
              videoContainer.style.display = 'block';
              canvas.style.display = 'block';
              video.style.display = 'none';

              const result = await webcodecStream(sdk, obj, canvas, status, progress, url);
              activeBrowserStreamAbort = result;

              const displayUrl = `Video (streaming): ${url}`;
              addToHistory(displayUrl, null, displayUrl, false, url, 'video');
              status.innerHTML = `<span class="pass">${status.textContent}</span>`;
              return;
            } catch (wcErr) {
              console.error('[browser] WebCodecs streaming failed:', wcErr);
              activeBrowserStreamAbort = null;
            }
          }

          // Fall back to MSE if WebCodecs failed or unavailable
          if (window.MediaSource) {
            status.textContent = 'Trying MSE streaming...';
            try {
              iframe.style.display = 'none';
              videoContainer.style.display = 'block';
              canvas.style.display = 'none';
              video.style.display = 'block';

              const result = await transmuxAndStream(sdk, obj, video, status, progress);
              activeBrowserStreamAbort = result;

              const displayUrl = `Video (streaming): ${url}`;
              addToHistory(displayUrl, null, displayUrl, false, url, 'video');
              status.innerHTML = `<span class="pass">${status.textContent}</span>`;
              return;
            } catch (mseErr) {
              console.error('[browser] MSE streaming failed, falling back to full download:', mseErr);
              activeBrowserStreamAbort = null;
            }
          }

          // Both streaming methods failed ‚Äî fall through to full download
          iframe.style.display = 'block';
          videoContainer.style.display = 'none';
          status.textContent = 'Streaming unavailable, downloading full file...';
        }

        // Full download path (non-video files or streaming fallback)
        status.textContent = 'Downloading...';
        const result = await parallelDownload(url, status, progress, 'Downloading');
        const downloadedBlob = result.blob;

        // Detect type from the full file
        status.textContent = 'Detecting file type...';
        const detectedType = await fileTypeFromBlob(downloadedBlob);

        let mimeType = 'application/octet-stream';
        let typeLabel = 'Unknown';
        let fileType = 'unknown';

        if (detectedType) {
          mimeType = detectedType.mime;
          typeLabel = detectedType.ext.toUpperCase();

          // Categorize for history tracking
          if (mimeType.startsWith('image/')) {
            fileType = 'image';
            typeLabel = 'Image';
          } else if (mimeType.startsWith('video/')) {
            fileType = 'video';
            typeLabel = 'Video';
          } else if (mimeType.startsWith('audio/')) {
            fileType = 'audio';
            typeLabel = 'Audio';
          } else if (mimeType === 'application/pdf') {
            fileType = 'pdf';
            typeLabel = 'PDF';
          } else if (mimeType === 'text/html') {
            fileType = 'html';
            typeLabel = 'HTML';
          } else if (mimeType.startsWith('text/')) {
            fileType = 'text';
            typeLabel = 'Text';
          }

          status.textContent = `Detected: ${mimeType} (${detectedType.ext})`;
          console.log('üîç Type detected:', { mimeType, typeLabel, fileType, ext: detectedType.ext });
        } else {
          // Fallback: try to detect text by checking if it's valid UTF-8
          try {
            const sample = await downloadedBlob.slice(0, 1024).arrayBuffer();
            const text = new TextDecoder('utf-8', { fatal: true }).decode(sample);
            // If we got here, it's valid UTF-8 text
            if (text.includes('<html') || text.includes('<!DOCTYPE')) {
              mimeType = 'text/html';
              typeLabel = 'HTML';
              fileType = 'html';
            } else {
              mimeType = 'text/plain';
              typeLabel = 'Text';
              fileType = 'text';
            }
            status.textContent = `Detected: ${typeLabel} (fallback UTF-8 detection)`;
          } catch {
            // Not text, treat as binary
            status.textContent = 'Could not detect file type, treating as binary';
          }
        }

        // Create blob with appropriate wrapper for better display
        let blobUrl;
        const downloadStart = performance.now();

        if (fileType === 'video') {
          // Video that was too small to stream or streaming failed ‚Äî use iframe player
          const videoBlob = new Blob([downloadedBlob], { type: mimeType });
          const videoUrl = URL.createObjectURL(videoBlob);
          const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;margin:0;background:#0a0a0a;color:#e0e0e0;font-family:system-ui,sans-serif;padding:2rem;}video{width:100%;max-width:1200px;background:#000;}</style></head><body><video controls autoplay><source src="${videoUrl}" type="${mimeType}">Your browser does not support the video element.</video><p style="margin-top:1rem;color:#888;">File size: ${formatSize(size)} | Type: ${mimeType}</p></body></html>`;
          const blob = new Blob([html], { type: 'text/html' });
          blobUrl = URL.createObjectURL(blob);

        } else if (fileType === 'text') {
          // Decode text from the already-downloaded blob
          const text = new TextDecoder().decode(new Uint8Array(await downloadedBlob.arrayBuffer()));
          const escapedText = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
          const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{font-family:'Courier New',monospace;padding:1.5rem;background:#0a0a0a;color:#e0e0e0;margin:0;}pre{white-space:pre-wrap;word-wrap:break-word;margin:0;line-height:1.5;}</style></head><body><pre>${escapedText}</pre></body></html>`;
          const blob = new Blob([html], { type: 'text/html' });
          blobUrl = URL.createObjectURL(blob);

        } else if (fileType === 'audio') {
          const audioBlob = new Blob([downloadedBlob], { type: mimeType });
          const audioUrl = URL.createObjectURL(audioBlob);
          const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><style>body{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;margin:0;background:#0a0a0a;color:#e0e0e0;font-family:system-ui,sans-serif;}audio{width:90%;max-width:600px;}</style></head><body><h2 style="margin-bottom:2rem;">üéµ Audio Player</h2><audio controls autoplay><source src="${audioUrl}" type="${mimeType}">Your browser does not support the audio element.</audio></body></html>`;
          const blob = new Blob([html], { type: 'text/html' });
          blobUrl = URL.createObjectURL(blob);

        } else if (fileType === 'pdf') {
          const pdfBlob = new Blob([downloadedBlob], { type: 'application/pdf' });
          blobUrl = URL.createObjectURL(pdfBlob);
          window.open(blobUrl, '_blank');

          const displayUrl = `PDF: ${url}`;
          addToHistory(displayUrl, blobUrl, displayUrl, true, url, 'pdf');

          const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
          status.innerHTML = `Size: ${formatSize(size)}\nDetected: ${mimeType}\nLoaded in ${elapsed}s\n<span class="pass">PDF opened in new tab!</span>`;
          return;

        } else {
          // For other types (image, html, unknown), load directly
          blobUrl = URL.createObjectURL(new Blob([downloadedBlob], { type: mimeType }));
        }

        console.log(`üé¨ LINE 1712 - Setting iframe.src for ${fileType} (non-MSE path)`);
        iframe.src = blobUrl;

        const displayUrl = `${typeLabel}: ${url}`;
        addToHistory(displayUrl, blobUrl, displayUrl, false, url, fileType);

        const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
        status.innerHTML = `Size: ${formatSize(size)}\nDetected: ${mimeType}\nLoaded in ${elapsed}s\n<span class="pass">${typeLabel} loaded!</span>`;
      } catch (e) {
        status.innerHTML = `<span class="fail">Error: ${e.message}</span>`;
      } finally {
        loadContentInProgress = false;
      }
    }

    // Go button - auto-detects file type
    document.getElementById('btn-go').addEventListener('click', loadContentWithAutoDetect);

    // Open in external tab (with warning)
    document.getElementById('btn-external-tab').addEventListener('click', async () => {
      // Show warning first
      const confirmed = confirm('‚ö†Ô∏è WARNING: This will allow the downloaded page to execute JavaScript!\n\nOpening content in an external tab removes all sandbox protections. Only proceed if you trust the content.\n\nUse the Go button (sandboxed iframe) for untrusted content.');

      if (!confirmed) return;

      const status = document.getElementById('iframe-status');

      // Check if we have a current history item with blob URL - reuse it!
      if (currentHistoryIndex >= 0 && browserHistory[currentHistoryIndex]) {
        const currentItem = browserHistory[currentHistoryIndex];
        if (currentItem.blobUrl) {
          console.log('Reusing already-downloaded blob for external tab');
          window.open(currentItem.blobUrl, '_blank');
          status.innerHTML = '<span class="pass">‚úì Opened in external tab (reused downloaded file)!</span>';
          return;
        }
      }

      // No current blob URL - need to download from address bar
      const addressBar = document.getElementById('address-bar');
      const url = addressBar.value.trim();

      if (!url) {
        status.innerHTML = '<span style="color:#f59e0b">‚ö†Ô∏è Enter a URL in the address bar first.</span>';
        return;
      }

      // Download and open in new tab
      const progress = document.getElementById('iframe-progress');

      progress.style.display = 'none';
      progress.value = 0;

      try {
        status.textContent = 'Downloading for external tab...';

        const { blob: downloadedBlob } = await parallelDownload(url, status, progress, 'Downloading');

        // Detect MIME type
        status.textContent = 'Detecting file type...';
        const detectedType = await fileTypeFromBlob(downloadedBlob);

        let mimeType = 'application/octet-stream';
        let fileType = 'external';

        if (detectedType) {
          mimeType = detectedType.mime;
          console.log('External tab - detected MIME type:', mimeType);

          // Categorize for history
          if (mimeType.startsWith('image/')) fileType = 'image';
          else if (mimeType.startsWith('video/')) fileType = 'video';
          else if (mimeType.startsWith('audio/')) fileType = 'audio';
          else if (mimeType === 'application/pdf') fileType = 'pdf';
          else if (mimeType === 'text/html') fileType = 'html';
          else if (mimeType.startsWith('text/')) fileType = 'text';
        } else {
          // Fallback: check if it's valid UTF-8 text
          try {
            const sample = await downloadedBlob.slice(0, 1024).arrayBuffer();
            const text = new TextDecoder('utf-8', { fatal: true }).decode(sample);
            if (text.includes('<html') || text.includes('<!DOCTYPE')) {
              mimeType = 'text/html';
              fileType = 'html';
            } else {
              mimeType = 'text/plain';
              fileType = 'text';
            }
          } catch {
            // Binary file, use default
            console.log('External tab - could not detect type, using default');
          }
        }

        // Open in external tab with detected MIME type
        const blob = new Blob([downloadedBlob], { type: mimeType });
        const blobUrl = URL.createObjectURL(blob);
        window.open(blobUrl, '_blank');

        // Add to history with external flag
        const displayUrl = `External (${fileType}): ${url}`;
        addToHistory(displayUrl, blobUrl, displayUrl, true, url, fileType);

        status.innerHTML = `<span class="pass">‚úì Opened in external tab as ${mimeType}!</span>`;
      } catch (e) {
        status.innerHTML = `<span class="fail">Error: ${e.message}</span>`;
      }
    });

    // Listen for messages from iframe (e.g., from example.html buttons)
    window.addEventListener('message', async (event) => {
      const { type, url, title } = event.data;

      if (type === 'LOAD_IN_VIEWER') {
        // Load the share URL in the iframe viewer
        const status = document.getElementById('iframe-status');
        const progress = document.getElementById('iframe-progress');
        const iframe = document.getElementById('html-iframe');
        const browserNav = document.getElementById('browser-nav');
        const browserContainer = document.getElementById('browser-container');

        progress.style.display = 'none';
        progress.value = 0;

        try {
          status.textContent = `Loading ${title || 'file'}...`;

          const { blob, elapsed, size } = await parallelDownload(url, status, progress, 'Downloading');

          // Load into iframe (let browser detect content type)
          const blobUrl = URL.createObjectURL(blob);
          iframe.src = blobUrl;

          // Add to history
          const displayUrl = title || url;
          addToHistory(displayUrl, blobUrl, title, false, url, 'html');

          status.innerHTML = `Size: ${formatSize(size)}\nLoaded in ${elapsed}s\n<span class="pass">${title || 'File'} loaded!</span>`;
        } catch (e) {
          status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
        }
      } else if (type === 'LOAD_IN_NEW_TAB') {
        // Download and open in new tab
        const status = document.getElementById('iframe-status');
        const progress = document.getElementById('iframe-progress');

        progress.style.display = 'none';
        progress.value = 0;

        try {
          status.textContent = `Downloading ${title || 'file'}...`;

          const { blob, elapsed, size } = await parallelDownload(url, status, progress, 'Downloading');

          // Open in new tab (let browser detect content type)
          const blobUrl = URL.createObjectURL(blob);
          window.open(blobUrl, '_blank');

          status.innerHTML = `Size: ${formatSize(size)}\nDownloaded in ${elapsed}s\n<span class="pass">${title || 'File'} opened in new tab!</span>`;

          // Clean up blob URL after a delay
          setTimeout(() => URL.revokeObjectURL(blobUrl), 1000);
        } catch (e) {
          status.innerHTML += `\n<span class="fail">Error: ${e.message}</span>`;
        }
      }
    });

    // ===== Stream Video Section =====

    // --- WebCodecs streaming pipeline (handles B-frames correctly) ---

    async function webcodecStream(sdk, obj, canvasEl, statusEl, progressEl, objectUrl) {
      if (typeof VideoDecoder === 'undefined') {
        throw new Error('WebCodecs API not supported in this browser');
      }

      const totalSize = obj.size();
      statusEl.textContent = `File size: ${formatSize(totalSize)}. Initializing WebCodecs...`;

      const mp4box = createMP4Box();

      // State
      let byteOffset = 0;
      let downloadComplete = false;
      let mp4boxReady = false;
      let aborted = false;
      let resolveAbort, rejectAbort;
      const abortPromise = new Promise((resolve, reject) => {
        resolveAbort = resolve;
        rejectAbort = reject;
      });

      // WebCodecs video decoder
      let videoDecoder = null;

      // Video rendering
      const ctx = canvasEl.getContext('2d');
      const frameBuffer = []; // holds only UNDISPLAYED future frames
      const FRAME_BUFFER_MAX = 6;
      let renderLoopRunning = false;
      let canvasSized = false;
      let paused = false;
      let pauseOffsetUs = 0; // microseconds of media time accumulated before pause

      // Audio via MSE (hidden <audio> element with SourceBuffer)
      let audioEl = null;
      let audioMediaSource = null;
      let audioSourceBuffer = null;
      const audioAppendQueue = [];
      let audioSbAppending = false;
      let hasAudio = false;
      let audioMode = null; // 'fmp4-mse' (setSegmentOptions) or 'raw-mse' (setExtractionOptions ‚Üí audio/mpeg)

      // Video-only timing (used when no audio clock is available)
      let wallClockStart = 0;   // performance.now() when first frame is displayed
      let videoTimeBase = -1;   // PTS (microseconds) of the first displayed video frame
      let wallClockSynced = false; // true once first frame display establishes timing

      // Stall compensation: when the main thread is blocked (WASM slab processing),
      // rAF stops firing. When it resumes, the wall clock has jumped forward.
      // Instead of skipping frames (visible stutter), we absorb the excess time
      // so the video effectively "pauses" during the stall and resumes smoothly.
      let lastRafTime = 0;
      const STALL_THRESHOLD_MS = 50; // gaps longer than 3 frames at 60fps = stall
      const NORMAL_FRAME_MS = 16.67; // expected rAF interval at 60Hz

      // Controls state
      let mediaDuration = 0; // from mp4box info, seconds
      let videoTrackId = null;
      let audioTrackId = null;

      // Seek state
      let isSeeking = false;        // true while user is dragging the scrub bar
      let seekInProgress = false;   // prevents concurrent seeks
      let pendingSeekTime = null;   // queued seek during an in-progress seek
      let seekPendingDraw = false;  // true after seekTo(), cleared after drawing one frame while paused
      let bufferedDurationSec = 0;
      let lastBufferedUpdateTime = 0;

      // Returns current media time in microseconds
      function getCurrentMediaTimeUs() {
        if (paused) return pauseOffsetUs;
        if (hasAudio && audioEl) {
          // Always use audio as the clock when audio is active.
          // Stall video (return -1) until audio actually starts playing,
          // so video and audio are in sync from the very first frame.
          if (audioEl.paused || audioEl.currentTime === 0) return -1;
          return audioEl.currentTime * 1e6;
        }
        // No audio: use wall clock synced to first displayed frame
        if (!wallClockSynced) return -1; // timing not yet established
        const elapsedUs = (performance.now() - wallClockStart) * 1000;
        return videoTimeBase + elapsedUs;
      }

      // Returns the duration (seconds) up to which video data has been downloaded.
      function getBufferedDuration() {
        if (!mp4boxReady || videoTrackId === null) return 0;
        try {
          const samples = mp4box.getTrackSamplesInfo(videoTrackId);
          if (!samples || samples.length === 0) return 0;
          for (let i = samples.length - 1; i >= 0; i--) {
            if (samples[i].alreadyRead === samples[i].size) {
              const s = samples[i];
              return (s.cts + s.duration) / s.timescale;
            }
          }
        } catch (e) {}
        return 0;
      }

      function getBufferedDurationThrottled() {
        const now = performance.now();
        if (now - lastBufferedUpdateTime < 1000) return bufferedDurationSec;
        lastBufferedUpdateTime = now;
        bufferedDurationSec = getBufferedDuration();
        return bufferedDurationSec;
      }

      async function seekTo(timeSec) {
        if (!mp4boxReady || mediaDuration <= 0) return;

        if (seekInProgress) {
          pendingSeekTime = timeSec;
          return;
        }
        seekInProgress = true;

        // Clamp to buffered range
        const maxSeekable = downloadComplete ? mediaDuration : getBufferedDuration();
        timeSec = Math.max(0, Math.min(timeSec, maxSeekable - 0.1));

        console.log(`[webcodec] seekTo: ${timeSec.toFixed(2)}s (buffered: ${maxSeekable.toFixed(2)}s)`);

        // 1. Stop mp4box sample extraction
        mp4box.stop();

        // 2. Flush VideoDecoder ‚Äî drains in-flight decodes
        if (videoDecoder && videoDecoder.state === 'configured') {
          try {
            await videoDecoder.flush();
          } catch (e) {
            console.warn('[webcodec] decoder flush on seek:', e);
          }
        }

        // 3. Clear pending video samples and frame buffer
        pendingVideoSamples.length = 0;
        while (frameBuffer.length > 0) frameBuffer.shift().close();

        // 4. Seek mp4box to nearest keyframe
        mp4box.seek(timeSec, true);

        // 5. Reset timing
        const seekTimeUs = timeSec * 1e6;
        pauseOffsetUs = seekTimeUs;
        videoTimeBase = seekTimeUs;
        wallClockStart = performance.now();
        wallClockSynced = true;
        lastRafTime = wallClockStart;

        // 6. Handle audio seek
        if (hasAudio && audioEl) {
          audioAppendQueue.length = 0;

          // Abort any in-progress SourceBuffer operation
          if (audioSourceBuffer && audioSourceBuffer.updating) {
            try { audioSourceBuffer.abort(); } catch (e) {}
            audioSbAppending = false;
          }

          // For raw-mse, set timestampOffset so new data is positioned correctly
          if (audioMode === 'raw-mse' && audioSourceBuffer) {
            try { audioSourceBuffer.timestampOffset = timeSec; } catch (e) {}
          }

          audioEl.currentTime = timeSec;
          if (paused) {
            audioEl.pause();
          } else {
            audioEl.play().catch(() => {});
          }
        }

        // 7. Re-anchor wall clock for non-audio case
        if (!hasAudio && !paused) {
          wallClockStart = performance.now();
          videoTimeBase = seekTimeUs;
        }

        // 8. Restart mp4box extraction from new position
        seekPendingDraw = true;
        mp4box.start();

        seekInProgress = false;

        // If another seek was requested during this one, execute it
        if (pendingSeekTime !== null) {
          const t = pendingSeekTime;
          pendingSeekTime = null;
          seekTo(t);
        }
      }

      // --- Video frame rendering ---
      // Key design: frames are CONSUMED (shifted + closed) immediately after drawing.
      // The canvas retains the drawn pixels, so we don't need to hold the VideoFrame.
      // This frees buffer slots so the decoder output callback doesn't evict
      // undisplayed frames.
      function renderLoop() {
        if (aborted) {
          while (frameBuffer.length > 0) frameBuffer.shift().close();
          return;
        }

        // Stall compensation: if the main thread was blocked (WASM slab processing,
        // mp4box parsing), absorb the excess time so the clock doesn't jump forward.
        // This makes the video "pause" during stalls instead of skipping frames.
        const now = performance.now();
        if (lastRafTime > 0 && wallClockSynced && !hasAudio && !paused) {
          const gapMs = now - lastRafTime;
          if (gapMs > STALL_THRESHOLD_MS) {
            const excessMs = gapMs - NORMAL_FRAME_MS;
            wallClockStart += excessMs; // shift clock forward = time "didn't pass"
          }
        }
        lastRafTime = now;

        // Drip-feed queued samples to decoders (backpressure via decodeQueueSize)
        feedSamples();

        if (paused) {
          // After a seek while paused, draw the first available frame as a preview
          if (seekPendingDraw && frameBuffer.length > 0) {
            seekPendingDraw = false;
            let frameToDraw = null;
            while (frameBuffer.length > 0) {
              if (frameToDraw) frameToDraw.close();
              frameToDraw = frameBuffer.shift();
            }
            if (frameToDraw) {
              ctx.drawImage(frameToDraw, 0, 0, canvasEl.width, canvasEl.height);
              frameToDraw.close();
            }
          }
          requestAnimationFrame(renderLoop);
          return;
        }

        // Establish timing on first available frame (not on onReady)
        if (!wallClockSynced && !hasAudio && frameBuffer.length > 0) {
          videoTimeBase = frameBuffer[0].timestamp; // microseconds
          wallClockStart = performance.now();
          wallClockSynced = true;
          lastRafTime = wallClockStart; // reset so first real frame doesn't trigger stall detection
          console.log(`[webcodec] timing synced: videoTimeBase=${videoTimeBase} bufLen=${frameBuffer.length}`);
        }

        const mediaTimeUs = getCurrentMediaTimeUs();
        if (mediaTimeUs < 0) {
          requestAnimationFrame(renderLoop);
          return;
        }

        // Find the latest frame whose time has arrived, consume all older ones
        let frameToDraw = null;
        while (frameBuffer.length > 0 && frameBuffer[0].timestamp <= mediaTimeUs) {
          if (frameToDraw) frameToDraw.close(); // skip intermediate frames
          frameToDraw = frameBuffer.shift();
        }

        if (frameToDraw) {
          // Size canvas to video's native resolution for full quality rendering.
          // CSS object-fit:contain handles display scaling without quality loss.
          if (!canvasSized) {
            canvasEl.width = frameToDraw.displayWidth;
            canvasEl.height = frameToDraw.displayHeight;
            canvasSized = true;
            console.log(`[webcodec] canvas sized to native ${frameToDraw.displayWidth}x${frameToDraw.displayHeight}`);
          }

          ctx.drawImage(frameToDraw, 0, 0, canvasEl.width, canvasEl.height);
          frameToDraw.close();
        }
        // else: no new frame ready ‚Äî canvas retains the last drawn content

        // Update time display and seek bar
        const mediaTimeSec = mediaTimeUs / 1e6;
        const timeEl = document.getElementById('vc-time');
        if (timeEl) {
          const m = Math.floor(mediaTimeSec / 60);
          const s = Math.floor(mediaTimeSec % 60);
          const pad = s < 10 ? '0' : '';
          if (mediaDuration > 0) {
            const dm = Math.floor(mediaDuration / 60);
            const ds = Math.floor(mediaDuration % 60);
            const dpad = ds < 10 ? '0' : '';
            timeEl.textContent = `${m}:${pad}${s} / ${dm}:${dpad}${ds}`;
          } else {
            timeEl.textContent = `${m}:${pad}${s}`;
          }
        }

        // Update seek bar (unless user is dragging)
        if (!isSeeking && mediaDuration > 0) {
          const playedPct = Math.min(100, (mediaTimeSec / mediaDuration) * 100);
          if (seekPlayedEl) seekPlayedEl.style.width = playedPct + '%';
          if (seekThumbEl) seekThumbEl.style.left = playedPct + '%';

          // Update buffered indicator (throttled to 1Hz)
          const bufDur = getBufferedDurationThrottled();
          const bufPct = Math.min(100, (bufDur / mediaDuration) * 100);
          if (seekBufferedEl) seekBufferedEl.style.width = bufPct + '%';
        }

        requestAnimationFrame(renderLoop);
      }

      let framesReceived = 0;
      function bufferVideoFrame(frame) {
        if (aborted) { frame.close(); return; }
        framesReceived++;
        if (framesReceived <= 5) {
          console.log(`[webcodec] bufferVideoFrame #${framesReceived}: ts=${frame.timestamp} bufLen=${frameBuffer.length}`);
        }
        // No eviction ‚Äî feed rate is controlled to prevent overflow
        frameBuffer.push(frame);
      }

      // --- Rate-controlled sample feeding ---
      // Feed based on total pipeline depth (decode queue + frame buffer).
      // At most 1 video sample per call to prevent flooding.
      const pendingVideoSamples = [];
      const PIPELINE_MAX = 12; // max total items in decode queue + frame buffer

      let samplesFed = 0;
      function feedSamples() {
        if (!videoDecoder || videoDecoder.state !== 'configured') return;
        // Feed more aggressively when buffer is empty (startup / seeking)
        // Otherwise feed 2 per tick (handles up to 120fps video at 60Hz display)
        const maxFeed = frameBuffer.length === 0 ? 8 : 2;
        let fed = 0;
        while (pendingVideoSamples.length > 0 && fed < maxFeed) {
          const pipelineDepth = videoDecoder.decodeQueueSize + frameBuffer.length;
          if (pipelineDepth >= PIPELINE_MAX) break;
          const s = pendingVideoSamples.shift();
          fed++;
          samplesFed++;
          if (samplesFed <= 10) {
            console.log(`[webcodec] feed #${samplesFed}: cts=${s.cts} sync=${s.is_sync} pipeline=${pipelineDepth} pending=${pendingVideoSamples.length}`);
          }
          try {
            videoDecoder.decode(new EncodedVideoChunk({
              type: s.is_sync ? 'key' : 'delta',
              timestamp: (s.cts * 1e6) / s.timescale,
              duration: (s.duration * 1e6) / s.timescale,
              data: s.data,
            }));
          } catch (e) {}
        }
        // Audio is handled via MSE (onSegment ‚Üí SourceBuffer), not WebCodecs
      }

      // --- Audio via MSE: drain fMP4 segments into SourceBuffer ---
      function drainAudioQueue() {
        if (!audioSourceBuffer || audioSbAppending || audioAppendQueue.length === 0) return;
        if (audioMediaSource.readyState !== 'open') return;
        const buf = audioAppendQueue.shift();
        audioSbAppending = true;
        try {
          audioSourceBuffer.appendBuffer(buf);
        } catch (e) {
          audioSbAppending = false;
          if (e.name === 'QuotaExceededError') {
            audioAppendQueue.unshift(buf);
            // Evict old audio data
            if (audioSourceBuffer.buffered.length > 0 && audioEl) {
              const removeEnd = audioEl.currentTime - 5;
              if (removeEnd > audioSourceBuffer.buffered.start(0)) {
                audioSourceBuffer.remove(audioSourceBuffer.buffered.start(0), removeEnd);
              }
            }
          } else {
            console.warn('[webcodec] Audio appendBuffer error:', e);
          }
        }
      }

      function maybeEndAudioStream() {
        if (!downloadComplete || audioAppendQueue.length > 0 || audioSbAppending) return;
        if (audioMediaSource && audioMediaSource.readyState === 'open') {
          try { audioMediaSource.endOfStream(); } catch (e) {}
        }
      }

      // --- Codec description extraction (W3C WebCodecs pattern) ---
      function getCodecDescription(box) {
        const stream = new DataStream(undefined, 0, Endianness.BIG_ENDIAN);
        box.write(stream);
        return new Uint8Array(stream.buffer, 8); // Skip 8-byte box header (size + type)
      }

      // --- mp4box onReady: configure WebCodecs decoders ---
      // IMPORTANT: This handler MUST be fully synchronous. mp4box calls onReady
      // synchronously during appendBuffer(). If we use async/await, the handler
      // yields and mp4box continues processing samples without extraction options
      // set, losing all samples from the current and subsequent buffers until
      // the async handler resumes. setExtractionOptions + start() must happen
      // before this function returns.
      mp4box.onReady = (info) => {
        mp4boxReady = true;
        console.log('[webcodec] onReady. Tracks:', info.tracks.map(t => ({
          id: t.id, codec: t.codec, video: !!t.video, audio: !!t.audio,
          type: t.type, name: t.name
        })));

        // Duration from mp4box (in timescale units)
        if (info.duration && info.timescale) {
          mediaDuration = info.duration / info.timescale;
        }

        const mediaTracks = info.tracks.filter(t => t.video || t.audio);
        if (mediaTracks.length === 0) {
          rejectAbort(new Error('No video or audio tracks found'));
          return;
        }

        const trackDescs = mediaTracks.map(t =>
          `${t.video ? 'video' : 'audio'} (${t.codec})`
        ).join(', ');
        statusEl.textContent = `Tracks: ${trackDescs}. Configuring decoders...`;

        // FIRST: set extraction options and start SYNCHRONOUSLY so mp4box
        // begins extracting samples immediately from this appendBuffer call.
        // We configure decoders below; onSamples will queue samples until ready.
        videoTrackId = null;
        audioTrackId = null;

        for (const track of mediaTracks) {
          if (track.video && videoTrackId === null) {
            videoTrackId = track.id;
          }
        }

        // Pick first audio track whose codec is supported by MSE.
        // Pass 1: try fMP4 MSE (setSegmentOptions ‚Üí onSegment ‚Üí SourceBuffer with video/mp4 MIME)
        // Pass 2: try raw MSE (setExtractionOptions ‚Üí onSamples ‚Üí SourceBuffer with audio/mpeg MIME)
        let audioTrack = null;
        if (audioMediaSource && audioMediaSource.readyState === 'open') {
          // Pass 1: fMP4 MSE
          for (const track of mediaTracks) {
            if (!track.audio) continue;
            const mime = `video/mp4; codecs="${track.codec}"`;
            if (MediaSource.isTypeSupported(mime)) {
              audioTrackId = track.id;
              audioTrack = track;
              audioMode = 'fmp4-mse';
              console.log(`[webcodec] Selected audio track ${track.id}: ${track.codec} via fMP4 MSE (${mime})`);
              break;
            } else {
              console.log(`[webcodec] Skipping audio track ${track.id}: ${track.codec} (${mime} not supported for fMP4 MSE)`);
            }
          }

          // Pass 2: raw MSE ‚Äî for codecs stored as raw frames (e.g. MP3 in MP4 container)
          if (!audioTrack) {
            const rawMimeMap = {
              'mp4a.6b': 'audio/mpeg', // MP3 (MPEG-1 Layer 3, OTI 0x6B)
              'mp4a.69': 'audio/mpeg', // MP3 (MPEG-2 Layer 3, OTI 0x69)
            };
            for (const track of mediaTracks) {
              if (!track.audio) continue;
              const rawMime = rawMimeMap[track.codec];
              if (rawMime && MediaSource.isTypeSupported(rawMime)) {
                audioTrackId = track.id;
                audioTrack = track;
                audioMode = 'raw-mse';
                console.log(`[webcodec] Selected audio track ${track.id}: ${track.codec} via raw MSE (${rawMime})`);
                break;
              } else if (rawMime) {
                console.log(`[webcodec] Skipping audio track ${track.id}: ${track.codec} (${rawMime} not supported for raw MSE)`);
              }
            }
          }
        }

        // Video: raw samples via setExtractionOptions ‚Üí onSamples ‚Üí WebCodecs VideoDecoder
        if (videoTrackId !== null) {
          mp4box.setExtractionOptions(videoTrackId, 'video', { nbSamples: 200 });
        }

        // Audio setup: two paths depending on audioMode
        if (audioTrack !== null && audioMode === 'fmp4-mse') {
          // fMP4 MSE: setSegmentOptions ‚Üí onSegment ‚Üí SourceBuffer (video/mp4 MIME)
          const audioMime = `video/mp4; codecs="${audioTrack.codec}"`;
          mp4box.setSegmentOptions(audioTrackId, 'audio', { nbSamples: 100, rapAlignment: true });
          const initResult = mp4box.initializeSegmentation();
          console.log(`[webcodec] Audio fMP4 MSE: ${audioMime}, init segment: ${initResult.buffer?.byteLength} bytes`);

          audioSourceBuffer = audioMediaSource.addSourceBuffer(audioMime);
          audioSourceBuffer.addEventListener('updateend', () => {
            audioSbAppending = false;
            drainAudioQueue();
            maybeEndAudioStream();
          });
          audioSourceBuffer.addEventListener('error', (e) => {
            console.warn('[webcodec] Audio SourceBuffer error:', e);
            hasAudio = false;
          });

          // Queue init segment
          if (initResult.buffer) {
            audioAppendQueue.push(initResult.buffer);
            drainAudioQueue();
          }

          hasAudio = true;
          audioEl.play().catch(e => console.warn('[webcodec] Audio autoplay blocked:', e.message));
          console.log(`[webcodec] Audio via fMP4 MSE: ${audioTrack.codec} ${audioTrack.audio.sample_rate}Hz ${audioTrack.audio.channel_count}ch`);
        } else if (audioTrack !== null && audioMode === 'raw-mse') {
          // Raw MSE: setExtractionOptions ‚Üí onSamples ‚Üí SourceBuffer (audio/mpeg MIME)
          const rawMimeMap = { 'mp4a.6b': 'audio/mpeg', 'mp4a.69': 'audio/mpeg' };
          const rawMime = rawMimeMap[audioTrack.codec];
          mp4box.setExtractionOptions(audioTrackId, 'audio', { nbSamples: 200 });
          console.log(`[webcodec] Audio raw MSE: ${rawMime} (codec: ${audioTrack.codec})`);

          audioSourceBuffer = audioMediaSource.addSourceBuffer(rawMime);
          audioSourceBuffer.addEventListener('updateend', () => {
            audioSbAppending = false;
            drainAudioQueue();
            maybeEndAudioStream();
          });
          audioSourceBuffer.addEventListener('error', (e) => {
            console.warn('[webcodec] Audio SourceBuffer error:', e);
            hasAudio = false;
          });

          // No init segment for raw audio streams
          hasAudio = true;
          audioEl.play().catch(e => console.warn('[webcodec] Audio autoplay blocked:', e.message));
          console.log(`[webcodec] Audio via raw MSE: ${audioTrack.codec} ${audioTrack.audio.sample_rate}Hz ${audioTrack.audio.channel_count}ch`);
        }

        mp4box.start();

        // Configure video decoder synchronously (no await).
        for (const track of mediaTracks) {
          if (track.video && !videoDecoder && track.id === videoTrackId) {
            try {
              const trak = mp4box.getTrackById(track.id);
              const entry = trak.mdia.minf.stbl.stsd.entries[0];
              const descBox = entry.avcC || entry.hvcC || entry.vpcC || entry.av1C;

              let description;
              if (descBox) {
                description = getCodecDescription(descBox);
              }

              const config = {
                codec: track.codec,
                codedWidth: track.video.width,
                codedHeight: track.video.height,
                description: description,
              };

              videoDecoder = new VideoDecoder({
                output: bufferVideoFrame,
                error: (e) => {
                  console.error('[webcodec] VideoDecoder error:', e);
                  if (!aborted) {
                    aborted = true;
                    rejectAbort(new Error(`Video decoder error: ${e.message}`));
                  }
                }
              });
              videoDecoder.configure(config);

              console.log(`[webcodec] VideoDecoder configured: ${track.codec} ${track.video.width}x${track.video.height}`);
            } catch (e) {
              console.warn(`[webcodec] Failed to configure video track ${track.id}:`, e);
              videoDecoder = null;
            }
          }
        }

        if (!videoDecoder) {
          rejectAbort(new Error('No supported video codec found'));
          return;
        }

        // Start render loop (timing is established when the first frame is displayed)
        renderLoopRunning = true;
        requestAnimationFrame(renderLoop);

        statusEl.textContent = `Streaming: ${trackDescs}`;
      };

      // --- mp4box onSamples: queue raw video samples for rate-controlled feeding ---
      // Audio is handled here only in raw-mse mode; fmp4-mse audio uses onSegment instead.
      let videoSampleCount = 0;
      mp4box.onSamples = (trackId, user, samples) => {
        if (aborted) return;

        if (user === 'audio' && audioMode === 'raw-mse') {
          // Raw MSE: push raw MP3 frames directly to SourceBuffer
          for (const sample of samples) {
            if (aborted) break;
            // sample.data is a Uint8Array; copy to a standalone ArrayBuffer for the queue
            const buf = sample.data.buffer.slice(
              sample.data.byteOffset,
              sample.data.byteOffset + sample.data.byteLength
            );
            audioAppendQueue.push(buf);
          }
          drainAudioQueue();
          return;
        }

        if (user !== 'video') return;

        if (videoSampleCount === 0) {
          console.log(`[webcodec] First video samples batch: ${samples.length} samples`);
        }

        for (const sample of samples) {
          if (aborted) break;
          videoSampleCount++;
          pendingVideoSamples.push(sample);
        }
      };

      // --- mp4box onSegment: feed audio fMP4 segments to MSE SourceBuffer ---
      let audioSegmentCount = 0;
      mp4box.onSegment = (trackId, user, buffer) => {
        if (aborted) return;
        if (user === 'audio') {
          audioSegmentCount++;
          if (audioSegmentCount <= 3) {
            console.log(`[webcodec] Audio segment #${audioSegmentCount}: size=${buffer.byteLength}`);
          }
          audioAppendQueue.push(buffer);
          drainAudioQueue();
        }
      };

      mp4box.onError = (e) => {
        console.error('[webcodec] mp4box error:', e);
      };

      // --- Controls wiring (set up before download starts so controls work during streaming) ---
      const container = document.getElementById('video-container');
      const controlsEl = document.getElementById('video-controls');
      const playBtn = document.getElementById('vc-playpause');
      const volSlider = document.getElementById('vc-volume');
      const fsBtn = document.getElementById('vc-fullscreen');
      const seekbarEl = document.getElementById('vc-seekbar');
      const seekPlayedEl = document.getElementById('vc-seek-played');
      const seekBufferedEl = document.getElementById('vc-seek-buffered');
      const seekThumbEl = document.getElementById('vc-seek-thumb');

      let hideTimeout;
      function showControls() {
        controlsEl.style.opacity = '1';
        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(() => { controlsEl.style.opacity = '0'; }, 3000);
      }
      container.addEventListener('mousemove', showControls);
      container.addEventListener('mouseenter', showControls);
      showControls();

      function togglePause() {
        if (paused) {
          // Resume: adjust wall clock so timing picks up from where we paused
          paused = false;
          if (wallClockSynced && !hasAudio) {
            wallClockStart = performance.now() - ((pauseOffsetUs - videoTimeBase) / 1000);
          }
          if (audioEl && audioEl.paused) audioEl.play().catch(() => {});
          playBtn.innerHTML = '&#9646;&#9646;';
        } else {
          // Pause: snapshot current media time
          paused = true;
          pauseOffsetUs = getCurrentMediaTimeUs();
          if (audioEl && !audioEl.paused) audioEl.pause();
          playBtn.innerHTML = '&#9654;';
        }
      }
      canvasEl.addEventListener('click', togglePause);
      playBtn.addEventListener('click', togglePause);
      playBtn.innerHTML = '&#9646;&#9646;';

      volSlider.addEventListener('input', () => {
        if (audioEl) audioEl.volume = parseFloat(volSlider.value);
      });

      fsBtn.addEventListener('click', () => {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        } else {
          container.requestFullscreen().catch(() => {});
        }
      });

      // --- Seek bar interaction ---
      let seekbarDragging = false;

      function seekbarPctFromEvent(e) {
        const rect = seekbarEl.getBoundingClientRect();
        const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
        return Math.max(0, Math.min(1, x / rect.width));
      }

      function seekbarUpdateTimeDisplay(timeSec) {
        const timeEl = document.getElementById('vc-time');
        if (!timeEl || mediaDuration <= 0) return;
        const m = Math.floor(timeSec / 60);
        const s = Math.floor(timeSec % 60);
        const pad = s < 10 ? '0' : '';
        const dm = Math.floor(mediaDuration / 60);
        const ds = Math.floor(mediaDuration % 60);
        const dpad = ds < 10 ? '0' : '';
        timeEl.textContent = `${m}:${pad}${s} / ${dm}:${dpad}${ds}`;
      }

      function seekbarClampPct(pct) {
        if (!downloadComplete && mediaDuration > 0) {
          const maxPct = Math.min(1, getBufferedDuration() / mediaDuration);
          return Math.min(pct, maxPct);
        }
        return pct;
      }

      function seekbarStartDrag(e) {
        if (mediaDuration <= 0) return;
        e.preventDefault();
        e.stopPropagation();
        seekbarDragging = true;
        isSeeking = true;
        seekThumbEl.style.opacity = '1';

        let pct = seekbarPctFromEvent(e);
        pct = seekbarClampPct(pct);
        seekPlayedEl.style.width = (pct * 100) + '%';
        seekThumbEl.style.left = (pct * 100) + '%';
        seekbarUpdateTimeDisplay(pct * mediaDuration);
      }

      function seekbarMoveDrag(e) {
        if (!seekbarDragging) return;
        e.preventDefault();
        let pct = seekbarPctFromEvent(e);
        pct = seekbarClampPct(pct);
        seekPlayedEl.style.width = (pct * 100) + '%';
        seekThumbEl.style.left = (pct * 100) + '%';
        seekbarUpdateTimeDisplay(pct * mediaDuration);
      }

      function seekbarEndDrag(e) {
        if (!seekbarDragging) return;
        seekbarDragging = false;
        isSeeking = false;

        // Calculate final position from last visual state
        const pctStr = seekPlayedEl.style.width;
        const pct = parseFloat(pctStr) / 100;
        seekTo(pct * mediaDuration);
      }

      seekbarEl.addEventListener('mousedown', seekbarStartDrag);
      document.addEventListener('mousemove', seekbarMoveDrag);
      document.addEventListener('mouseup', seekbarEndDrag);

      seekbarEl.addEventListener('touchstart', seekbarStartDrag, { passive: false });
      document.addEventListener('touchmove', seekbarMoveDrag, { passive: false });
      document.addEventListener('touchend', seekbarEndDrag);

      // Single click to seek (without drag)
      seekbarEl.addEventListener('click', (e) => {
        if (mediaDuration <= 0) return;
        e.stopPropagation();
        let pct = seekbarPctFromEvent(e);
        pct = seekbarClampPct(pct);
        seekTo(pct * mediaDuration);
      });

      // --- Set up hidden <audio> element with MSE for audio playback ---
      // The browser's native audio decoder (via MSE) handles multichannel AAC, Opus, etc.
      // that WebCodecs AudioDecoder cannot decode.
      if (window.MediaSource) {
        audioEl = document.createElement('audio');
        audioEl.style.display = 'none';
        document.body.appendChild(audioEl);
        audioMediaSource = new MediaSource();
        audioEl.src = URL.createObjectURL(audioMediaSource);

        // Wait for sourceopen before starting download (must be ready before onReady fires)
        await new Promise((resolve) => {
          if (audioMediaSource.readyState === 'open') resolve();
          else audioMediaSource.addEventListener('sourceopen', resolve, { once: true });
        });
        console.log('[webcodec] Audio MediaSource ready');
      }

      // --- Stream data from SDK via Web Worker ---
      progressEl.style.display = 'block';
      const downloadStart = performance.now();

      let chunkCount = 0;
      const worker = new Worker('./worker.js', { type: 'module' });

      const streamPromise = new Promise((resolveStream, rejectStream) => {
        worker.onmessage = (e) => {
          const msg = e.data;

          if (msg.type === 'chunk') {
            if (aborted) return;
            chunkCount++;
            const buf = msg.data; // Transferred ArrayBuffer (zero-copy)
            buf.fileStart = msg.offset;
            if (chunkCount <= 3) {
              console.log(`[webcodec] chunk #${chunkCount}: size=${msg.size} fileStart=${msg.offset}`);
            }
            byteOffset += msg.size;
            mp4box.appendBuffer(buf);
          } else if (msg.type === 'progress') {
            if (aborted) return;
            progressEl.max = msg.total;
            progressEl.value = msg.current;
            const pct = msg.total > 0 ? ((msg.current / msg.total) * 100).toFixed(0) : 0;
            statusEl.textContent = `Streaming: ${msg.current}/${msg.total} slabs (${pct}%) ‚Äî ${formatSize(byteOffset)} / ${formatSize(totalSize)}`;

            if (byteOffset > 50 * 1024 * 1024 && !mp4boxReady) {
              aborted = true;
              worker.terminate();
              rejectStream(new Error(
                'No moov atom found after 50 MB. The file may have moov at the end. ' +
                'Re-encode with "ffmpeg -i input.mp4 -movflags +faststart output.mp4" to fix.'
              ));
            }
          } else if (msg.type === 'complete') {
            resolveStream();
          } else if (msg.type === 'error') {
            rejectStream(new Error(msg.message));
          }
        };

        worker.onerror = (e) => {
          rejectStream(new Error(`Worker error: ${e.message}`));
        };
      });

      // Start the download worker
      worker.postMessage({
        type: 'start',
        indexerUrl: getUrl(),
        keyHex: getKeyHex(),
        maxDownloads: getMaxDownloads(),
        objectUrl: objectUrl,
        logLevel: getLogLevel(),
      });

      try {
        await Promise.race([streamPromise, abortPromise]);
      } catch (e) {
        aborted = true;
        worker.terminate();
        throw e;
      }
      worker.terminate();

      if (!aborted) {
        downloadComplete = true;
        mp4box.flush();
        progressEl.value = progressEl.max;

        // Wait for video decoder to finish processing queued samples
        try {
          if (videoDecoder && videoDecoder.state === 'configured') await videoDecoder.flush();
        } catch (e) {
          console.warn('[webcodec] Decoder flush error:', e);
        }

        // Signal end of audio stream to MSE
        maybeEndAudioStream();

        const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
        statusEl.textContent = `Stream complete! ${formatSize(totalSize)} in ${elapsed}s.`;
      }

      return {
        abort: () => {
          aborted = true;
          worker.terminate();
          try { mp4box.flush(); } catch (e) {}
          if (videoDecoder) try { videoDecoder.close(); } catch (e) {}
          if (audioEl) {
            try { audioEl.pause(); } catch (e) {}
            try { audioEl.remove(); } catch (e) {}
          }
          if (audioMediaSource && audioMediaSource.readyState === 'open') {
            try { audioMediaSource.endOfStream(); } catch (e) {}
          }
          while (frameBuffer.length > 0) frameBuffer.shift().close();
          clearTimeout(hideTimeout);
          resolveAbort();
        }
      };
    }

    // --- MSE streaming pipeline (legacy fallback for browsers without WebCodecs) ---

    async function transmuxAndStream(sdk, obj, videoEl, statusEl, progressEl) {
      if (!window.MediaSource) {
        throw new Error('MediaSource Extensions not supported in this browser');
      }

      const totalSize = obj.size();
      statusEl.textContent = `File size: ${formatSize(totalSize)}. Initializing...`;

      const mp4box = createMP4Box();
      const mediaSource = new MediaSource();
      videoEl.src = URL.createObjectURL(mediaSource);

      // State
      let byteOffset = 0;
      let downloadComplete = false;
      let mp4boxReady = false;
      let aborted = false;
      let resolveAbort, rejectAbort;
      const abortPromise = new Promise((resolve, reject) => {
        resolveAbort = resolve;
        rejectAbort = reject;
      });

      // Wait for sourceopen
      await new Promise((resolve, reject) => {
        mediaSource.addEventListener('sourceopen', resolve, { once: true });
        mediaSource.addEventListener('error', () => reject(new Error('MediaSource failed to open')), { once: true });
        setTimeout(() => reject(new Error('MediaSource sourceopen timeout')), 5000);
      });

      statusEl.textContent = 'MediaSource opened. Downloading first slab...';

      function maybeEndOfStream() {
        if (!downloadComplete) return;
        if (appendQueue.length > 0 || sbAppending) return;
        if (mediaSource.readyState === 'open') {
          try { mediaSource.endOfStream(); } catch (e) {}
        }
      }

      // mp4box v2 returns a single init segment for all tracks.
      // Use one combined SourceBuffer with all codecs.
      let sourceBuffer = null;
      const appendQueue = [];
      let sbAppending = false;

      mp4box.onReady = (info) => {
        mp4boxReady = true;
        console.log('[stream] onReady fired. All tracks:', info.tracks.map(t => ({
          id: t.id, codec: t.codec, video: !!t.video, audio: !!t.audio,
          type: t.type, name: t.name
        })));

        // Filter to only video and audio tracks (skip timecode, metadata, etc.)
        const mediaTracks = info.tracks.filter(t => t.video || t.audio);
        console.log('[stream] Media tracks:', mediaTracks.map(t => ({
          id: t.id, codec: t.codec, video: !!t.video, audio: !!t.audio,
        })));

        if (mediaTracks.length === 0) {
          rejectAbort(new Error('No video or audio tracks found'));
          return;
        }

        const trackDescs = mediaTracks.map(t =>
          `${t.video ? 'video' : 'audio'} (${t.codec})`
        ).join(', ');
        statusEl.textContent = `Tracks: ${trackDescs}. Starting playback...`;

        // Build combined codec string from media tracks only
        const codecs = mediaTracks.map(t => t.codec).join(', ');
        const mime = `video/mp4; codecs="${codecs}"`;
        console.log(`[stream] Combined MIME: ${mime}`);

        if (!MediaSource.isTypeSupported(mime)) {
          console.error(`[stream] MIME not supported: ${mime}`);
          rejectAbort(new Error(`Codec not supported by browser: ${mime}`));
          return;
        }

        sourceBuffer = mediaSource.addSourceBuffer(mime);
        sourceBuffer.addEventListener('updateend', () => {
          sbAppending = false;
          // After any operation completes, try to drain queued data
          if (needsEviction) {
            tryEvict();
          } else {
            drainAppendQueue();
          }
        });
        sourceBuffer.addEventListener('error', (e) => {
          console.error('[stream] SourceBuffer error:', e, 'readyState:', mediaSource.readyState);
          if (!aborted) {
            aborted = true;
            rejectAbort(new Error('SourceBuffer error ‚Äî the video may use features incompatible with browser streaming'));
          }
        });

        // Periodically evict old buffer data as video plays
        videoEl.addEventListener('timeupdate', () => {
          if (needsEviction && !sbAppending && sourceBuffer && !sourceBuffer.updating) {
            tryEvict();
          }
        });

        // Set segment options only for media tracks
        for (const track of mediaTracks) {
          mp4box.setSegmentOptions(track.id, null, { nbSamples: 100, rapAlignment: true });
        }

        // Get single combined init segment (mp4box v2 API)
        const initResult = mp4box.initializeSegmentation();
        console.log('[stream] Init segment:', {
          tracks: initResult.tracks,
          bufferSize: initResult.buffer?.byteLength
        });

        if (initResult.buffer) {
          appendQueue.push(initResult.buffer);
          drainAppendQueue();
        }

        mp4box.start();
        videoEl.play().catch(e => console.log('[stream] autoplay blocked:', e.message));
      };

      let needsEviction = false;

      function tryEvict() {
        if (aborted || !sourceBuffer || sourceBuffer.updating || sbAppending) return;
        if (mediaSource.readyState !== 'open') return;
        if (!sourceBuffer.buffered || sourceBuffer.buffered.length === 0) {
          // No buffered data yet, just retry the append
          needsEviction = false;
          drainAppendQueue();
          return;
        }

        const currentTime = videoEl.currentTime;
        const bufferedStart = sourceBuffer.buffered.start(0);
        const keepBehind = 5; // keep 5 seconds behind playhead

        if (currentTime - bufferedStart > keepBehind) {
          const removeEnd = currentTime - keepBehind;
          console.log(`[stream] Evicting buffer: ${bufferedStart.toFixed(1)}s ‚Üí ${removeEnd.toFixed(1)}s (playhead at ${currentTime.toFixed(1)}s)`);
          sbAppending = true;
          sourceBuffer.remove(bufferedStart, removeEnd);
          needsEviction = false;
          // updateend will fire ‚Üí sbAppending=false ‚Üí drainAppendQueue resumes
        } else {
          // Playhead hasn't advanced enough to evict. Wait for timeupdate.
          // Don't spam retries ‚Äî the timeupdate listener will trigger us.
        }
      }

      function drainAppendQueue() {
        if (aborted) return;
        if (!sourceBuffer || sbAppending || appendQueue.length === 0) {
          maybeEndOfStream();
          return;
        }
        // Guard against SourceBuffer removed from MediaSource
        if (mediaSource.readyState !== 'open') return;
        // Proactively evict if we have a lot buffered ahead
        if (sourceBuffer.buffered && sourceBuffer.buffered.length > 0) {
          const bufferedEnd = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
          const bufferedStart = sourceBuffer.buffered.start(0);
          const currentTime = videoEl.currentTime;
          // If buffer exceeds 60 seconds ahead of playhead, evict old data first
          if (bufferedEnd - currentTime > 60 && currentTime - bufferedStart > 5) {
            console.log(`[stream] Proactive eviction: ${(bufferedEnd - currentTime).toFixed(0)}s buffered ahead`);
            needsEviction = true;
            tryEvict();
            return;
          }
        }
        const buf = appendQueue.shift();
        sbAppending = true;
        try {
          sourceBuffer.appendBuffer(buf);
        } catch (e) {
          sbAppending = false;
          if (e.name === 'QuotaExceededError') {
            appendQueue.unshift(buf);
            if (!needsEviction) {
              console.warn('[stream] QuotaExceededError, waiting for playback to advance...');
            }
            needsEviction = true;
            tryEvict();
          } else {
            console.error('[stream] appendBuffer error:', e);
          }
        }
      }

      let segmentCount = 0;
      mp4box.onSegment = (trackId, user, buffer) => {
        segmentCount++;
        if (segmentCount <= 5 || segmentCount % 20 === 0) {
          console.log(`[stream] onSegment #${segmentCount}: track=${trackId} size=${buffer.byteLength}`);
        }
        appendQueue.push(buffer);
        if (!needsEviction) {
          drainAppendQueue();
        }
        // If needsEviction, don't try to drain ‚Äî wait for eviction to complete
      };

      mp4box.onError = (e) => {
        console.error('[stream] mp4box error:', e);
      };

      // Stream data
      progressEl.style.display = 'block';
      const downloadStart = performance.now();

      let chunkCount = 0;
      const dlOpts2 = new DownloadOptions();
      dlOpts2.maxInflight = getMaxDownloads();
      const streamPromise = sdk.downloadStreaming(obj, dlOpts2,
        (chunk) => {
          if (aborted) return;
          chunkCount++;
          const buf = chunk.buffer.slice(
            chunk.byteOffset,
            chunk.byteOffset + chunk.byteLength
          );
          buf.fileStart = byteOffset;
          if (chunkCount <= 3) {
            console.log(`[stream] chunk #${chunkCount}: size=${chunk.byteLength} fileStart=${byteOffset}`);
          }
          byteOffset += chunk.byteLength;
          mp4box.appendBuffer(buf);
        },
        (current, total) => {
          if (aborted) return;
          progressEl.max = total;
          progressEl.value = current;
          const pct = total > 0 ? ((current / total) * 100).toFixed(0) : 0;
          statusEl.textContent = `Streaming: ${current}/${total} slabs (${pct}%) ‚Äî ${formatSize(byteOffset)} / ${formatSize(totalSize)}`;

          // Detect moov-at-end or non-MP4: if enough data delivered and mp4box still hasn't parsed moov.
          // We check byteOffset (bytes actually fed to mp4box) rather than slab count because
          // the progress callback can fire before all chunk data from a slab is flushed.
          if (byteOffset > 50 * 1024 * 1024 && !mp4boxReady) {
            aborted = true;
            rejectAbort(new Error(
              'No moov atom found after 50 MB. The file may have moov at the end (common with GoPro/camera recordings). ' +
              'Re-encode with "ffmpeg -i input.mp4 -movflags +faststart output.mp4" to fix, or use the Download section.'
            ));
          }
        },
      );

      try {
        await Promise.race([streamPromise, abortPromise]);
      } catch (e) {
        // Silence callbacks from the still-running WASM download before
        // propagating the error ‚Äî prevents it from clobbering the status
        // element if the caller starts a fallback download.
        aborted = true;
        throw e;
      }

      if (!aborted) {
        downloadComplete = true;
        mp4box.flush();
        progressEl.value = progressEl.max;
        drainAppendQueue();
        const elapsed = ((performance.now() - downloadStart) / 1000).toFixed(1);
        statusEl.textContent = `Stream complete! ${formatSize(totalSize)} downloaded in ${elapsed}s.`;
      }

      return {
        abort: () => {
          aborted = true;
          try { mp4box.flush(); } catch (e) {}
          if (mediaSource.readyState === 'open') {
            try { mediaSource.endOfStream(); } catch (e) {}
          }
          resolveAbort();
        }
      };
    }

    let activeBrowserStreamAbort = null;

  </script>
</body>

</html>